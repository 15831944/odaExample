(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?module.exports=f():typeof define==='function'&&define.amd?define(f):(g=typeof globalThis!=='undefined'?globalThis:g||self,g.ODA=f());}(this,(function(){'use strict';///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
function json(request) {
  return request.then(response => response.json())
}

function text(request) {
  return request.then(response => response.text())
}

function arrayBuffer(request) {
  return request.then(response => response.arrayBuffer())
}

function options(method, headers, body, signal) {
  const opt =  {
    method,
    headers,
    body
  };
  signal && (opt.signal = signal);
  return opt
}

function catchHttpError(status) {
  return status > 400 ? Promise.reject(status): Promise.resolve()
  
}
function catchHttFetchError(request) {
  return request
  .then(response => {
    return catchHttpError(response.status)
     .then(() => request, () => response.json().then(json => Promise.reject(new Error(json.description))))
  })
}

function $get(url, headers, signal) {
  return catchHttFetchError(fetch(url, options("GET", headers, null, signal)))
}
function $put(url, headers, body) {
  if (typeof (body) === 'object') {
    if (body instanceof FormData) ; else if (!(body instanceof ArrayBuffer) && !(body instanceof Blob)) {
      body = JSON.stringify(body);
      headers = { ...headers, 'Content-Type': 'application/json' };
    }
  } else {
    headers = { ...headers, 'Content-Type': 'application/json' };
  }
  headers = { ...headers, 'Access-Control-Allow-Origin': '*', 'pragma': 'no-cache', 'cache-control': 'no-cache' };

  return catchHttFetchError(fetch(url, options("PUT", headers, body)))
}

// json || object 'content-type': 'application/json'
// FormData 'Content-Type': 'multipart/form-data'
function $post(url, headers, body) {
  if (typeof (body) === 'object') {
    if (body instanceof FormData) ; else if (!(body instanceof ArrayBuffer) && !(body instanceof Blob)) {
      body = JSON.stringify(body);
      headers = { ...headers, 'Content-Type': 'application/json' };
    }
  } else {
    headers = { ...headers, 'Content-Type': 'application/json' };
  }
  headers = { ...headers, 'Access-Control-Allow-Origin': '*', 'pragma': 'no-cache', 'cache-control': 'no-cache' };
  return catchHttFetchError(fetch(url, options("POST", headers, body)))
}

function $delete(url, headers, body) {
  return catchHttFetchError(fetch(url, options("DELETE", headers, body)))
}

function streamProgress(stream, onprogress) {
  const reader = stream.getReader();
  let current = 0;

  reader.read().then(calc).catch(console.error);

  function calc(ev) {
    if (!ev.done) {
      reader.read().then(calc).catch(console.error);
    }
    ev.value && (current += ev.value.length);
    onprogress(current);
  }
  return stream
}

function downloadProgress(response, onprogress) {
  const total = response.headers.get("Content-Length");
  const tee = response.body.tee();
  streamProgress(tee[0], bytesCount => onprogress && onprogress(bytesCount / total));
  return new Response(tee[1])
}

/* eslint no-unused-vars: off */
function $XMLHttp(url, {
  headers,
  method,
  body,
  uploadProgress,
  downloadProgress
}) {

      /* eslint no-unused-vars: off */
  function getDescription(text) {
    try{
      return JSON.parse(text).description
    }
    catch {
      return text
    }
  }

  return new Promise((resolve, reject) => {
    const req = new XMLHttpRequest();
    req.open(method, url, true);
    for (var key in headers) {
      req.setRequestHeader(key, headers[key]);
    }
    function calcProgress(ev) {
      return ev.lengthComputable ? ev.loaded / ev.total : 1
    }
    req.upload.onprogress = ev => uploadProgress && uploadProgress(calcProgress(ev));
    req.onprogress = ev => downloadProgress && downloadProgress(calcProgress(ev));

    req.onloadend = ev => catchHttpError(req.status).then(() => resolve(req), ()=> reject(new Error(getDescription(ev.target.responseText))));
    req.onerror = ev => reject(ev);
    req.send(body);
  });
}

function waitFor(func, options = { timeout: 600000, interval: 3000 }) {
  return new Promise((resolve, reject) => {
    let elapsed = 0;
    const id = setInterval(() => {
      if(func()){
        clearInterval(id);
        resolve();
      }
      elapsed += options.interval;
      if(elapsed >= options.timeout) {
        reject();
        clearInterval(id);
      }
    }, options.interval);
  })
}

function normalizePath(path) {
  return path.replace(/^\/*/,"/")
}///////////////////////////////////////////////////////////////////////////////

class MarkupImpl {

  constructor(data, file) {
    this.data = data;
    this.file = file;
  }

  get id() { return this.data.id }


  get(relativePath, signal) {
    const path = normalizePath(relativePath);
    return this.file.get(`/markup/${this.id}${path}`, signal)
  }

  post(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.file.post(`/markup/${this.id}${path}`, body)
  }

  put(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.file.put(`/markup/${this.id}${path}`, body)
  }

  delete(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.file.delete(`/markup/${this.id}${path}`, body)
  }

  // Update markup for file
  saveMarkup() {
    return json(this.post(`/`, this.data))
  }

  // Get markup by id
  getMarkup() {
    return json(this.get(`/`))
  }

  // Delete markup by id
  deleteMarkup() {
    return json(this.delete(`/`))
  }

}///////////////////////////////////////////////////////////////////////////////

class ModelImpl {
  constructor(data, file) {
    this.data = data;
    this.file = file;
  }

  get id() { return this.data.id }

  get(relativePath, signal) {
    const path = normalizePath(relativePath);
    return this.file.get(`/${path}`, signal)
  }

  post(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.file.post(`/${path}`, body)
  }

  put(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.file.put(`/${path}`, body)
  }

  delete(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.user.delete(`/${path}`, body)
  }

  //Download file resource
  downloadResource(dataId, onProgress, signal) {
    return this.file.downloadResource(dataId, onProgress, signal)
  }

  partialDownloadResource(dataId, signal, onProgress) {
    return this.file.partialDownloadResource(dataId, signal, onProgress)
  }

  getReferences() {
    return this.file.getReferences()
  }

  // Get all viewpoint for file
  getViewPoints() {
    if (! this.file.getViewPoints) {
      throw new Error('Assembly not support viewpoint')
    }
    return this.file.getViewPoints()
      .then(data => data.filter(viewpoint => viewpoint.custom_fields.modelId === this.id))
  }

  // Add viewpoint for file
  postViewpoint(data) {
    if (! this.file.postViewpoint) {
      throw new Error('Assembly not support viewpoint')
    }
    return this.file.postViewpoint({ ...data, custom_fields: { modelId: this.id } })
  }

  // Get viewpoint by guid
  getViewpoint(guid) {
    if (! this.file.getViewpoint) {
      throw new Error('Assembly not support viewpoint')
    }
    return this.file.getViewpoint(guid)
  }

  // Delete viewpoint by guid
  deleteViewpoint(guid) {
    if (! this.file.deleteViewpoint) {
      throw new Error('Assembly not support viewpoint')
    }
    return this.file.deleteViewpoint(guid)
  }

  // Get snapshot data for view point by guid
  getSnapshot(guid) {
    if (! this.file.getSnapshot) {
      throw new Error('Assembly not support viewpoint')
    }
    return this.file.getSnapshot(guid)
  }

  // Get snapshot data for view point by guid
  getSnapshotData(guid, bitmapGuid) {
    if (! this.file.getSnapshotData) {
      throw new Error('Assembly not support viewpoint')
    }
    return this.file.getSnapshot(guid, bitmapGuid)
  }
}///////////////////////////////////////////////////////////////////////////////
/* eslint no-unused-vars: off */
class FileImpl {

  constructor(fileInfo, user) {
    this.fileInfo = fileInfo;
    this.user = user;
  }
  get id() { return this.fileInfo.id }
  /**
  * File operation api
  * */

  get(relativePath, signal) {
    const path = normalizePath(relativePath);
    return this.user.get(`/files/${this.id}${path}`, signal)
  }

  post(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.user.post(`/files/${this.id}${path}`, body)
  }

  put(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.user.put(`/files/${this.id}${path}`, body)
  }

  delete(relativePath, body) {
    const path = normalizePath(relativePath);
    return this.user.delete(`/files/${this.id}${path}`, body)
  }

  //Get object properties for specific file
  getProperties() {
    return json(this.get(`/properties`))
  }

  //Get object properties for specific file
  getProperty(id) {
    return json(this.get(`/properties?handle=${id}`))
  }


  //Get geometry metadata for specific file
  getModels() {
    return json(this.get(`/geometry`))
      .then(models => models.map(data => new ModelImpl(data, this)))

  }

  //Add geometry metadata for specific file
  postMetadata(metadata) {
    return json(this.post(`/geometry`, metadata))
  }

  //Upload file for downloads
  postFileDownloads(file, onProgress) {
    //todo: Check description
    const data = new FormData();
    data.append('file', file);
    return json(this.post(`/downloads`, data))
  }

  //Download file
  downloadFile() {
    return arrayBuffer(this.get(`/downloads`))
  }

  //Download file resource
  downloadResource(dataId, onProgress, signal) {
    return this.get(`/downloads/${dataId}`, signal)
      .then(response => downloadProgress(response, onProgress))
      .then(response => response.arrayBuffer())
  }

  async partialDownloadResource(dataId, signal, onProgress)
  {
    const path = normalizePath(`/files/${this.id}/downloads/${dataId}`);
    
    const response = await fetch(`${this.user.url}${path}`, {
      headers: this.user.headers, signal: signal
    });
    const contentLength = response.headers.get('content-length');
    const total = parseInt(contentLength, 10);

    let loaded = 0;

    const reader = response.body.getReader();
    let condition = true;
    while (condition) 
    {
      const {done, value} = await reader.read();
      
      if (done) {
        break
      }

      loaded += value.byteLength;

      onProgress(loaded/total, value);
    }
  }

  //Show file info
  getFileInfo() {
    return json(this.get(`/`))
  }

  //Update file(name and preview)
  putFile(fileInfo) {
    return json(this.put(`/`, fileInfo))
  }

  //Remove file
  deleteFile() {
    return this.user.deleteFile(this.id)
  }

  //Get all markups for file
  getMarkupList() {
    return json(this.get(`/markup`))
      .then(list => list.result.map(data => new MarkupImpl(data, this)))
  }

  // Add markup to file
  postMarkup(markup) {
    return json(this.post(`/markup/`, markup))
  }

  // Delete markup by id
  deleteMarkup(markupId) {
    return json(this.delete(`/markup/${markupId}`))
  }

  // Get markup by id
  getMarkup(markupId) {
    return json(this.get(`/markup/${markupId}`))
  }

  // Create new Job
  createJob(outputFormat) {
    return this.user.postJob(this.id, outputFormat)
  }

  getReferences() {
    return json(this.get(`/references`))
  }

  putReferences(object) {
    return json(this.put(`/references`, object))
  }

  downloadReferenceFile(onProgress, signal)  {
    return arrayBuffer(this.user.downloadReferenceFile(this.id, onProgress, signal))
  }


  // Get all viewpoint for file
  getViewPoints() {
    return json(this.get(`/viewpoints`))
      .then(list => list.result)
  }

  // Add viewpoint for file
  postViewpoint(data) {
    return json(this.post(`/viewpoints`, data))
  }

  // Get viewpoint by guid
  getViewpoint(guid) {
    return json(this.get(`/viewpoints/${guid}`))
  }

  // Delete viewpoint by guid
  deleteViewpoint(guid) {
    return json(this.delete(`/viewpoints/${guid}`))
  }

  // Get snapshot data for view point by guid
  getSnapshot(guid) {
    return text(this.get(`/viewpoints/${guid}/snapshot`))
  }

  // Get snapshot data for view point by guid
  getSnapshotData(guid, bitmapGuid) {
    return text(this.get(`/viewpoints/${guid}/bitmaps/${bitmapGuid}`))
  }

}///////////////////////////////////////////////////////////////////////////////

class JobImpl {
  
  constructor(data, user) {
    this.data = data;
    this.user = user;
  }

  get id() { return this.data.id }

  get done() { return this.data.state === "done" }

  get state() { return this.data.state }

  get fileId() { return this.data.fileId }

  get assemblyId() { return this.data.assemblyId }

  get createdAt() { return this.data.createdAt }

  get startedAt() { return this.data.startedAt }

  get lastUpdate() { return this.data.lastUpdate }

  get outputFormat() { return this.data.outputFormat }

  // Status for specified job
  refresh() {
    return this.user.getJob(this.id)
      .then(data => this.data = data)
      .then(() => this)
  }

  // Update some parameters for specific job (available only for admins)
  editJob(data) {
    return this.user.editJob(this.id, data)
      .then(data => this.data = data)
      .then(() => this)
  }

  delete() {
    return this.user.deleteJob(this.id)
  }

  waitForDone() {
    return waitFor(() => this.refresh() && this.done)
  }

}///////////////////////////////////////////////////////////////////////////////

class ProjectImpl {
  constructor(data, user) {
    this._data = data;
    this._user = user;
  }

  delete() {
    const { id } = this._data;
    return this._user.delete(`/projects/${id}`)
  }

  save() {
    const { id } = this._data;
    return json(this._user.put(`/projects/${id}`, this._data))
  }
}///////////////////////////////////////////////////////////////////////////////

class AssemblyImpl {
  constructor(assemblyData, user) {
    this._data = assemblyData;
    this._user = user;
  }

  _get(relativePath, signal) {
    const path = normalizePath(relativePath || '');
    return this._user.get(`/assemblies/${this._data.id}${path}`, signal)
  }

  _post(relativePath, body) {
    const path = normalizePath(relativePath || '');
    return this._user.post(`/assemblies/${this._data.id}${path}`, body)
  }

  _put(relativePath, body) {
    const path = normalizePath(relativePath || '');
    return this._user.put(`/assemblies/${this._data.id}${path}`, body)
  }

  _delete(relativePath, body) {
    const path = normalizePath(relativePath || '');
    return this._user.delete(`/assemblies/${this._data.id}${path}`, body)
  }

  getProperties() {
    return json(this._get(`/properties`))
  }

  getProperty(id) {
    return json(this._get(`/properties?handle=${id}`))
  }

  getModels() {
    return json(this._get(`/geometry`))
      .then(models => models.map(data => new ModelImpl(data, this)))
  }

  downloadResource(dataId, onProgress, signal) {
    return this._get(`/downloads/${dataId}`, signal)
      .then(response => downloadProgress(response, onProgress))
      .then(response => response.arrayBuffer())
  }

  async partialDownloadResource(dataId, signal, onProgress)
  {
    const path = normalizePath(`/assemblies/${this._data.id}/downloads/${dataId}`);
    
    const response = await fetch(`${this._user.url}${path}`, {
      headers: this._user.headers, signal: signal
    });
    const contentLength = response.headers.get('content-length');
    const total = parseInt(contentLength, 10);

    let loaded = 0;

    const reader = response.body.getReader();
    let condition = true;
    while (condition) 
    {
      const {done, value} = await reader.read();
      
      if (done) {
        break
      }

      loaded += value.byteLength;

      onProgress(loaded/total, value);
    }
  }

  delete() {
    return this._delete()
  }

  save() {
    return this._put('', this._data)
  }
}///////////////////////////////////////////////////////////////////////////////

class UserImpl {

  constructor(data, url, opt) {
    this.data = data;
    this.url = url;
    this.headers = {
      'Authorization': data.tokenInfo.token,
    };
    this.opt = opt;
    if (! this.opt)
    {
      throw new Error('opt can not be undefined')
    }
  }

  get(relativePath, signal) {
    const path = normalizePath(relativePath);
    return $get(`${this.url}${path}`, this.headers, signal)
  }

  post(relativePath, body) {
    const path = normalizePath(relativePath);
    return $post(`${this.url}${path}`, this.headers, body)
  }

  put(relativePath, body) {
    const path = normalizePath(relativePath);
    return $put(`${this.url}${path}`, this.headers, body)
  }

  delete(relativePath, body) {
    const path = normalizePath(relativePath);
    return $delete(`${this.url}${path}`, this.headers, body)
  }

  // ----------- Users ---------------

  //get all users
  getUsers() {
    return json(this.get(`/users`))
  }

  // My account information
  getUserInfo() {
    return json(this.get(`/user`))
  }

  // Update information in my account
  putUserInfo(userInfo) {
    return json(this.put(`/user`, userInfo))
  }

  save() {
    return this.putUserInfo(this.data)
  }

  // ----------- Files ---------------

  //Show file info
  getFile(fileId) {
    return json(this.get(`/files/${fileId}`)).then(data => new FileImpl(data, this))
  }
  // Get all user files
  getFiles(start, limit, name, ext, ids, sortByDesc) {
    const query = [];
    if (start !== undefined)
    {
      query.push('start=' + start);
    }

    if (limit !== undefined)
    {
      query.push('limit=' + limit);
    }

    if (name)
    {
      query.push('name=' + name);
    }
    
    if (ext)
    {
      query.push('ext=' + ext.toLowerCase());
    }

    if (ids)
    {
      query.push('id=' + ids.join('|'));
    }

    if (sortByDesc)
    {
      query.push('sortBy=desc');
    }

    const queryStr = query.length !== 0 ? ('?' + query.join('&')) : '';
    return json(this.get(`/files${queryStr}`))
      .then(list => {
        return { ...list, result: list.result.map(fileInfo => new FileImpl(fileInfo, this)) }
      })
  }

  // Upload new file
  postFile(file, onProgress) {
    const data = new FormData();
    data.append('file', file);

    return $XMLHttp(`${this.url}/files/`, {
      method: "POST",
      headers: this.headers,
      body: data,
      uploadProgress: onProgress
    })
      .then(request => JSON.parse(request.responseText))
      .then(data => new FileImpl(data, this))
  }

  deleteFile(fileId, body) {
    return json(this.delete(`/files/${fileId}`, body))
  }
  // ----------- Jobs ---------------

  // Show all jobs
  getJobs(state = null, limit = null, start = null, sortByDesc = null) {

    const params = [
      state ? `${"state"}=${state}` : '',
      limit ? `${"limit"}=${limit}` : '',
      start ? `${"start"}=${start}` : '',
      sortByDesc ? `${"sortBy"}=desc` : '',
    ].filter(p => p);

    const query = params.length?`?${params.join("&")}`:""; 

    return json(this.get(`/jobs${query}`))
      .then(list => {
        return { ...list, result: list.result.map(data => new JobImpl(data, this)) }
      })
  }

  // Create new Job
  postJob(fileId, outputFormat) {
    const parameters = this.opt.useVSFX ? {"useVSFX": ""} : {};
    return json(this.post(`/jobs`, { "fileId": fileId, "outputFormat": outputFormat, "parameters": parameters }))
      .then(data => new JobImpl(data, this))
  }

  // Status for specified job
  getJob(jobId) {
    return json(this.get(`/jobs/${jobId}`))
      .then(data => new JobImpl(data, this))
  }

  // Delete job by Id
  deleteJob(jobId) {
    return json(this.delete(`/jobs/${jobId}`))
  }

  // Edit jobs, available only for admins
  editJob(data) {
    return json(this.put(`/jobs/${this.id}`, data))
      .then(data => new JobImpl(data, this))
  }

  downloadReferenceFile(fileId, onProgress, signal) {
    return this.get(`/files/${fileId}/downloads`, signal)
      .then(response => downloadProgress(response, onProgress))
      .then(response => response.arrayBuffer())
  }

  getProjects() {
    return json(this.get(`/projects`))
      .then(projectsData => {
        return projectsData.map(data => new ProjectImpl(data, this))
      })
  }

  createProject(name, description, startDate, endDate, avatarUrl) {
    return json(this.post(`/projects`, { 
      "name" : name,
      "description": description,
      "startDate": startDate.toISOString(),
      "endDate": endDate.toISOString(),
      "avatarUrl" : avatarUrl
    }))
    .then(data => new ProjectImpl(data, this))
  }
  
  getProjectById(id) {
    return json(this.get(`/projects/${id}`)).then(data => new ProjectImpl(data, this))
  }

  createAssembly(files, name)
  {
    return json(this.post(`/assemblies`, { 
      "name" : name,
      "files": files
    }))
    .then(data => new AssemblyImpl(data, this))
  }

  getAssemblyById(id) {
    return json(this.get(`/assemblies/${id}`)).then(data => new AssemblyImpl(data, this))
  }

  getAssemblies(start, limit, name, ids, sortByDesc) {
    const query = [];
    if (start !== undefined)
    {
      query.push('start=' + start);
    }

    if (limit !== undefined)
    {
      query.push('limit=' + limit);
    }

    if (name)
    {
      query.push('name=' + name);
    }

    if (ids)
    {
      query.push('id=' + ids.join('|'));
    }

    if (sortByDesc)
    {
      query.push('sortBy=desc');
    }

    const queryStr = query.length !== 0 ? ('?' + query.join('&')) : '';
    return json(this.get(`/assemblies${queryStr}`))
    .then(assemblies => {
      return {
        ...assemblies,
        result: assemblies.result.map(data => new AssemblyImpl(data, this))
      } 
    })
  }

  deleteAssembly(id) {
    return json(this.delete(`/assemblies/${id}`))
  }
}///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.


///////////////////////////////////////////////////////////////////////////////

/**
 * @class
 */
class Model {
  constructor(impl, file, assembly) {
    this._impl = impl;
    this._file = file;
    this._assembly = assembly;
  }

  /**
   * @type {File}
   */
  get file() {
    return this._file
  }

  /**
   * @type {Assembly}
   */
  get assembly() {
    return this._assembly
  }

  /**
   * @type {boolean}
   */
  get default() { return this._impl.data.default }

  /**
   * @type {string}
   */
  get database() { return this._impl.data.database }

  /**
   * @type {string}
   */
  get fileId() { return this._impl.data.fileId }

  /**
   * @type {string[]}
   */
  get geometry() { return this._impl.data.geometry }

  /**
   * @type {string}
   */
  get id() { return this._impl.data.id }

  /**
   * @type {string}
   */
  get name() { return this._impl.data.name }

  /**
   * @type {string}
   */
  get version() { return this._impl.data.version }


  /**
   * Get file model viewpoints
   * @function
   * @async
   * @returns {Viewpoint[]}
   */
  getViewpoints() {
    return this._impl.getViewPoints()
  }

  /**
   * Save viewpoint
   * @param {*} viewpointData 
   * @async
   * @returns {Viewpoint}
   */
  saveViewpoint(viewpointData) {
    return this._impl.postViewpoint(viewpointData)
  }

  /**
   * Delete viewpoint by id
   * @function
   * @param {string} viewpointId 
   * @async
   * @returns {Object}
   */
  deleteViewpoint(viewpointId) {
    return this._impl.deleteViewpoint(viewpointId)
  }

  /**
   * Get snapshot by id
   * @param {string} guid 
   * @async
   * @returns {Object}
   */
  getSnapshot(guid) {
    return this._impl.getSnapshot(guid)
  }

  /**
   * Get snapshot data by guid and bitmapGuid
   * @function
   * @async
   * @param {string} guid 
   * @param {string} bitmapGuid
   * @returns {ArrayBuffer}
   */
  getSnapshotData(guid, bitmapGuid) {
    return this._impl.getSnapshotData(guid, bitmapGuid)
  }

  /**
   * Download resource by id
   * @async
   * @param {string} dataId - dataId
   * @param {function} onProgress - onprogress callback
   * @param {AbortSignal} signal - signal for cancellation
   * @returns {ArrayBuffer} - binary data
   */ 
  downloadResource(dataId, onProgress, signal) {
    return this._impl.downloadResource(dataId, onProgress, signal)
  }

  /**
   * Download resource by id use fetch
   * @async
   * @param {string} dataId - dataId
   * @param {function} onProgress - onprogress callback
   * @param {AbortSignal} signal - signal for cancellation
   * @returns {void}
  */ 
   partialDownloadResource(dataId, signal, onProgress)
   {
    return this._impl.partialDownloadResource(dataId, signal, onProgress)
   }


  /**
  * File Reference
  * @typedef {Object} Reference
  * @property {string} id - id of file reference
  * @property {string} name - name of file reference, ex "font1.ttf"
  */


  /**
  * File references
  * @typedef {Object} References
  * @property {string} fileId - url to visualizeJS
  * @property {Reference[]} references - array of references for fileId
  * }
  */


  /**
   * Get snapshot data by guid and bitmapGuid
   * @function
   * @async
   * @returns {References}
   */
  getReferences() {
    return this._impl.getReferences()
  }
}///////////////////////////////////////////////////////////////////////////////

/**
 * @class
 */
 class Project {
  constructor(impl, app) {
    this._impl = impl;
    this.app = app;
  }

  /**
   * Project id
   * @type {(string)}
   */
  get id() {
    return this._impl._data.id;
  }
  /**
   * Project name
   * @type {(string)}
   */
  get name() {
    return this._impl._data.name;
  }

  set name(value) {
    this._impl._data.name = value;
  }
  /**
   * Project authorization for current user
   * @type {(Object)}
   */
  get authorization() {
    return this._impl._data.authorization;
  }
  /**
   * Project created date in ISO string
   * @type {(string)}
   */
  get createdAt() {
    return this._impl._data.createdAt;
  }
  /**
   * Project last update date in ISO string
   * @type {(string)}
   */
  get updatedAt() {
    return this._impl._data.updatedAt;
  }
  /**
   * Project start date in ISO string
   * @type {(string)}
   */
  get startDate() {
    return this._impl._data.startDate;
  }

  set startDate(value) {
    this._impl._data.startDate = value.toISOString();
  }
  /**
   * Project start date in ISO string
   * @type {(string)}
   */
  get endDate() {
    return this._impl._data.endDate;
  }

  set endDate(value) {
    this._impl._data.endDate = value.toISOString();
  }
  /**
   * Project detail description
   * @type {(string)}
   */
  get description() {
    return this._impl._data.description;
  }

  set description(value) {
    this._impl._data.description = value;
  }
  /**
   * Project avatar url (base64 image)
   * @type {(string)}
   */
  get avatarUrl() {
    return this._impl._data.avatarUrl;
  }

  set avatarUrl(value) {
    this._impl._data.avatarUrl = value;
  }
  /**
   * Project custom fields
   * @type {(Object)}
   */
  get customFields() {
    return this._impl._data.customFields;
  }

  set customFields(value) {
    this._impl._data.customFields = value;
  }
  /**
   * Project public flag
   * @type {(Object)}
   */
  get public() {
    return this._impl._data.public;
  }

  set public(value) {
    this._impl._data.public = value;
  }

  /**
   * Save project
   */
  save() {
    return this._impl.save()
  }

  /**
   * Delete project
   */
  delete() {
    return this._impl.delete()
  }
}///////////////////////////////////////////////////////////////////////////////

/**
 * @class
 */
class User {
  constructor(impl, plugin) {
    this._impl = impl;
    this._plugin = plugin;
  }


  /**
   * Raw object of user
   * @type {Object}
   */
  get data() {
    return this._impl.data;
  }

  /**
   * Get avatar image url
   * @returns {string}
   *//**
* Set avatar image url, and send save request
* @param {string} val
* @returns {this}
*/
  get avatarImage() { return this._impl.data.avatarImage }
  set avatarImage(v) { this._impl.data.avatarImage = v; this._impl.save(); }

  /**
   * Is user possible to create a project
   * @type {Boolean}
   */
  get canCreateProject() { return this._impl.data.canCreateProject }

  /**
   * Time when user was created
   * @type {string}
   */
  get createAt() { return this._impl.data.createAt }

  /**
   * Custom fields object, to save custom data
   * @type {*}
   */
  get customFields() { return this._impl.data.customFields }

  /**
   * User email
   * @type {string} 
   */
  get email() { return this._impl.data.email }

  /**
   * Get first name of user
   * @returns {string}
   *//**
* Set first name of user, and send save request
* @param {string} val
* @returns {this}
*/
  get firstName() { return this._impl.data.firstName }
  set firstName(v) { this._impl.data.firstName = v; this._impl.save(); }

  /**
   * Date of last modify user data
   * @type {string}
   */
  get lastModified() { return this._impl.data.lastModified }

  /**
 * Get last name of user
 * @returns {string}
 *//**
   * Set last name of user, and send save request
   * @param {string} val
   * @returns {this}
   */
  get lastName() { return this._impl.data.lastName }
  set lastName(v) { this._impl.data.lastName = v; this._impl.save(); }


  /**
   * Date of last sign in
   * @type {string}
   */
  get lastSignIn() { return this._impl.data.lastSignIn }

  /**
   * Projects limit to create
   * @type {Number}
   */
  get projectsLimit() { return this._impl.data.projectsLimit }


  /**
* Get user name of user
* @returns {string}
*//**
   * Set user name of user, and send save request
   * @param {string} val
   * @returns {this}
   */
  get userName() { return this._impl.data.userName }
  set userName(v) { this._impl.data.userName = v; this._impl.save(); }


/**
 * Returns result with array of available users
 * @returns {Object} 
 */
  getUsers() {
    return this._impl.getUsers()
  }
}///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

/**
 * @class
 */
class Job {
  constructor(impl, app) {
    this._impl = impl;
    this._app = app;
  }

  /**
   * Owner
   * @type {User}
   */
  get user() {
    return new User(this.impl.user, this._app)
  }

  /**
   * Job id
   * @type {string}
   */
  get id() { return this._impl.id }

  /**
   * Job done status
   * @type {boolean}
   */
  get done() { return this._impl.done }

  /**
   * Job state
   * @type {string}
   */
  get state() { return this._impl.state }

  /**
   * Job fileId
   * @type {string}
   */
  get fileId() { return this._impl.fileId }

  /**
   * Job assemblyId
   * @type {string}
   */
   get assemblyId() { return this._impl.assemblyId }
   
  /**
   * Job created at
   * @type {string}
   */
  get createdAt() { return this._impl.createdAt }

  /**
   * Job started at
   * @type {string}
   */
  get startedAt() { return this._impl.startedAt }

  /**
   * Job last update
   * @type {string}
   */
  get lastUpdate() { return this._impl.lastUpdate }

  /**
   * Update current job status
   * @async 
   */
  refresh() {
    return this._impl.refresh()
  }

  /**
   * Update some parameters for specific job (available only for admins)
   * @async 
   */
  editJob(data) {
    return this._impl.editJob(data)
  }

  /**
   * Delete job
   * @async 
   */
  delete() {
    return this._impl.delete()
  }
}///////////////////////////////////////////////////////////////////////////////

/**
 * @class
 */
class File {
  constructor(impl, app) {
    this._impl = impl;
    this.app = app;
  }

  /**
   * File owner - user
   * @type {User}
   */
  get user() { return new User(this._impl.user, this.app) }

  /**
   *  Created time
   * @type {(number|string)}
   */
  get created() { return this._impl.fileInfo.created }

  /**
   * Exports array
   * @type {Object[]} 
   */
  get exports() { return this._impl.fileInfo.exports }

  /**
   * File id
   * @type {string}
   */
  get id() { return this._impl.fileInfo.id }

  /**
   * Metadata
   * @type {boolean}
   */
  get metadata() { return this._impl.fileInfo.metadata }


  /**
   * User id
   * @type {string}
   */
  get owner() { return this._impl.fileInfo.owner }

  /**
   * Base64 image preview, get/set
   * @type {string}
   */
  get preview() { return this._impl.fileInfo.preview }
  set preview(base64) { this._impl.fileInfo.preview = base64; }

  /**
   * Have generated properties
   * @type {boolean}
   */
  get properties() { return this._impl.fileInfo.properties }

  /**
   * File size
   * @type {number}
   */
  get size() { return this._impl.fileInfo.size }

  /**
   * File type
   * @type {string}
   */
  get type() { return this._impl.fileInfo.type }

  /**
   * Server version
   * @type {string}
   */
  get version() { return this._impl.fileInfo.version }

  /**
   * Get and set file name
   * @type {string}
   */
  get name() { return this._impl.fileInfo.name }
  set name(newName) { this._impl.fileInfo.name = newName; }

  /**
   * Get geometry status (waiting inprogress done failed)
   * @type {string}
   */
  get geometryStatus() { return this._impl.fileInfo.geometryStatus }

  /**
   * Get properties status (waiting inprogress done failed)
   * @type {string}
   */
  get propertiesStatus() { return this._impl.fileInfo.propertiesStatus }

  /**
   * Get file models
   * @function
   * @async
   * @returns {Model[]}
   */
  getModels() {
    return this._impl.getModels().then(models => models.map(modelImpl => new Model(modelImpl, this)))
  }

  /**
   * Get property by id
   * @param {string} id 
   * @async 
   * @returns {Object} - property object
   */
  getProperty(id) {
    return this._impl.getProperty(id)
  }

  /**
   * Get all properties
   * @async 
   * @returns {Property[]} - properties array
   */
  getProperties() {
    return this._impl.getProperties()
  }

  /**
  * GetViewpoints
  * @async 
  * @returns {Viewpoint[]} - viewpoints array
  */
  getViewPoints() {
    return this._impl.getViewPoints()
  }

  /**
  * Delete file
  * @async 
  * @returns {Object} - 
  */
  delete() {
    return this._impl.deleteFile()
  }

  /**
   * Download resource by id
   * @async
   * @param {string} dataId - dataId
   * @param {string} onProgress - onprogress callback
   * @param {AbortSignal} signal - signal for cancellation
   * @returns {ArrayBuffer} - binary data
   */ 
  downloadResource(dataId, onProgress, signal) {
    return this._impl.downloadResource(dataId, onProgress, signal)
  }

  /**
   * Save file changes
   * @async 
   * @returns {Object}  
   */
  save() {
    return this._impl.putFile(this._impl.fileInfo)
  }


  /**
   * Update file data
   * @async 
   * @returns {File}  
   */
  checkout() {
    return this._impl.getFileInfo()
      .then(info => this._impl.fileInfo = info)
      .then(() => this)
  }

  /**
   * Update file data
   * @async 
   * @param {References}  
   * @returns {References}
   */
  createReferences(object) {
    return this.putReferences(object)
  }


  /**
   * Get file references
   * @async 
   * @returns {References}
   */
  getReferences() {
    return this._impl.getReferences()
  }

  /**
   * Change file references
   * @async 
   * @returns {References}
   */
  putReferences(object) {
    return this._impl.putReferences(object)
  }

  /**
   * Create job for extract geometry
   * @async 
   * @returns {Job}
   */
  extractGeometry() {
    return this._impl.createJob("geometry").then(jobImpl => new Job(jobImpl, this.app))
  }

  /**
   * Create job for extract properties
   * @async 
   * @returns {Job}
   */
  extractProperties() {
    return this._impl.createJob("properties").then(jobImpl => new Job(jobImpl, this.app))
  }

}///////////////////////////////////////////////////////////////////////////////
/* eslint no-unused-vars: off */

/**
 * @class
 */
class JobUpdater {
  constructor(userImpl, plugin) {
    this._userImpl = userImpl;
    this._plugin = plugin;
    this._intervalId = 0;

    /**
     * Interval for update jobs
     * @type {Number}
     */
    this.interval = 5000;

    /**
     * Array of jobs
     * @type {Job[]}
     */
    this.jobs = [];
  }

  /**
   * Start to update jobs periodicals
   * @function
   */
  start() {
    this._intervalId = setInterval(() => {
      this.update();
    }, this.interval);
  }

  /**
   * Update job function, it invokes automatic when run "Start"
   * @function
   * @async
   */
  async update() {

    function completed(one, two) {
      return one.filter(job1 => !two.find(job2 => job1.id === job2.id))
    }

    const jobs = [...(await this._userImpl.getJobs("running")).result, ...(await this._userImpl.getJobs("waiting")).result];
    const completedJobs = completed(this.jobs, jobs);
    this.jobs = jobs;

    const completedFiles = await completedJobs.reduce((acc, job) => {
      return acc.then(arr => {
        return this._userImpl.getFile(job.fileId).then(file => arr.push(file) && arr)
      })
    }, Promise.resolve([]));

    completedFiles.length && this._plugin.emit({ type: "jobs-complete", data: completedFiles.map(fileImpl => new File(fileImpl, this._plugin)) });
  }

 /**
   * Start to update jobs periodicals
   * @function
   */
  stop() {
    clearInterval(this._intervalId);
    this._intervalId = 0;
  }
}function loadScript(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = url;
    script.async = true;
    script.onload = resolve;
    script.onerror = reject;
    document.body.appendChild(script);
  })
}

/**
 * @class
 */
class EventEmitter$1 {

  /**
   * @constructor
   */
  constructor() {
    this.draggers = [];

    this.emitEvent = this.emitEvent.bind(this);
  }

  /**
   * Add dragger to listen couple of events
   * @function
   * @param {Object}
   * @param {Array<String>}
   */
  addDragger(dragger, events) {
    const subscriber = {
      dragger,
      events: events.map(key => ({
        key,
        fn: event => dragger[key] && dragger[key](event)
      }))
    };
    subscriber.events.forEach(ev => this.addEventListener(ev.key, ev.fn));
    this.draggers.push(subscriber);
  }

    /**
   * Remove dragger, detach to listen events
   * @function
   * @param {Object}
   */
  removeDragger(dragger) {
    const draggers = this.draggers.filter(d => d.dragger === dragger);
    draggers.forEach(dragger => {
      dragger.events.forEach(ev => this.removeEventListener(ev.key, ev.fn));
    });
    this.draggers = this.draggers.filter(d => d.dragger !== dragger);
  }

  /**
   * Subscribe on event
   * @function
   * @param {string} 
   * @param {function} 
   */
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === - 1) {
      listeners[type].push(listener);
    }
  }

  /**
   * Unsubscribe from event
   * @function
   * @param {string} 
   * @param {function} 
   */
  removeEventListener(type, listener) {

    if (this._listeners === undefined) return;

    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {

      const index = listenerArray.indexOf(listener);
      if (index !== - 1) {
        listenerArray.splice(index, 1);
      }
    }
  }

/**
 * The interface of the Event from EventEmitter.
 * @typedef {(Object | Event)} EventObject
 * @property {string} type - type of the event
 * @property {Object} data - data of the event
 */


  /**
   * Emit event
   * @function
   * @param {EventObject} 
   */
  emitEvent(event) {

    if (this._listeners === undefined) return;

    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      if (!event.target) {
        event.target = this;
      }


      // Make a copy, in case listeners are removed while iterating.
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      if (event.target === this) {
        event.target = null;
      }
    }
  }

  removeAllListeners() {
    this._listeners = [];
  }

  attach(element, eventType) {
    return element.addEventListener(eventType, this.emitEvent)
  }
  detach(element, eventType) {
    return element.removeEventListener(eventType, this.emitEvent)
  }
}

const memoize = (f) => {
  const cache = {};
  return (...args) => {
    const argStr = JSON.stringify(args);
    cache[argStr] = cache[argStr] || f(...args);
    return cache[argStr];
  };
};
const loadVisualizeJS = memoize((url, onprogress) => {
  return loadScript(url)
  .then(() => {
    return new Promise(resolve => {
      const instance = window["getVisualizeLibInst"]({ urlMemFile: url + ".wasm", TOTAL_MEMORY: 134217728, onprogress: onprogress});
      instance.postRun.push(() => resolve(instance));
    })
  })
});

const composingMatrixFromTransform = (translate, rotate, scale, modelCenter, matrix) => {

  const translateMatrix = matrix.setTranslation(
    [
      translate.x, 
      translate.y, 
      translate.z
    ]
  );

  const rotateMatrix = matrix.setToRotation(
    rotate.angle,
    [
      rotate.x,
      rotate.y, 
      rotate.z
    ],
    modelCenter
  );

  const scaleMatrix = matrix.setToScaling(scale, modelCenter);
  return translateMatrix.postMultBy(rotateMatrix).postMultBy(scaleMatrix);
};///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
class OdaGeAction {
  constructor(module) {
    this.m_module = module;
  }

  getViewer() {
    return this.m_module.getViewer();
  }

  getModel() {
    return this.getViewer().getMarkupModel();
  }
  
  copyPoint(point) {
    const p = new this.m_module.Point3d();
    p.set(point.x, point.y, point.z);
    return p;
  }

  createVector3d() {
    return new this.m_module.Vector3d();
  }

  createPoint3d() {
    return new this.m_module.Point3d();
  }

  createMatrix3d() {
    return new this.m_module.Matrix3d();
  }

  createPlane() {
    return new this.m_module.OdTvPlane();
  }

  toVector(geVector) {
    return this.m_module.Vector3d.createFromArray(geVector);
  }

  toGeVector(v) {
    return [v.x, v.y, v.z];
  }

  toGePoint(point) {
    return [point.x, point.y, point.z];
  }

  toPoint(gePoint) {
    return this.m_module.Point3d.createFromArray(gePoint);
  }

  screenToWorld(x, y) {
    return this.toPoint(this.m_module.getViewer().screenToWorld(x, y));
  }

  toDoubleArray(points) {
    const p = [];
    for (let i = 0; i < points.length; i++) {
      p.push(points[i].x);
      p.push(points[i].y);
      p.push(points[i].z);
    }
    return p;
  }

  correctCameraTarget() {
    const params = this.getViewParams();
    let ext = this.m_module.getViewer().getActiveExtents();
    const { min, max } = ext;
    const target = this.toGePoint(params.target);
    
    const contains = (target.x >= min.x
    && target.y >= min.y
    && target.z >= min.z
    && target.x <= max.x
    && target.y <= max.y
    && target.z <= max.z );
    if(!contains) {
      params.target = ext.center();
      this.setViewParams(params);
    }
  }

  setViewParams(params) {
    const extView = this.m_module.getViewer().getActiveTvExtendedView();
    extView.setView(
      params.position,
      params.target,
      params.upVector,
      params.viewFieldWidth,
      params.viewFieldHeight,
      params.perspective
    );
    extView.delete && extView.delete();
  }

  getViewParams() {
    const view = this.m_module.getViewer().activeView;

    const obj = {
      position: view.viewPosition,
      target: view.viewTarget,
      upVector: view.upVector,
      viewFieldWidth: view.viewFieldWidth,
      viewFieldHeight: view.viewFieldHeight,
      perspective: view.perspective
    };
    view.delete && view.delete();

    return obj;
  }
}///////////////////////////////////////////////////////////////////////////////

const CLICK_DELTA = 5;
const OVERLAY_VIEW_NAME = "$OVERLAY_VIEW_NAME";

function syncOverlayView(viewer) {
  let overlayView = viewer.getViewByName(OVERLAY_VIEW_NAME);
  const activeView = viewer.activeView;

  if (!overlayView) {
    const overlayModel = viewer.getMarkupModel();
    const pDevice = viewer.getActiveDevice();

    overlayView = pDevice.createView(OVERLAY_VIEW_NAME, false);

    overlayView.addModel(overlayModel);

    activeView.addSibling(overlayView);
    pDevice.addView(overlayView);
  }

  overlayView.viewPosition = activeView.viewPosition;
  overlayView.viewTarget = activeView.viewTarget;
  overlayView.upVector = activeView.upVector;
  overlayView.viewFieldWidth = activeView.viewFieldWidth;
  overlayView.viewFieldHeight = activeView.viewFieldHeight;

  const viewPort = overlayView.getViewport();
  overlayView.setViewport(viewPort.lowerLeft, viewPort.upperRight);

  overlayView.vportRect = activeView.vportRect;

  return overlayView;
}



class OdBaseDragger extends OdaGeAction {
  constructor(subject) {
    super(subject.visualizeJs);
    this.subject = subject;
    this.needInputText = false;
    this.touchStartPoints = { x: 0, y: 0 };
    this.touchEndPoints = { x: 0, y: 0 };
    this.mouseDownPosition = { x: 0, y: 0 };
    this.autoSelect = false;
    this.onmessage = new Function();

    this.onmessage = event => this.subject.emitEvent(event);

    this.subject.eventEmitter.addDragger(this, [
      "mousemove",
      "mouseleave",
      "mousedown",
      "mouseup",
      "mouseleave",
      "click",
      "touchstart",
      "touchend",
      "touchcancel",
      "touchmove",
      "dblclick",
    ]);
  }

  dispose() {
    this.subject.eventEmitter.removeDragger(this);
  }

  relativeCoords(event) {
    const bounds = event.target.getBoundingClientRect();
    event.touches && event.touches[0] && (event = event.touches[0]);
    const x = event.clientX - bounds.left;
    const y = event.clientY - bounds.top;
    const rect = this.m_module.canvas.getBoundingClientRect();
    const left = rect.left;
    const top = rect.top;
    const right = rect.right;
    const bottom = rect.bottom;
    if (x <= left || x >= right || y <= top || y >= bottom) {
      return { x: x * window.devicePixelRatio, y: y * window.devicePixelRatio, isValid: false };
    }
    return { x: x * window.devicePixelRatio, y: y * window.devicePixelRatio, isValid: true };
  }

  touchstart(ev) {
    if (ev.touches.length > 1) {
      ev.preventDefault();
    }
    const relCoord = this.relativeCoords(ev);
    this.isDragging = true;
    this.touchStartPoints.x = relCoord.x;
    this.touchStartPoints.y = relCoord.y;
    this.touchEndPoints.x = relCoord.x;
    this.touchEndPoints.y = relCoord.y;
    this.start(relCoord.x, relCoord.y);
    this.onmessage({ type: 'update' });
  }

  touchend(ev) {
    this.end(this.touchEndPoints.x, this.touchEndPoints.y);
    this.isDragging = false;
    this.onmessage({ type: 'update' });
  }

  touchmove(ev) {
    const relCoord = this.relativeCoords(ev);
    ev.touches[0];
    this.touchEndPoints.x = relCoord.x;
    this.touchEndPoints.y = relCoord.y;
    this.drag(
      relCoord.x,
      relCoord.y,
      this.touchStartPoints.x - relCoord.x,
      this.touchStartPoints.y - relCoord.y);
    if (this.isDragging) {
      this.onmessage({ type: 'update' });
    }
  }

  mousedown(ev) {
    const relCoord = this.relativeCoords(ev);
    this.isDragging = true;
    this.mouseDownPosition = { x: relCoord.x, y: relCoord.y };
    this.start(this.mouseDownPosition.x, this.mouseDownPosition.y,
      ev.clientX, ev.clientY);
    this.onmessage({ type: 'update' });
  }

  mouseup(ev) {
    const relCoord = this.relativeCoords(ev);
    this.end(relCoord.x, relCoord.y);
    this.isDragging = false;
    this.onmessage({ type: 'update' });
  }

  mouseleave(ev) {
    this.mouseup(ev);
  }

  mousemove(ev) {
    const relCoord = this.relativeCoords(ev);
    if (!relCoord.isValid) {
      this.mouseup(ev);
      return
    }
    this.drag(relCoord.x, relCoord.y, ev.movementX, ev.movementY);
    if (this.isDragging) {
      this.onmessage({ type: 'update' });
    }
  }

  click(ev) {
    const relCoord = this.relativeCoords(ev);
    const x = relCoord.x;
    const y = relCoord.y;

    const isNotDragging = Math.abs(x - this.mouseDownPosition.x) < CLICK_DELTA &&
      Math.abs(y - this.mouseDownPosition.y) < CLICK_DELTA;

    const viewer = this.getViewer();

    if (viewer && viewer.getEnableAutoSelect() && isNotDragging) {
      viewer.unselect();
      viewer.select(x, y, x, y);
      const pSelected = viewer.getSelected();
      if (!pSelected.isNull() && pSelected.numItems() !== 0) {
        this.onmessage({ type: 'select', data: pSelected });
      }
      this.onmessage({ type: 'update' });
    }
  }

  dblclick(ev) {
    const viewer = this.getViewer();
    const relCoord = this.relativeCoords(ev);
    const x = relCoord.x;
    const y = relCoord.y;

    const device = viewer.getActiveDevice();
    const clickView = device.viewAt([x, y]);
    if (clickView && !clickView.active) {
      viewer.activeView = clickView;
      clickView.delete();
      this.onmessage({ type: 'update' });
    } else {
      if (viewer && viewer.getEnableAutoSelect()) {
        const pSelected = viewer.getSelected();

        if (!pSelected.isNull() && pSelected.numItems() !== 0) {
          const itr = pSelected.getIterator();
          const entity = itr.getEntity();
          viewer.zoomToEntity(entity);

          this.onmessage({ type: 'zoomToEntity', data: entity });
          this.onmessage({ type: 'update' });

          this.deleteAll([itr, entity]);
        }

        pSelected.delete();
      }
    }

    device.delete();
  }

  start(x, y) {

  }

  drag(x, y) {

  }

  end(x, y) {

  }

  beginInteractivity() {
    const view = this.getViewer().activeView;
    if (view['beginInteractivity']) {
      view.beginInteractivity(15);
      this.onmessage({ type: 'update' });
    }
    view.delete();
  }

  endInteractivity() {
    const view = this.getViewer().activeView;
    if (view['endInteractivity']) {
      view.endInteractivity();

      const device = this.getViewer().getActiveDevice();
      const canvas = this.m_module.canvas;
      device.invalidate([0, 0, canvas.width, canvas.height]);
      device.delete();
      this.onmessage({ type: 'update' });
    }
    view.delete();
  }

  getActiveMarkupEntity(type) {
    syncOverlayView(this.getViewer());
    const model = this.getViewer().getMarkupModel();
    const entityName = '$MarkupTempEntity_' + type;

    let entityId = model.appendEntity(entityName);
    
    const entity = entityId.openObject();
    entity.setColor(255, 0, 0);
    entity.setLineWeight(2);

    entity.delete();
    model.delete();

    return entityId;
  }

  deleteAll(objects) {
    for (let obj of objects) {
      obj && obj.delete && obj.delete();
    }
  }
}///////////////////////////////////////////////////////////////////////////////

class OdPanDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;

    this.m_module.getViewer().setEnableAutoSelect(true);
  }

  start(x, y) {
    this.press = true;
    this.m_start = this.screenToWorld(x, y);
    this.beginInteractivity();
  }

  drag(x, y, dltX, dltY) {
    if (this.press) {
      const { Vector3d } = this.m_module;
      const params = this.getViewParams();
      const pt = this.screenToWorld(x, y);

      const ptSub = this.m_start.sub(pt);
      const delta = ptSub.asVector();

      const target = Vector3d.createFromArray(params.target);
      const targetWithDelta = target.add(delta);
      params.target = targetWithDelta.toArray();

      const position = Vector3d.createFromArray(params.position);
      const positionWithDelta  = position.add(delta);
      params.position = positionWithDelta.toArray();
      
      this.setViewParams(params);

      pt.delete();
      ptSub.delete();
      delta.delete();
      target.delete();

      targetWithDelta.delete();
      position.delete();
      positionWithDelta.delete();
    }
  }

  end(x, y) {
    this.press = false;
    this.endInteractivity();
    this.m_start && this.m_start.delete();
    this.m_start = null;
  }

}///////////////////////////////////////////////////////////////////////////////

class OdOrbitDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;

    this.getViewer().setEnableAutoSelect(true);
  }

  start(x, y) {
    this.press = true;

    this.m_viewCenter = this.getCenter();
    this.m_startPoint = {x: x, y: y};

    const view = this.getViewer().activeView;

    this.startCameraParams = {
      position        : view.viewPosition,
      target          : view.viewTarget,
      upVector        : view.upVector,
      viewFieldWidth  : view.viewFieldWidth,
      viewFieldHeight : view.viewFieldHeight,
      perspective     : view.perspective
    };

    view.delete();
    this.beginInteractivity();
  }

  setDefaultViewParams() {
    const extView = this.getViewer().getActiveTvExtendedView();
    extView.setView(
      this.startCameraParams.position,
      this.startCameraParams.target,
      this.startCameraParams.upVector,
      this.startCameraParams.viewFieldWidth,
      this.startCameraParams.viewFieldHeight,
      this.startCameraParams.perspective
    );
    extView.delete();
  }

  getSideVector(viewParams) {
    const pUpV = this.toVector(viewParams.upVector);
    const pTarget = this.toPoint(viewParams.target);
    const pPosition = this.toPoint(viewParams.position);

    const direct = pTarget.sub(pPosition);
    const vDirect = direct.asVector();

    const vCross = pUpV.crossProduct(vDirect);
    const sideVector = vCross.normalize();

    this.deleteAll([direct, pUpV, pTarget, pPosition, vDirect, vCross]);

    return sideVector;
  }

  calculateXOrbit(viewParams, delta, sideVector) {
    {
      const pPoint = this.toPoint(viewParams.position);
      const pCenter = this.toPoint(this.m_viewCenter);

      const rotatePoint = pPoint.rotateByBasePoint(delta, sideVector, pCenter);
      viewParams.position = rotatePoint.toArray();

      this.deleteAll([pPoint, pCenter, rotatePoint]);
    }

    {
      const pTarget = this.toPoint(viewParams.target);
      const pCenter = this.toPoint(this.m_viewCenter);

      const rotatePoint = pTarget.rotateByBasePoint(delta, sideVector, pCenter);
      viewParams.target = rotatePoint.toArray();

      this.deleteAll([pTarget, pCenter, rotatePoint]);
    }

    {
      const pPoint = this.toPoint(viewParams.position);
      const pTarget = this.toPoint(viewParams.target);
      const pCenter = this.toPoint(this.m_viewCenter);

      const pUp = pTarget.sub(pPoint);
      const vUp = pUp.asVector();

      const crossProduct = vUp.crossProduct(sideVector);
      const crossProductNormal = crossProduct.normalize();
      
      viewParams.upVector = crossProductNormal.toArray();

      this.deleteAll([pPoint, pTarget, pCenter, pUp, vUp, crossProduct, crossProductNormal]);
    }
  }

  calculateYOrbit(viewParams, delta, sideVector)
  {
    {
      const pPoint = this.toPoint(viewParams.position);
      const pCenter = this.toPoint(this.m_viewCenter);

      const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);

      const rotatePoint = pPoint.rotateByBasePoint(delta, zAxis, pCenter);
      viewParams.position = rotatePoint.toArray();

      this.deleteAll([zAxis, pPoint, pCenter, rotatePoint]);
    }

    {
      const pTarget = this.toPoint(viewParams.target);
      const pCenter = this.toPoint(this.m_viewCenter);

      const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);

      const rotatePoint = pTarget.rotateByBasePoint(delta, zAxis, pCenter);
      viewParams.target = rotatePoint.toArray();

      this.deleteAll([zAxis, pTarget, pCenter, rotatePoint]);
    }

    {
      const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);
      const pTarget = this.toPoint(viewParams.target);
      const pPoint = this.toPoint(viewParams.position);

      const side = sideVector.rotateBy(delta, zAxis);

      const pUp = pTarget.sub(pPoint);
      const vUp = pUp.asVector();

      const cross = vUp.crossProduct(side);
      const crossNormal = cross.normalize();

      viewParams.upVector = crossNormal.toArray();

      this.deleteAll([zAxis, pTarget, pPoint, side, pUp, vUp, cross, crossNormal]);
    }
    
  }

  drag(x, y, dltX, dltY) {
    if (this.press) {
      const view = this.getViewer().activeView;

      const corners = view.vportRect;

      const size = Math.max(
        Math.abs(corners[2] - corners[0]),
        Math.abs(corners[3] - corners[1]));

      const distX = (this.m_startPoint.x - x) * Math.PI / size;
      const distY = (this.m_startPoint.y - y) * Math.PI / size;

      this.m_startPoint.x = x;
      this.m_startPoint.y = y;

      const xOrbit = distY;
      const yOrbit = distX;

      const viewParams = {
        position: view.viewPosition,
        target: view.viewTarget,
        upVector: view.upVector,
        viewFieldWidth: view.viewFieldWidth,
        viewFieldHeight: view.viewFieldHeight,
        perspective: view.perspective
      };

      view.delete();

      const sideVector = this.getSideVector(viewParams);

      if (xOrbit != 0.0) {
        this.calculateXOrbit(viewParams, -xOrbit, sideVector);
      }

      if (yOrbit != 0.0) {
        this.calculateYOrbit(viewParams, yOrbit, sideVector);
      }

      sideVector.delete();

      const extView = this.getViewer()
        .getActiveTvExtendedView();

      extView.setView(
        viewParams.position,
        viewParams.target,
        viewParams.upVector,
        viewParams.viewFieldWidth,
        viewParams.viewFieldHeight,
        viewParams.perspective
      );
      extView.delete();
    }
  }

  end(x, y) {
    this.press = false;
    this.endInteractivity();
  }
  
  mouseleave(ev) {
    this.end();
  }

  getCenter() {
    const viewer = this.getViewer();

    let ext = viewer.getActiveExtents();

    const pSet = viewer.getSelected();
    if (!pSet.isNull() && pSet.numItems() !== 0) {
      const itr = pSet.getIterator();
      const entId = itr.getEntity();

      if (entId.getType() === 1) {
        const obj = entId.openObject();

        ext.delete();
        ext = obj.getExtents();

        obj.delete();
      } else if (entId.getType() === 2) {
        const obj = entId.openObjectAsInsert();
        const extTuple = obj.getExtents();

        ext.delete();
        ext = extTuple.ext;

        extTuple.delete();
        obj.delete();
      }

      itr.delete();
    }
    pSet.delete();

    const center = ext.center();

    ext.delete();
    return center;
  }
}///////////////////////////////////////////////////////////////////////////////

class OdZoomDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;

    this.getViewer().setEnableAutoSelect(true);
  }

  start(x, y) {
    this.press = true;
    this.pressX = x;
    this.pressY = y;
  }

  drag(x, y, dltX, dltY) {
    if (this.press) {

      const ZOOM_SPEED = 0.025;
  
      const viewer = this.m_module.getViewer();

      viewer.zoomAt(dltY > 0 ? 1 + ZOOM_SPEED : 1 - ZOOM_SPEED, this.pressX, this.pressY);

      if (this.subject.activeDragger() && this.subject.activeDragger().updatePreview)
      {
        this.subject.activeDragger().updatePreview();
      }
    }
  }

  end(x, y) {
    this.press = false;
  }

  mouseleave(ev) {
    this.end();
  }
}///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
class OdSelectionFrame {
  constructor() {
    this.m_start = [0, 0, 0]; // 0
    this.m_end = [0, 0, 0]; // 2

    this.m_model = null;
  }

  createPoint3d() {
    return new this.m_module.Point3d();
  }

  init(instance, model) {
    this.m_module = instance;
    this.m_model = model;
  }

  getViewer() {
    return this.m_module.getViewer();
  }

  setValue(value) {
    this.m_end = value;
    this.draw();
  }

  setStartPoint(point) {
    this.m_start = point;
    this.m_end = point;
    this.draw();
  }

  toDoubleArray(points) {
    const p = [];
    for (let i = 0; i < points.length; i++) {
      p.push(points[i].x);
      p.push(points[i].y);
      p.push(points[i].z);
    }
    return p;
  }

  draw() {
    const view = this.getViewer().activeView;
    const viewM = view.viewingMatrix;

    const points = [];
    points.push(this.m_start);
    points.push(this.createPoint3d());
    points.push(this.m_end);
    points.push(this.createPoint3d());

    let p0 = this.createPoint3d();
    p0.set(this.m_start.x, this.m_start.y, this.m_start.z);

    let p2 = this.createPoint3d();
    p2.set(this.m_end.x, this.m_end.y, this.m_end.z);

    p0.transformBy(viewM);
    p2.transformBy(viewM);

    points[1].x = p0.x;
    points[3].x = p2.x;
    points[1].y = p2.y;
    points[3].y = p0.y;
    points[1].z = points[3].z = p2.z;

    const eyeM = view.eyeToWorldMatrix;
    points[1].transformBy(eyeM);
    points[3].transformBy(eyeM);

    if (!this.m_entity) {
      this.m_entity = this.m_model.appendEntity("");
      const entityPtr = this.m_entity.openObject();

      entityPtr.setColor(112, 112, 112);
      entityPtr.setLineWeight(2);

      this.m_frame = entityPtr.appendPolygon(this.toDoubleArray(points));
      entityPtr.delete();
    } else {
      this.m_frame.openAsPolygon().setPoints(this.toDoubleArray(points));
    }
  }

  clear() {
    if (this.m_entity) {
      this.m_model.removeEntity(this.m_entity);
      this.m_entity = null;
    }
  }
}///////////////////////////////////////////////////////////////////////////////

class OdZoomWindowDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.needInputText = false;
    
    this.m_frame = new OdSelectionFrame();
    this.getViewer().setEnableAutoSelect(true);
    this.m_frame.init(this.m_module, this.getModel());
  }

  start(x, y) {
    this.press = true;
    this.m_minX = x;
    this.m_minY = y;

    const startPoint = this.screenToWorld(x, y);
    this.m_frame.setStartPoint(startPoint);
  }

  drag(x, y, dltX, dltY) {
    if (this.press) {
      this.m_maxX = x;
      this.m_maxY = y;

      const point = this.screenToWorld(x, y);
      this.m_frame.setValue(point);
    }
  }

  end(x, y) {
    this.press = false;
    this.m_maxX = x;
    this.m_maxY = y;

    if (this.m_minX !== this.m_maxX && this.m_minY !== this.m_maxY) {
      this.m_frame.clear();
      this.getViewer().zoomWindow(this.m_minX, this.m_minY, this.m_maxX, this.m_maxY);
    }
  }

}///////////////////////////////////////////////////////////////////////////////

class OrbitAroundBuildingDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.maxPolarAngle = Math.PI / 2;
    this.minPolarAngle = 0; // radians

    this.getViewer().setEnableAutoSelect(true);
  }

  start(x, y) {
  
    this.press = true;

    this.m_viewCenter = this.getCenter();
    this.m_startPoint = { x: x, y: y };

    const view = this.getViewer().activeView;

    this.startCameraParams = this.getViewParams();

    const corners = view.vportRect;

    this.m_delta = Math.max(
      corners[1] - corners[0],
      corners[2] - corners[3]);

    this.beginInteractivity();
  }

  setDefaultViewParams() {
    this.setViewParams(this.startCameraParams);
  }

  drag(x, y, dltX, dltY) {
    if (this.press) {

      let dX = x - this.m_startPoint.x;
      let dY = y - this.m_startPoint.y;

      dX *= Math.PI / this.m_delta;
      dY *= Math.PI / this.m_delta;
      
      this.setDefaultViewParams();

      const { Vector3d, Matrix3d } = this.m_module;
      
      const target = Vector3d.createFromArray(this.startCameraParams.target);
      const offset = Vector3d.createFromArray(this.startCameraParams.position).sub(target);
      const dir = offset.normalize();

      const zMatrix = new Matrix3d(); zMatrix.setToIdentity();
      const xMatrix = new Matrix3d(); xMatrix.setToIdentity();
      
      // ---- restore start rotation ---- 
      
      const yAxis = Vector3d.createFromArray([dir.x,dir.y,dir.z]);
      const zAxis = Vector3d.createFromArray( this.startCameraParams.upVector);
      const xAxis = yAxis.crossProduct(zAxis);
      
      // ----------- zAxis rotation restore -----------
      let xyDir = Vector3d.createFromArray([yAxis.x, yAxis.y,0]);

      if(xyDir.length() <= 0.00001) {
        xyDir.set(-xAxis.y, xAxis.x, 0);
      } else {
        xyDir = xyDir.normalize();
      }
      const xyAngle = Math.sign(xyDir.dotProduct(Vector3d.createFromArray([-1,0,0])))* xyDir.angleTo(Vector3d.createFromArray([0,1,0])); 
      dX -= xyAngle;
      // ----------- zAxis rotation restore -----------


      // ----------- xAxis rotation restore -----------
      let yzDir = Vector3d.createFromArray([dir.x, dir.y,0]);
      let yzAngle = 0;
      if(yzDir.length() <= 0.00001) {
        yzAngle = -dir.z * Math.PI / 2;
      }  else {
        yzDir = yzDir.normalize();
        yzAngle =  -yzDir.angleTo(dir); 
      }
      dY -= yzAngle;
      // ----------- xAxis rotation restore -----------

      // ---- restore start rotation ----

      zMatrix.setToRotation(-dX, [0,0,1], [0,0,0]);

      const xAngle = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, dY));
      xMatrix.setToRotation(xAngle, [1,0,0], [0,0,0]);

      const endMatrix = zMatrix.postMultBy(xMatrix);

      let pos = Vector3d.createFromArray([0,1,0]).transformBy(endMatrix);
      const up = Vector3d.createFromArray([0,0,1]).transformBy(endMatrix);
      
      pos.setLength(offset.length());
      pos = target.add(pos);
      
      const current = this.getViewParams();

      current.position = pos.toArray();
      current.upVector = up.toArray();

      this.setViewParams(current);
      
    }
  }

  end(x, y) {
    this.press = false;
    this.endInteractivity();
  }

  mouseleave(ev) {
    this.end();
  }

  getCenter() {
    const viewer = this.getViewer();

    let ext = viewer.getActiveExtents();

    const pSet = viewer.getSelected();
    if (!pSet.isNull() && pSet.numItems() !== 0) {
      const itr = pSet.getIterator();
      const entId = itr.getEntity();

      if (entId.getType() === 1) {
        const obj = entId.openObject();

        ext.delete();
        ext = obj.getExtents();

        obj.delete();
      } else if (entId.getType() === 2) {
        const obj = entId.openObjectAsInsert();
        const extTuple = obj.getExtents();

        ext.delete();
        ext = extTuple.ext;

        extTuple.delete();
        obj.delete();
      }

      itr.delete();
    }
    pSet.delete();

    const center = ext.center();

    ext.delete();
    return center;
  }
}///////////////////////////////////////////////////////////////////////////////

class OdZoomWheelDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.subject.eventEmitter.removeDragger(this);
    this.subject.eventEmitter.addDragger(this, ["wheel"]);
  }


  wheel(event) {
    event = event || window.event;

    const ZOOM_SPEED = 0.075;

    const sign = Math.sign(event.deltaY);

    const viewer = this.m_module.getViewer();
    if (viewer) {
      const k = ZOOM_SPEED * sign;
      const { Vector3d } = this.m_module;
      const params = this.getViewParams();

      const center = Vector3d.createFromArray([
        this.m_module.canvas.clientWidth * 0.5,
        this.m_module.canvas.clientHeight * 0.5,
        0
      ]);

      const mousePos = Vector3d.createFromArray([
        event.offsetX,
        event.offsetY,
        0
      ]);
      const mouseDelta = mousePos.sub(center);

      params.viewFieldWidth = params.viewFieldWidth * (1 + k);
      params.viewFieldHeight = params.viewFieldHeight * (1 + k);

      this.setViewParams(params);
      k < 0 && viewer.pan(mouseDelta.x * k, mouseDelta.y * k);

      if (this.subject.activeDragger() && this.subject.activeDragger().updatePreview)
      {
        this.subject.activeDragger().updatePreview();
      }

      center.delete();
      mousePos.delete();
      mouseDelta.delete();
    }
  }

}///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////

function createHtmlElementIfNeed(element, targetElement) {
  if (!element) {
    element = document.createElement("div");
    targetElement.appendChild(element);
  }
  return element;
}

function destroyHtmlElement(element, targetElement) {
  if (element) {
    targetElement.removeChild(element);
  }
  return null;
}

function worldToScreen(gePoint, moduleInstance, viewer) {
  const worldPoint = moduleInstance.Point3d.createFromArray(gePoint);
  const avp = viewer.activeView;
  const mtx = avp.worldToDeviceMatrix;

  const devicePoint = worldPoint.transformBy(mtx);

  const res = { x: devicePoint.x / window.devicePixelRatio, y: devicePoint.y / window.devicePixelRatio};

  mtx.delete();
  worldPoint.delete();
  devicePoint.delete();
  avp.delete();
  return res;
}

function getDistance(gePoint1, gePoint2, moduleInstance) {
  const tvPoint1 = moduleInstance.Point3d.createFromArray(gePoint1);
  const tvPoint2 = moduleInstance.Point3d.createFromArray(gePoint2);

  const distance = tvPoint1.distanceTo(tvPoint2).toFixed(2);

  tvPoint1.delete();
  tvPoint2.delete();

  return distance;
}

function normalizeFloat(value) {
   return value < 0 ? Math.ceil(value) : Math.floor(value);
}

const lineSegmentsIntersect = (p1, p2, p3, p4) => {
  const a_dx = p2.x - p1.x;
  const a_dy = p2.y - p1.y;
  const b_dx = p4.x - p3.x;
  const b_dy = p4.y - p3.y;
  const s = (-a_dy * (p1.x - p3.x) + a_dx * (p1.y - p3.y)) / (-b_dx * a_dy + a_dx * b_dy);
  const t = (+b_dx * (p1.y - p3.y) - b_dy * (p1.x - p3.x)) / (-b_dx * a_dy + a_dx * b_dy);
  return (s >= 0 && s <= 1 && t >= 0 && t <= 1) ?
   { 
     x: normalizeFloat(p1.x + t * a_dx),
     y: normalizeFloat(p1.y + t * a_dy)
   } : false;
};

function checkSegmentsIntersect(p1, p2, p3, p4, res) {
  const r = lineSegmentsIntersect(p1, p2, p3, p4);
  if (r) {
    res.push(r);
  }
}

function isInsideRect(p, width, height) {
  return p.x <= width && p.x >= 0 && p.y <= height && p.y >= 0;
}

function getDataForDrawLineWithFixed(p1, p2, width, height) {
  const pLU = {x: 0, y: 0};
  const pRU = {x: width, y: 0};

  const pLB = {x: 0, y: height};
  const pRB = {x: width, y: height};

  const intersects = [];

  checkSegmentsIntersect(p1, p2, pLU, pRU, intersects);
  checkSegmentsIntersect(p1, p2, pLU, pLB, intersects);
  checkSegmentsIntersect(p1, p2, pLB, pRB, intersects);
  checkSegmentsIntersect(p1, p2, pRB, pRU, intersects);

  let fixedP1 = null;
  let fixedP2 = null;

  if (intersects.length === 0) {
    fixedP1 = p1;
    fixedP2 = p2;
  } else if (intersects.length === 1) {
    if (isInsideRect(p1, width, height)) {
      fixedP1 = p1;
      fixedP2 = intersects[0];
    } else {
      fixedP1 = intersects[0];
      fixedP2 = p2;
    }
  } else {
    fixedP1 = intersects[0];
    fixedP2 = intersects[1];
  }

  const dx = fixedP2.x - fixedP1.x;
  const dy = fixedP2.y - fixedP1.y;
  let angle = (180 * Math.atan(dy / dx)) / Math.PI;
  if (dx < 0) {
    angle -= 180;
  }
  const size = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
  return { angle: angle, width: size, p1: fixedP1, p2: fixedP2 };
}

function onSetCallback(element, cb) {
  if (element) {
    element.onclick = cb ? () => cb(this) : () => { };
  }
}

function onSetSelectivity(element, enable) {
  element.style.pointerEvents = enable ? "auto" : "none";
}///////////////////////////////////////////////////////////////////////////////

class MeasureLineItem {
  constructor(targetElement, viewer, moduleInstance) {
    this.htmlElemStartPoint = null;
    this.htmlElemEndPoint = null;
    this.htmlElemLine = null;
    this.htmlElemTitle = null;

    this.startPoint = null;
    this.endPoint = null;

    this.unit = "";
    this.scale = 1.0;
    this.size = 10.0;
    this.lineThickness = 2;

    this.style = {
      border: "2px solid #FFFFFF",
      background: "#009bff",
      color: "white",
      boxShadow: "0 0 10px rgba(0,0,0,0.5)"
    };

    this.htmlElemStartPoint = createHtmlElementIfNeed(this.htmlElemStartPoint, targetElement);
    this.htmlElemEndPoint = createHtmlElementIfNeed(this.htmlElemEndPoint, targetElement);
    this.htmlElemLine = createHtmlElementIfNeed(this.htmlElemLine, targetElement);
    this.htmlElemTitle = createHtmlElementIfNeed(this.htmlElemTitle, targetElement);

    this.viewer = viewer;
    this.moduleInstance = moduleInstance;
    this.targetElement = targetElement;
    this.isFinishDraw = false;
  }

  drawMeasureLine() {
    const pointSize = this.size;
    const rect = this.moduleInstance.canvas.getBoundingClientRect();

    // draw start point
    if (this.startPoint) {
      this.htmlElemStartPoint = createHtmlElementIfNeed(this.htmlElemStartPoint, this.targetElement);
    
      const pScreenStart = worldToScreen(this.startPoint, this.moduleInstance, this.viewer);
      if (isInsideRect(pScreenStart, rect.width, rect.height))
      {
        this.htmlElemStartPoint.style.display = 'block';
        this.htmlElemStartPoint.style.cursor = "pointer";
        this.htmlElemStartPoint.style.position = "absolute";
        this.htmlElemStartPoint.style.top = `${pScreenStart.y - pointSize / 2}px`;
        this.htmlElemStartPoint.style.left = `${pScreenStart.x - pointSize / 2}px`;
        this.htmlElemStartPoint.style.borderRadius = `${pointSize}px`;
        this.htmlElemStartPoint.style.border = this.style.border;
        this.htmlElemStartPoint.style.background = this.style.background;
        this.htmlElemStartPoint.style.zIndex = 2;
        this.htmlElemStartPoint.style.width = `${pointSize}px`;
        this.htmlElemStartPoint.style.height = `${pointSize}px`;
        this.htmlElemStartPoint.style.boxShadow = this.style.boxShadow;
      } else {
        this.htmlElemStartPoint.style.display = 'none';
      }
    }

    // draw end point
    if (this.endPoint && this.isFinishDraw) {
      this.htmlElemEndPoint = createHtmlElementIfNeed(this.htmlElemEndPoint, this.targetElement);

      const pScreenEnd = worldToScreen(this.endPoint, this.moduleInstance, this.viewer);

      if (isInsideRect(pScreenEnd, rect.width, rect.height))
      { 
        this.htmlElemEndPoint.style.display = 'block';
        this.htmlElemEndPoint.style.cursor = "pointer";
        this.htmlElemEndPoint.style.position = "absolute";
        this.htmlElemEndPoint.style.top = `${pScreenEnd.y - pointSize / 2}px`;
        this.htmlElemEndPoint.style.left = `${pScreenEnd.x - pointSize / 2}px`;
        this.htmlElemEndPoint.style.borderRadius = `${pointSize}px`;
        this.htmlElemEndPoint.style.border = this.style.border;
        this.htmlElemEndPoint.style.background = this.style.background;
        this.htmlElemEndPoint.style.zIndex = 2;
        this.htmlElemEndPoint.style.width = `${pointSize}px`;
        this.htmlElemEndPoint.style.height = `${pointSize}px`;
        this.htmlElemEndPoint.style.boxShadow = this.style.boxShadow;
      } else {
        this.htmlElemEndPoint.style.display = 'none';
      }
    }

    if (this.endPoint && this.startPoint) {
      const point1 = worldToScreen(this.startPoint, this.moduleInstance, this.viewer);
      const point2 = worldToScreen(this.endPoint, this.moduleInstance, this.viewer);

      const { p1, p2, angle, width } = getDataForDrawLineWithFixed(point1, point2, rect.width, rect.height);

      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;

      const height = this.lineThickness;
      if (
        isInsideRect(p1, rect.width, rect.height) &&
        isInsideRect(p2, rect.width, rect.height)
      ) {
        this.htmlElemLine = createHtmlElementIfNeed(this.htmlElemLine, this.targetElement);
        this.htmlElemLine.style.display = 'block';
        this.htmlElemLine.style.cursor = "pointer";
        this.htmlElemLine.style.position = "absolute";
        this.htmlElemLine.style.top = `${p1.y}px`;
        this.htmlElemLine.style.left = `${p1.x}px`;
        this.htmlElemLine.style.width = `${width}px`;
        this.htmlElemLine.style.transform = `rotate(${angle}deg)`;
        this.htmlElemLine.style.transformOrigin = `0px ${height / 2}px`;
        this.htmlElemLine.style.boxShadow = this.style.boxShadow;
        this.htmlElemLine.style.border = "none";
        this.htmlElemLine.style.background = this.style.background;
        this.htmlElemLine.style.zIndex = 1;
        this.htmlElemLine.style.height = `${height}px`;
  
        const distance = `${this.getDistance()} ${this.unit}`;
  
        const pX = p1.x + dx / 2;
        const pY = p1.y + dy / 2;
  
        const widthTitle = (distance.length) * 10;
  
        this.htmlElemTitle = createHtmlElementIfNeed(this.htmlElemTitle, this.targetElement);
        this.htmlElemTitle.style.display = 'block';
        this.htmlElemTitle.style.cursor = "pointer";
        this.htmlElemTitle.style.font = "10px";
        this.htmlElemTitle.style.color = "white";
        this.htmlElemTitle.style.position = "Absolute";
        this.htmlElemTitle.style.top = `${pY}px`;
        this.htmlElemTitle.style.left = `${pX - widthTitle / 2}px`;
        this.htmlElemTitle.style.width = `${widthTitle}px`;
        this.htmlElemTitle.style.transformOrigin = "0px 0px";
        this.htmlElemTitle.style.borderRadius = "5px";
        this.htmlElemTitle.style.boxShadow = this.style.boxShadow;
        this.htmlElemTitle.style.border = "none";
        this.htmlElemTitle.style.background = this.style.background;
        this.htmlElemTitle.style.zIndex = 3;
        this.htmlElemTitle.style.padding = "2px";
        this.htmlElemTitle.style.textAlign = "center";
        this.htmlElemTitle.innerHTML = `${distance}`;
      } else {
        this.htmlElemLine.style.display = 'none';
        this.htmlElemTitle.style.display = 'none';
      }
    
    }
  }

  getDistance() {
    return getDistance(this.startPoint, this.endPoint, this.moduleInstance) / this.scale;
  }

  setStartPoint(gePoint) {
    this.startPoint = gePoint;
    this.drawMeasureLine();
  }

  setEndPoint(gePoint, isFinish) {
    this.isFinishDraw = isFinish === undefined ? true : isFinish;
    this.endPoint = gePoint;
    this.drawMeasureLine();
  }

  update() {
    this.drawMeasureLine();
  }

  setSize(size) {
    this.size = size;
    this.drawMeasureLine();
  }

  clear() {
    this.endPoint = null;
    this.startPoint = null;
    this.htmlElemStartPoint = destroyHtmlElement(this.htmlElemStartPoint, this.targetElement);
    this.htmlElemEndPoint = destroyHtmlElement(this.htmlElemEndPoint, this.targetElement);
    this.htmlElemLine = destroyHtmlElement(this.htmlElemLine, this.targetElement);
    this.htmlElemTitle = destroyHtmlElement(this.htmlElemTitle, this.targetElement);
  }

  setUnit(unit) {
    this.unit = unit;
    this.drawMeasureLine();
  }

  setConversionFactor(scale) {
    this.scale = scale;
    this.drawMeasureLine();
  }

  setStyle(style) {
    this.style = style;
    this.drawMeasureLine();
  }

  setSelectionReactor(reactor) {
    onSetCallback(this.htmlElemStartPoint, reactor ? reactor.onStartPoint : null);
    onSetCallback(this.htmlElemEndPoint, reactor ? reactor.onEndPoint : null);
    onSetCallback(this.htmlElemTitle, reactor ? reactor.onTitle : null);
  }

  setSelectability(enable) {
    onSetSelectivity(this.htmlElemStartPoint, enable);
    onSetSelectivity(this.htmlElemEndPoint, enable);
    onSetSelectivity(this.htmlElemLine, enable);
    onSetSelectivity(this.htmlElemTitle, enable);
  }
}///////////////////////////////////////////////////////////////////////////////

function renameUnit(table, unit){
  return table[unit] || unit
}

class MeasureLineDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.lineThickness = 2;
    this.press = false;
    this.autoSelect = false;
    this.gripingRadius = 5.0;
    this.firstPoint = null;
    this.secondPoint = null;

    this.m_overlayElement = document.createElement("div");
    this.m_overlayElement.style.background    = "rgba(0,0,0,0)";
    this.m_overlayElement.style.position      = "fixed";
    this.m_overlayElement.style.zIndex        = "1";
    this.m_overlayElement.style.pointerEvents = "none";

    document.body.appendChild(this.m_overlayElement);

    this.renameUnitTable = {
      "Millimeters":"mm",
      "Centimeters":"cm",
      "Meters":"m",
      "Undefined": " "
    };

    this.items = [];

    this.resize();
    this._resize = () => this.resize();
    window.addEventListener('resize', this._resize);
  }

  dispose() {
    window.removeEventListener('resize', this._resize);
    super.dispose();
    this.m_overlayElement.remove();
  }

  updatePreview()
  {
    for(let item of this.items)
    {
      item.update();
    }
  }

  resize(ev) {
    const rect = this.m_module.canvas.getBoundingClientRect();

    this.m_overlayElement.style.top    = `${rect.top}px`;
    this.m_overlayElement.style.left   = `${rect.left}px`;
    this.m_overlayElement.style.width  = `${rect.width}px`;
    this.m_overlayElement.style.height = `${rect.height}px`;
  }

  getSnapPointRadius() {
    const view = this.getViewer().activeView;
    const corners = view.viewDcCorners();

    const pt1 = corners.lowerLeft;
    const pt2 = corners.upperRight;

    pt2[0] -= pt1[0];
    pt2[1] -= pt1[1];

    return Math.min(pt2[0], pt2[1]) / 120;
  }

  drag(x, y) {
    this.createNewMeasureIfNeed();
    const point = this.getViewer().getSnapPoint(x, y, this.gripingRadius);

    if (this.isDragging) {
      if (point) {
        if (this.firstPoint) {
          this.secondPoint = point;
          this.previewMeasureLine.setStartPoint(this.firstPoint);
          this.previewMeasureLine.setEndPoint(this.secondPoint);
        } else {
          this.firstPoint = point;
          this.previewMeasureLine.setStartPoint(this.firstPoint);
        }
      } else {
        this.secondPoint = null;
        this.previewMeasureLine.clear();
        this.previewMeasureLine.setStartPoint(this.firstPoint);
        this.previewMeasureLine.setEndPoint(this.getViewer().screenToWorld(x, y), false);
      }
    } else {
      if (point) {
        this.previewMeasureLine.setStartPoint(point);
      } else {
        this.previewMeasureLine.clear();
      }
    }
  }

  end() {
    if (this.firstPoint && this.secondPoint) {
      const newLineMeasure = this.createMeasureLine();
      newLineMeasure.setStartPoint(this.firstPoint);
      newLineMeasure.setEndPoint(this.secondPoint);
    }
    this.firstPoint = this.secondPoint = null;
    this.previewMeasureLine.clear();
  } 

  createNewMeasureIfNeed() {
    if (! this.previewMeasureLine) {
      this.previewMeasureLine = this.createMeasureLine();
    }
  }

  createMeasureLine() {
    const viewer = this.m_module.getViewer();
    var item = new MeasureLineItem(this.m_overlayElement, viewer, this.m_module);
    item.lineThickness = this.lineThickness || item.lineThickness;
    item.setUnit(renameUnit(this.renameUnitTable,viewer.getUnit()));
    this.items.push(item);
    return item;
  }

  
}///////////////////////////////////////////////////////////////////////////////

class OdBaseCuttingPlaneDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;

    this.getViewer().setEnableAutoSelect(false);
    //this.getViewer().getMarkupController().clear();

    const ext = this.getViewer().getActiveExtents();
    const min = ext.min();
    const max = ext.max();

    this.m_size_x = Math.abs(max[0] - min[0]) / 2.;
    this.m_size_y = Math.abs(max[1] - min[1]) / 2.;
    this.m_size_z = Math.abs(max[2] - min[2]) / 2.;

    this.m_center = this.toPoint(ext.center());
    this.m_normal = this.createNormal();

    const avp = this.getViewer().activeView;
    const plane = this.createPlane();
    plane.set(this.toGePoint(this.m_center), this.m_normal);

    avp.addCuttingPlane(plane);
    this.index = avp.numCuttingPlanes() - 1;
    avp.setEnableCuttingPlaneFill(true, 0x66, 0x66, 0x66);

    this.m_model = this.getModel();
    this.createPreview();

    this.deleteAll([ext, avp, plane]);
  }

  dispose() {
    super.dispose();

    if (this.m_entity) {
      this.m_model.removeEntity(this.m_entity);
      this.deleteAll([this.m_model, this.m_entity, this.planePreview]);
      this.m_entity = null;
      this.planePreview = null;
    }
  }


  createNormal() {
    return [0., 0., 0.];
  }

  handleDelta(delta) {
    return delta;
  }

  getPlanePreviewCoordinate() {
    return [];
  }

  start(x, y) {
    this.press = true;
    this.m_last = this.screenToWorld(x, y);
    this.m_click = { x: x, y: y };
  }

  drag(x, y) {
    if (this.press) {
      const point = this.screenToWorld(x, y);
      const delta = this.handleDelta(point.sub(this.m_last));

      const oldCenter = this.m_center;
      this.m_center = oldCenter.add(delta);

      const oldLast = this.m_last;
      this.m_last = point;

      const avp = this.getViewer().activeView;
      const plane = this.createPlane();
      const newPlane = plane.set(this.toGePoint(this.m_center), this.m_normal);
      const newCutting = avp.updateCuttingPlane(this.index, plane);

      this.drawPreview();

      this.deleteAll([avp, plane, oldCenter, delta, oldLast, newPlane, newCutting]);
    }
  }

  end(x, y) {
    this.press = false;
    if (x === this.m_click.x && y === this.m_click.y) {
      this.m_normal = [this.m_normal[0] * -1, this.m_normal[1] * -1, this.m_normal[2] * -1];

      const avp = this.getViewer().activeView;
      const plane = this.createPlane();
      plane.set(this.toGePoint(this.m_center), this.m_normal);
      avp.updateCuttingPlane(this.index, plane);

      this.deleteAll([avp, plane, this.m_center, this.m_last]);
    }
  }

  createPreview() {
    this.m_entity = this.m_model.appendEntity('&CuttingPlanePreview');

    const GeometryTypes = this.m_module.GeometryTypes;

    const transparencyDef = new this.m_module.OdTvTransparencyDef();
    const colorDef = new this.m_module.OdTvColorDef(112, 112, 112); //0x53, 0x72, 0xAE

    transparencyDef.setValue(0.9);

    const entityPtr = this.m_entity.openObject();
    entityPtr.setColor(colorDef, GeometryTypes.kFaces.value);

    colorDef.setColor(112, 112, 112); //0xcd, 0xe2, 0xff
    entityPtr.setColor(colorDef, GeometryTypes.kEdges.value);

    entityPtr.setLineWeight(5);

    entityPtr.setTransparency(transparencyDef, GeometryTypes.kFaces);
    transparencyDef.setValue(1.0);
    entityPtr.setTransparency(transparencyDef, GeometryTypes.kEdges);

    this.planePreview = entityPtr.appendPolygon(this.getPlanePreviewCoordinate());
    const polygonPtr = this.planePreview.openAsPolygon();
    polygonPtr.setFilled(true);

    this.deleteAll([transparencyDef, colorDef, entityPtr, polygonPtr, GeometryTypes]);
  }

  drawPreview() {
    const polygonPtr = this.planePreview.openAsPolygon();
    polygonPtr.setPoints(this.getPlanePreviewCoordinate());
    this.deleteAll([polygonPtr]);
  }


}///////////////////////////////////////////////////////////////////////////////

class OdCuttingPlaneXAxisDragger extends OdBaseCuttingPlaneDragger {

  createNormal() {
    return [1., 0., 0.];
  }

  handleDelta(delta) {
    delta.y = 0.0;
    delta.z = 0.0;
    return delta;
  }

  getPlanePreviewCoordinate() {
    return [
      this.m_center.x, this.m_center.y - this.m_size_y, this.m_center.z - this.m_size_z,
      this.m_center.x, this.m_center.y + this.m_size_y, this.m_center.z - this.m_size_z,
      this.m_center.x, this.m_center.y + this.m_size_y, this.m_center.z + this.m_size_z,
      this.m_center.x, this.m_center.y - this.m_size_y, this.m_center.z + this.m_size_z
    ];
  }
}///////////////////////////////////////////////////////////////////////////////

class OdCuttingPlaneYAxisDragger extends OdBaseCuttingPlaneDragger {

  createNormal() {
    return [0., 1., 0.];
  }

  handleDelta(delta) {
    delta.x = 0.0;
    delta.z = 0.0;
    return delta;
  }

  getPlanePreviewCoordinate() {
    return [
      this.m_center.x - this.m_size_x, this.m_center.y , this.m_center.z - this.m_size_z,
      this.m_center.x + this.m_size_x, this.m_center.y , this.m_center.z - this.m_size_z,
      this.m_center.x + this.m_size_x, this.m_center.y , this.m_center.z + this.m_size_z,
      this.m_center.x - this.m_size_x, this.m_center.y , this.m_center.z + this.m_size_z
    ];
  }
}///////////////////////////////////////////////////////////////////////////////

class OdCuttingPlaneZAxisDragger extends OdBaseCuttingPlaneDragger {

  createNormal() {
    return [0., 0., 1.];
  }

  handleDelta(delta) {
    delta.x = 0.0;
    delta.y = 0.0;
    return delta;
  }

  getPlanePreviewCoordinate() {
    return [
      this.m_center.x - this.m_size_x, this.m_center.y - this.m_size_y, this.m_center.z,
      this.m_center.x + this.m_size_x, this.m_center.y - this.m_size_y, this.m_center.z,
      this.m_center.x + this.m_size_x, this.m_center.y + this.m_size_y, this.m_center.z,
      this.m_center.x - this.m_size_x, this.m_center.y + this.m_size_y, this.m_center.z
    ];
  }
}///////////////////////////////////////////////////////////////////////////////

class OdaLineDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.getViewer().setEnableAutoSelect(false);
  }

  dispose() {
    super.dispose();
    this.end();
    this.points = null;
    this.drawPoints = null;
  }
  
  start(x, y) {
    const point = this.getViewer().screenToWorld(x, y);
    this.drawPoints = [point[0], point[1], point[2]];
  }

  drag(x, y) {
    if (this.isDragging) {
      const point = this.getViewer().screenToWorld(x, y);
      this.drawPoints.push(point[0], point[1], point[2]);
      this._updateFrame();
    }
  }

  end() {
    if (this.entity) {
      this.entity.delete();
      this.drawPoints = null;
      this.entity = null;
    }
  }

   _updateFrame() {
    if (this.entity) {
      const model = this.getViewer().getMarkupModel();
      model.removeEntity(this.entity);
      model.delete();
      this.entity.delete();
    }

    this.entity = this.getActiveMarkupEntity("Line");

    const entityPtr = this.entity.openObject();
    entityPtr.appendPolyline(this.drawPoints).delete();
    entityPtr.delete();
  }
}///////////////////////////////////////////////////////////////////////////////

class OdaTextDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.getViewer().setEnableAutoSelect(false);
  }

  dispose() {
    super.dispose();
    this.textRef && this.textRef.remove();
    this.textRef = null;
  }

  _finishInput() {
    this._updateFrame();
    this.textRef && this.textRef.remove();
    this.textRef = null;
  }

  start(x, y, absoluteX, absoluteY) {
    if (!this.textRef) {
      this.textRef = document.createElement('textarea');
      this.textRef.style.zIndex = 9999;
      this.textRef.style.position = 'absolute';
      this.textRef.style.display = 'block';
      this.textRef.style.top = absoluteY + 'px';
      this.textRef.style.left = absoluteX + 'px';
      this.textRef.onkeypress = (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this._finishInput();
        }
      };
      document.body.appendChild(this.textRef);

      this.press = true;
      this.m_data = null;
      this.m_center = this.screenToWorld(x, y + 24);
      this.needInputText = true;
    } else {
      this._finishInput();
    }
  }

  _updateFrame() {

    this.entity = this.getActiveMarkupEntity("Text");
    const entityPtr = this.entity.openObject();

    const view = this.getViewer().activeView;
    const pos = this.toPoint(view.viewPosition);
    const target = this.toPoint(view.viewTarget);

    const eyeToWorld = view.eyeToWorldMatrix;
    const eyeDir = pos.sub(target).asVector();

    const xDir = this.toVector([1.0, 0.0, 0.0]);
    const direction = xDir.transformBy(eyeToWorld);

    const mtrx = this.createMatrix3d();
    mtrx.setToWorldToPlane(this.toGeVector(eyeDir));
    direction.transformBy(mtrx);

    let angel = -Math.atan2(-direction.y, direction.x);

    let textSize = 0.02;
    let textScale = 1.0;

    const projMtrx = view.projectionMatrix;
    const mtrxNumber = projMtrx.get(1, 1);
    const tol = 1.0e-6;
    if (!(mtrxNumber < tol && mtrxNumber > -tol)) {
      textScale = 1. / mtrxNumber;
    }

    const geomData = entityPtr.appendText(this.toGePoint(this.m_center), this.textRef.value.trimLeft());
    const textPtr = geomData.openAsText();

    textPtr.setNormal(this.toGeVector(eyeDir));
    textPtr.setRotation(angel);
    textPtr.setTextSize(textSize * textScale);
    textPtr.delete();
    geomData.delete();
    entityPtr.delete();
  }
}///////////////////////////////////////////////////////////////////////////////


const FocalLengthConst = 42.0;//42.0 

const calcFocalLength = (lensLength, fieldWidth, fieldHeight) => {
  return (lensLength / FocalLengthConst * Math.sqrt(fieldWidth * fieldWidth + fieldHeight * fieldHeight));
};

class OdaWalkDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.getViewer().setEnableAutoSelect(false);

    this.lastCoord = { x: 0, y: 0 };

    this.speed = 1;
    this.delta = this.getViewer().activeView.viewFieldWidth / 1000;

    this.keyPressMap = new Set();

    this.onKeyDown = (ev) => {
      const currentDelta = this.speed * this.delta;
      this.keyPressMap.add(ev.code);

      for(let keyCode of this.keyPressMap) {
        if (keyCode === 'KeyW') {
          this.cameraWalker.moveForward(currentDelta);
        } else if (keyCode === 'KeyS') {
          this.cameraWalker.moveBackward(currentDelta);
        } else if (keyCode === 'KeyA') {
          this.cameraWalker.moveLeft(currentDelta);
        } else if (keyCode === 'KeyD') {
          this.cameraWalker.moveRight(currentDelta);
        } else if (keyCode === 'KeyQ') {
          this.cameraWalker.moveUp(currentDelta);
        } else if (keyCode === 'KeyE') {
          this.cameraWalker.moveDown(currentDelta);
        } else if (keyCode === 'NumpadSubtract' || keyCode === 'Minus') {
          this.speed = this.speed !== 1 ? this.speed - 1 : 1;
          this.subject.emitEvent({ type: 'ChangeWalkDraggerSpeed', data: this.speed});
        } else if (keyCode === 'NumpadAdd' || keyCode === 'Equal') {
          this.speed = this.speed !== 10 ? this.speed + 1 : 10;
          this.subject.emitEvent({ type: 'ChangeWalkDraggerSpeed', data: this.speed});
        }
      }
    };

    this.onKeyRelease = (ev) => {
      this.keyPressMap.delete(ev.code);
    };

    window.addEventListener('keydown', this.onKeyDown, false);
    window.addEventListener('keyup', this.onKeyRelease, false);

    if (! this.cameraId) {
      this.initialize();
    }

    this.subject._setEnableForZoomWheelDragger(false);
  }

  initialize() {
    const view = this.getViewer().activeView;

    this.subject.emitEvent({type: 'StartWalkerDragger', data: null});

    this.viewParams = {
      position        : view.viewPosition,
      target          : view.viewTarget,
      upVector        : view.upVector,
      viewFieldWidth  : view.viewFieldWidth,
      viewFieldHeight : view.viewFieldHeight,
      perspective     : view.perspective,
      lensLength      : view.lensLength
    };

    const extView = this.getViewer().getActiveTvExtendedView();
    extView.setView(
      this.viewParams.position,
      this.viewParams.target,
      this.viewParams.upVector,
      this.viewParams.viewFieldWidth,
      this.viewParams.viewFieldHeight,
      true
    );
    extView.delete();

    view.lensLength = view.lensLength * 42 / 120;
    
    const model = this.getViewer().getActiveModel();
    this.cameraId = model.appendCamera("Camera0");
    const pCamera = this.cameraId.openObjectAsCamera();
    var target = view.viewTarget;

    pCamera.setDisplayGlyph(false);
    pCamera.setDisplayTarget(false);
    pCamera.setAutoAdjust(true);
    pCamera.setupCamera(view.viewPosition, target, view.upVector);
    pCamera.setNearClip(false, 1.0);
    pCamera.setFarClip(false, 0.);
    pCamera.setViewParameters(
      view.viewFieldWidth,
      view.viewFieldHeight,
      true);
 
    const focalL = calcFocalLength(view.lensLength, view.viewFieldWidth, view.viewFieldHeight);
  
    {
      const pTarget = this.toPoint(view.viewTarget);
      const viewDir = this.toPoint(view.viewPosition);
      const viewDirSub = viewDir.sub(pTarget);
      const viewDirVec = viewDirSub.asVector();
      const viewDirVecNormal = viewDirVec.normalize();
  
      const geViewDir = this.toGeVector(viewDirVecNormal);
      const newGeViewDir = [geViewDir[0] * focalL, geViewDir[1] * focalL, geViewDir[2] * focalL];

      const pTarget2 = this.toPoint(view.viewTarget);
      const newGeViewDirPt = this.toPoint(newGeViewDir);

      const newPos = pTarget2.add(newGeViewDirPt);
      pCamera.setupCamera(this.toGePoint(newPos), view.viewTarget, view.upVector);

      this.deleteAll([pTarget, viewDir, viewDirSub, viewDirVec, viewDirVecNormal, pTarget2, newGeViewDirPt, newPos]);
    }

    pCamera.assignView(view);
    pCamera.delete();
    model.delete();
    //pCamera.setAdjustLensLength(true);
    this.cameraWalker = new this.m_module.OdTvCameraWalker();
    this.cameraWalker.setCamera(this.cameraId);
  }

  dispose() {
    super.dispose();

    this.keyPressMap.clear();

    window.removeEventListener('keydown', this.onKeyDown);
    window.removeEventListener('keyup', this.onKeyRelease);

    if (this.cameraId)
    {
      const model = this.getViewer().getActiveModel();
      model.removeEntity(this.cameraId);
      model.delete();
      this.cameraWalker && this.cameraWalker.delete();
    }

    if (this.viewParams) {
      const extView = this.getViewer().getActiveTvExtendedView();

      extView.setView(
        this.viewParams.position,
        this.viewParams.target,
        this.viewParams.upVector,
        this.viewParams.viewFieldWidth,
        this.viewParams.viewFieldHeight,
        this.viewParams.perspective
      );
      extView.delete();

      const avp = this.getViewer().activeView;

      avp.lensLength = this.viewParams.lensLength;
      avp.delete();
    }

    this.subject._setEnableForZoomWheelDragger(true);
  }

  drag(x, y, dltX, dltY) {
    const view = this.getViewer().activeView;

    const focalL = calcFocalLength(view.lensLength, view.viewFieldWidth, view.viewFieldHeight);

    const hAngle = Math.atan(view.viewFieldHeight/(2 * focalL)) * 2;
    const wAngle = Math.atan(view.viewFieldWidth/(2 * focalL)) * 2;

    const dltAngleY = Math.abs(dltY) * hAngle / this.m_module.canvas.height * this.subject.api.options.cameraAxisYSpeed;
    const dltAngleX = Math.abs(dltX) * wAngle / this.m_module.canvas.width * this.subject.api.options.cameraAxisXSpeed;

    if (this.cameraId && this.isDragging) {
      if (dltX !== 0.0) {
        if (dltX > 0) {
          this.cameraWalker.turn(this.viewParams.upVector, -dltAngleX);
        } else if (dltX < 0) {
          this.cameraWalker.turn(this.viewParams.upVector, dltAngleX);
        }
      }

      if (dltY !== 0.0) {
        if (dltY < 0) {
          this.cameraWalker.turnUp(dltAngleY);
        } else if (dltY > 0) {
          this.cameraWalker.turnDown(dltAngleY);
        }
      }
    }
  }
}function setupViewerSettings(lib) {
  const viewer = lib.getViewer();
  const device = viewer.getActiveDevice();
  const view   = device.getActiveView();

  { // setup light
    view.enableDefaultLighting(true, lib.DefaultLightingType.kTwoLights);
    view.setDefaultLightingIntensity(1.25);
  }

  // setup visual style
  const visualStyleId = viewer.createVisualStyle("OpenCloud");
  {
    const visualStylePtr = visualStyleId.openObject();
    const colorDef       = new lib.OdTvColorDef(66, 66, 66);
    const shadedVsId     = viewer.findVisualStyle("Realistic");

    visualStylePtr.copyFrom(shadedVsId);
    visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kFaceModifiers, 0, lib.VisualStyleOperations.kSet);
    //visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeModel, 1, lib.VisualStyleOperations.kSet);
    visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeModel, 2, lib.VisualStyleOperations.kSet);
    visualStylePtr.setOptionDouble(lib.VisualStyleOptions.kEdgeCreaseAngle, 60, lib.VisualStyleOperations.kSet);
    visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeStyles, 0, lib.VisualStyleOperations.kSet);
    visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeModifiers, 8, lib.VisualStyleOperations.kSet);
    visualStylePtr.setOptionColor(lib.VisualStyleOptions.kEdgeColorValue, colorDef, lib.VisualStyleOperations.kSet);

    visualStylePtr.delete();
  }

  view.visualStyle = visualStyleId;
  view.delete();
  device.delete();
}/**
 * Client viewer class
 * There are many instances may be in project
 * @class
 */
class Viewer {

  /**
 * Viewer Options
 * @typedef {Object} ViewerOptions
 * @property {string} visualizeJsUrl - url to visualizeJS
 */

  /**
   * @constructor
   * @param {Viewer} api 
   */
  constructor(api) {
    this.api = api;

    this._changeClientOptionCb = (event) => {
      const opt = event.data;
      this.syncOptions(opt);
    };

    this.api.eventEmitter.on('changeClientOption', this._changeClientOptionCb);

    /**
     * @type {ViewerOptions}
     */
    this.opt = { visualizeJsUrl: "https://opencloud.azureedge.net/libs/visualizejs/23.1/Visualize.js" };
    this._activeDragger = null;
    this.visualizeJs = null;

    /**
     * @type {EventEmitter}
     */
    this.eventEmitter = new EventEmitter$1();

    /**
     * Dragger factory
     * @type {Map}
     * @example draggerFactory.set("Line", OdaLineDragger);
     */
    this.draggerFactory = new Map();
    this.draggerFactory.set("Line", OdaLineDragger);
    this.draggerFactory.set("Text", OdaTextDragger);
    this.draggerFactory.set("Pan", OdPanDragger);
    this.draggerFactory.set("Orbit", OdOrbitDragger);
    this.draggerFactory.set("Zoom", OdZoomDragger);
    this.draggerFactory.set("ZoomWindow", OdZoomWindowDragger);
    this.draggerFactory.set("OrbitAroundBuilding", OrbitAroundBuildingDragger);
    this.draggerFactory.set("MeasureLine", MeasureLineDragger);
    this.draggerFactory.set("CuttingPlaneXAxis", OdCuttingPlaneXAxisDragger);
    this.draggerFactory.set("CuttingPlaneYAxis", OdCuttingPlaneYAxisDragger);
    this.draggerFactory.set("CuttingPlaneZAxis", OdCuttingPlaneZAxisDragger);
    this.draggerFactory.set("Walk", OdaWalkDragger);

    this.render = () => {
      this.frameId = requestAnimationFrame(this.render);
      this.visViewer().update();
    };
  }

  syncOptions(opt)
  {
    const viewer = this.visViewer();
    if (viewer)
    {
      if (opt.showFPS !== viewer.getEnableFPS())
      {
        viewer.setEnableFPS(opt.showFPS);
      }

      if (opt.showWCS !== viewer.getEnableWCS())
      {
        viewer.setEnableWCS(opt.showWCS);
      }

      if (opt.cameraAnimation !== viewer.getEnableAnimation())
      {
        viewer.setEnableAnimation(opt.cameraAnimation);
      }

      if (opt.antialiasing !== viewer.fxaaAntiAliasing3d)
      {
        viewer.fxaaAntiAliasing3d = opt.antialiasing;
        viewer.fxaaQuality = 5;
      }

      if (opt.groundShadow !== viewer.groundShadow)
      {
        viewer.groundShadow = opt.groundShadow;
      }

      if (opt.shadows !== viewer.shadows)
      {
        viewer.shadows = opt.shadows;
        const canvas = this.visLib().canvas;
        const device = viewer.getActiveDevice();
        device.invalidate([0, canvas.clientWidth, canvas.clientHeight, 0]);
        device.delete();
      }

      const lib = this.visLib();
      const device = viewer.getActiveDevice();
      if (opt.ambientOcclusion !== device.getOptionBool(lib.DeviceOptions.kSSAOEnable))
      {
      

        device.setOptionBool(lib.DeviceOptions.kSSAOEnable, opt.ambientOcclusion);
        device.setOptionBool(lib.DeviceOptions.kSSAODynamicRadius, true);
        device.setOptionDouble(lib.DeviceOptions.kSSAORadius, 1.);
        device.setOptionInt32(lib.DeviceOptions.kSSAOLoops, 32);
        device.setOptionDouble(lib.DeviceOptions.kSSAOPower, 2.);
        device.setOptionInt32(lib.DeviceOptions.kSSAOBlurRadius, 2);

        const avp = viewer.activeView;
        avp.setSSAOEnabled(opt.ambientOcclusion);
        avp.delete();
      }
      device.delete();
    }
  }

  _setEnableForZoomWheelDragger(enable) {
    if (enable && !this.wheelZoomDragger) {
      this.wheelZoomDragger = new OdZoomWheelDragger(this);
    } else {
      this.wheelZoomDragger && this.wheelZoomDragger.dispose();
      this.wheelZoomDragger = null;
    }
  }

  /**
   * Configure Viewer
   * @param {ViewerOptions}
   * @returns {Viewer}
   */
  configure(opt) {
    this.opt = opt;
    return this
  }

  /**
   * Viewer initialize Callback
   *
   * @callback VisualizeJSProgressCallback
   * @param {Viewer} 
   */

  /**
   * Intialize VisualizeJS with particular canvas
   * @param {HTMLCanvasElement}
   * @param {VisualizeJSProgressCallback} [onprogress = null] - The callback that handles the response.
   * @async
   */
  initializeAsync(canvas, onprogress = null) {
    if (canvas.style.width === '' && canvas.style.height === '') 
    {
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    }

    return loadVisualizeJS(this.opt.visualizeJsUrl,
      ev => {
        const { loaded, timeStamp, total, lengthComputable } = ev;
        const event = { loaded, timeStamp, total, lengthComputable, type: "visualize-progress" };
        onprogress && onprogress(event);
      }
    )
      .then(visualizeJs => this.visualizeJs = visualizeJs)
      .then(() => {
        canvas.width = canvas.clientWidth * window.devicePixelRatio;
        canvas.height = canvas.clientHeight * window.devicePixelRatio;
        this.visualizeJs.canvas = canvas;
        this.visualizeJs.Viewer.create();

      })
      .then(() => {
        this.syncOptions(this.api.options);

        this.eventEmitter.attach(this.visualizeJs.canvas, "mousemove");
        this.eventEmitter.attach(this.visualizeJs.canvas, "mousedown");
        this.eventEmitter.attach(this.visualizeJs.canvas, "mouseup");
        this.eventEmitter.attach(this.visualizeJs.canvas, "mouseleave");
        this.eventEmitter.attach(this.visualizeJs.canvas, "click");
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchstart");
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchend");
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchcancel");
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchmove");
        this.eventEmitter.attach(this.visualizeJs.canvas, "dblclick");
        this.eventEmitter.attach(this.visualizeJs.canvas, "wheel");

        this.eventEmitter.attach(window, "resize");

        this.wheelZoomDragger = new OdZoomWheelDragger(this);

        this.eventEmitter.addEventListener("resize", ev => {
          const { clientWidth, clientHeight } = canvas;
          canvas.height = clientHeight * window.devicePixelRatio;
          canvas.width = clientWidth * window.devicePixelRatio;

          this.visViewer().resize(0, canvas.width, canvas.height, 0);
          if (this.activeDragger() && this.activeDragger().updatePreview)
          {
            this.activeDragger().updatePreview();
          }
        });
      })
      .then(() => this.render())
      .then(() => Promise.resolve(this))
  }

  /**
   * Keys for available draggers in dragger factory
   * @property {string[]}
   */
  get draggers() {
    return [...this.draggerFactory.keys()]
  }

  /**
   * @function
   * @returns {(string | null)} - Current active dragger name
   */
  activeDragger() {
    return this._activeDragger
  }

  /**
  * Set active dragger
  * @function
  * @param {string}
  */
  setActiveDragger(name) {
    const Constructor = this.draggerFactory.get(name);
    if (!(this._activeDragger instanceof Constructor)) {
      this._activeDragger && this._activeDragger.dispose();
      this._activeDragger = null;
      this._activeDragger = new Constructor(this);
    }
  }

  /**
  * Get visualizeJS lib
  * @function
  * @returns {Object}
  */
  visLib() {
    return this.visualizeJs
  }

  /**
 * Get visualizeJS viewer instance
 * @function
 * @returns {Object}
 */
  visViewer() {
    return this.visualizeJs.getViewer()
  }

  /**
  * Clear slices | cutting planes
  * @function
  */
  clearSlices() {
    const avp = this.visViewer().activeView;
    avp.removeCuttingPlanes();
    avp.delete();
  }

  /**
   * Clear markup
   * @function
   */
  clearOverlay() {
    const markupCtrl = this.visViewer().getMarkupController();
    markupCtrl.clear();
    markupCtrl.delete();
  }

  /**
   * Is current drawing 3d 
   * @function
   * @returns {boolean}
   */
  is3D() {
    const ext = this.visViewer().getActiveExtents();
    const min = ext.min();
    const max = ext.max();
    const extHeight = max[2] - min[2];
    const is3D = extHeight !== 0;
    return is3D
    //return this.visViewer().activeView.upVector[1] >= 0.95;
  }

  /**
   * Destructor for this Viewer, releases all resources and unsubscribe all events
   * @function
   * @returns {boolean}
   */
  dispose() {
    if (this.visLib()) {
      if (this.activeDragger()) {
        this.activeDragger().dispose();
      }
      this.visViewer().clear();
    }

    cancelAnimationFrame(this.frameId);
    this.eventEmitter.detach(this.visualizeJs.canvas, "mousemove");
    this.eventEmitter.detach(this.visualizeJs.canvas, "mousedown");
    this.eventEmitter.detach(this.visualizeJs.canvas, "mouseup");
    this.eventEmitter.detach(this.visualizeJs.canvas, "mouseleave");
    this.eventEmitter.detach(this.visualizeJs.canvas, "click");
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchstart");
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchend");
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchcancel");
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchmove");
    this.eventEmitter.detach(this.visualizeJs.canvas, "dblclick");
    this.eventEmitter.detach(this.visualizeJs.canvas, "wheel");
    this.eventEmitter.detach(window, "resize");

    this.eventEmitter.removeEventListener();
    this.wheelZoomDragger.dispose();

    this._abortController && this._abortController.abort();
    this.api.eventEmitter.remove('changeClientOption', this._changeClientOptionCb);
  }

  /**
   * Provide subscribe to event emitter
   * @function
   * @param {string} name - Event type
   * @param {function} - Callback for event
   */
  addEventListener(name, cb) {
    this.eventEmitter.addEventListener(name, cb);
  }

  /**
   * Provide unsubscribe from event emitter
   * @function
   * @param {string} name - Event type
   * @param {function} - Callback for event
   */
  removeEventListener(name, cb) {
    this.eventEmitter.removeEventListener(name, cb);

  }

  /**
 * Provide emit event to event emitter
 * @function
 * @param {EventObject} event - Event object
 */
  emitEvent(event) {
    this.eventEmitter.emitEvent(event);
  }

  /**
   * Returns array of currently selected objects
   * @function
   * @returns {Object[]}
   */
  getSelected() {
    const result = [];
    const selectionSet = this.visViewer().getSelected();
    if (!selectionSet.isNull()) {

      const itr = selectionSet.getIterator();
      while (!itr.done()) {
        const entityId = itr.getEntity();
        const entityPtr = entityId.openObject();
        const nativeHandle = entityPtr.getNativeDatabaseHandle();
        result.push(nativeHandle);
        entityPtr.delete();
        entityId.delete();
        itr.step();
      }
      itr.delete();
    }
    selectionSet.delete();
    return result
  }

  /**
   * Load references like images, fonts, other files to view model correctly
   * @function
   * @async
   * @param {Model} model - model 
   * @returns {Promise}
   */
  async loadReferences(model) {
    let refs = [];
    try {
      const refsData = await model.getReferences();
      refs = refsData.references;
    } catch {
      //ignore
    }

    if (!this.visLib()) {
      throw new Error("VisualizeJS module is null when try load references");
    }

    if (!this.visViewer()) {
      throw new Error("VisualizeJS module getViewer return null, pls create viewer before load reference");
    }


    for (let refItem of refs) {
      const buffer = await this.api.downloadReferenceFile(refItem.id);
      this.visViewer().addEmbeddedFile(refItem.name, new Uint8Array(buffer));
    }
  }

  async _openTcsStream(model) 
  {
    const abortController = new AbortController();
    this._abortController = abortController;

    const listFileForDownload = [model.database, ...model.geometry];
    const chunksProgress = listFileForDownload.map(() => 0);

    const calcProgress = (index, progress) => {
      chunksProgress[index] = progress;
      const fileProgress = chunksProgress.reduce((acc, progress) => acc += progress) / (chunksProgress.length || 1);
      this.emitEvent({ type: 'geometry-progress', data: fileProgress });
    };

    this.emitEvent({ type: "geometry-start", data: model });

    this.visViewer().clear();
    this.visViewer().update();

    try {

      for (let i = 0; i < listFileForDownload.length; i++) {

        const chunk = listFileForDownload[i];
        const arrayBuffer = await model.downloadResource(chunk, progress => calcProgress(i, progress), abortController.signal);

        if (abortController.signal.aborted) {
          await Promise.reject(new Error(`Open model aborted  ${model.name}`));
        }

        this.visViewer().parseStream(new Uint8Array(arrayBuffer));
        if (i == 0) {
          this.syncOptions(this.api.options);
          setupViewerSettings(this.visLib());
        }
        
        this.emitEvent({
          type: i == 0 ? 'database-chunk' : 'geometry-chunk',
          data: new Uint8Array(arrayBuffer)
        });

        this.visViewer().update();
      }
      this.emitEvent({ type: "geometry-end", data: model });

    } catch (error) {
      this.emitEvent({ type: "error", data: error.message || error });
      throw error
    }
    return this
  }

  async openVsfxStream(model)
  {
    const abortController = new AbortController();
    this._abortController = abortController;

    this.emitEvent({ type: "geometry-start", data: model });
    this.visViewer().clear();
    this.visViewer().update();
    let isFireDatabaseChunk = false;
    try 
    {
      await model.partialDownloadResource(model.database,
        abortController.signal,
        (progress, value) => {
          const state = this.visViewer().parseVsfx(value);
          if (state === this.visLib().DatabaseStreamStatus.ReadyServiceData ||
              state === this.visLib().DatabaseStreamStatus.Complete && !isFireDatabaseChunk)
          {
            isFireDatabaseChunk = true;
            this.syncOptions(this.api.options);
            setupViewerSettings(this.visLib());
            this.emitEvent({ type: 'database-chunk', data: value });
          }
          else if (state === this.visLib().DatabaseStreamStatus.AwaitingObjectsData)
          {
            this.emitEvent({ type: 'geometry-chunk', data: value  });
          }
          this.emitEvent({ type: 'geometry-progress', data: progress });

      });
      this.emitEvent({ type: "geometry-end", data: model });
    } 
    catch (error)
    {
      this.emitEvent({ type: "error", data: error.message || error });
      throw error
    }
    return this
  }

  /**
   * Open file or model
   * @function
   * @async
   * @param {(Model|File)} model - model 
   * @returns {Promise}
   */
  async open(object) {
    this.cancel();

    let model = object;
    if (object.getModels) {
      const models = await object.getModels();
      model = models.find(model => model.default);
    }

    if (model.geometry.length === 0 && model.database.substr(-5) === '.vsfx')
    {
      await this.openVsfxStream(model);
    }
    else
    {
      await this._openTcsStream(model);
    }

    {
      const assembly = model.assembly;
      const lib = this.visLib();
      if (assembly)
      {
        const modelItr = this.visViewer().getModelIterator();
        for (; !modelItr.done(); modelItr.step())
        {
          const model = modelItr.getModel();
          const transform = assembly.getModelTransformMatrix(model.getDatabaseHandle());
          if (transform)
          {
            const extents = model.getExtents();
            const matrix = composingMatrixFromTransform(
              transform.translate, 
              transform.rotation, 
              transform.scale, 
              extents.center(), 
              new lib.Matrix3d());

            model.setModelingMatrix(matrix, true);
          }
        }
      }
    }
  }

  /**
   * Open file or model
   * @function
   * @param {(Uint8Array|ArrayBuffer)} binary - data of .vsf file
   * @returns {Viewer}
   */
  openVsfFile(binary) {
    if (!binary instanceof Uint8Array) {
      binary = new Uint8Array(binary);
    }
    this.visViewer().parseFile(binary);
    this.syncOptions(this.api.options);
    setupViewerSettings(this.visLib());
    return this
  }

  /**
 * Cancel asynchronous open model | file
 * @function
 * @returns {Viewer}
 */
  cancel() {
    this._abortController && this._abortController.abort();
    return this
  }

}class Assembly {
  
  constructor(impl) {
    this._impl = impl;
  }
  /**
   * Assembly id
   * @type {string}
   */
  get id() { return this._impl._data.id }
  /**
   * Assembly name
   * @type {string}
   */
  get name() { return this._impl._data.name }
  set name(value) { this._impl._data.name = value; }
  /**
   * Ids files
   * @type {Array<string>}
   */
  get files() { return this._impl._data.files }
  /**
   * owner - short description
   * @type {Object}
   */
  get owner() { return this._impl._data.owner }
  /**
   * File id
   * @type {string}
   */
  get created() { return this._impl._data.created }
  /**
   * File id
   * @type {string}
   */
  get status() { return this._impl._data.status }
  /**
   * Ids related jobs
   * @type {Array<string>}
   */
  get relatedJobs() { return this._impl._data.relatedJobs }

  /**
   * Return transform matrix by handle
   * @type {Transform}
   */
  getModelTransformMatrix(handle)
  {
    return this._impl._data.transform[handle];
  }

  /**
   * Set transform matrix by handle
   * @param {string} handle - model handle
   * @param {Transform} transform - transform matrix
   */
  setModelTransformMatrix(handle, transform)
  {
    this._impl._data.transform[handle] = transform;
    return this._impl._put('', { transform: this._impl._data.transform });
  }

  /**
 * Get file models
 * @function
 * @async
 * @returns {Model[]}
 */
  getModels() {
    return this._impl.getModels().then(models => models.map(modelImpl => new Model(modelImpl, null, this)))
  }

  /**
   * Get property by id
   * @param {string} id 
   * @async 
   * @returns {Object} - property object
   */
  getProperty(id) {
    return this._impl.getProperty(id)
  }

  /**
   * Get all properties
   * @async 
   * @returns {Property[]} - properties array
   */
  getProperties() {
    return this._impl.getProperties()
  }

  /**
  * Delete file
  * @async 
  * @returns {Object} - 
  */
  delete() {
    return this._impl.delete()
  }

  /**
   * Download resource by id
   * @async
   * @param {string} dataId - dataId
   * @param {string} onProgress - onprogress callback
   * @param {AbortSignal} signal - signal for cancellation
   * @returns {ArrayBuffer} - binary data
   */ 
  downloadResource(dataId, onProgress, signal) {
    return this._impl.downloadResource(dataId, onProgress, signal)
  }

  /**
   * Save file changes
   * @async 
   * @returns {Object}  
   */
  save() {
    return this._impl.save()
  }

  /**
   * Get file references
   * @async 
   * @returns {References}
   */
  getReferences() {
    return {fileId: '', references: [] }
  }
}class Options
{
  constructor(emitter)
  {
    this._showFPS = false;
    this._showWCS = true;
    this._cameraAnimation = true;
    this._antialiasing = true;
    this._groundShadow = false;
    this._shadows = false;
    this._cameraAxisXSpeed = 4;
    this._cameraAxisYSpeed = 1;
    this._ambientOcclusion = false;
    this.loadFromStorage();
    this._emitter = emitter;
  }

  notifierChangeEvent()
  {
    if (this._emitter)
    {
      this.saveToStorage();
      this._emitter.emit(
        {
          type: 'changeClientOption',
          data: this
        }
      );
    }
  }

  saveToStorage()
  {
    const opt = {
      showFPS: this._showFPS,
      showWCS: this._showWCS,
      cameraAnimation: this._cameraAnimation,
      antialiasing: this._antialiasing,
      groundShadow: this._groundShadow,
      shadows: this._shadows,
      cameraAxisXSpeed: this._cameraAxisXSpeed,
      cameraAxisYSpeed: this._cameraAxisYSpeed,
      ambientOcclusion: this._ambientOcclusion
    };
   
    localStorage.setItem('od-client-settings', JSON.stringify(opt));
  }

  loadFromStorage()
  {
    const jsonOpt = localStorage.getItem('od-client-settings');
    if (jsonOpt)
    {
      const opt = JSON.parse(jsonOpt);

      this._showFPS         = opt.showFPS;
      this._showWCS         = opt.showWCS;
      this._cameraAnimation = opt.cameraAnimation;
      this._antialiasing    = opt.antialiasing;
      this._groundShadow    = opt.groundShadow;
      this._shadows         = opt.shadows;
      this._cameraAxisXSpeed = opt.cameraAxisXSpeed || 4;
      this._cameraAxisYSpeed = opt.cameraAxisYSpeed || 1;
      this._ambientOcclusion = opt.ambientOcclusion || false;
    }
  }

  get showFPS() {
    return this._showFPS
  }

  set showFPS(value) {
    this._showFPS = value;
    this.notifierChangeEvent();
  }

  get showWCS() {
    return this._showWCS
  }

  set showWCS(value) {
    this._showWCS = value;
    this.notifierChangeEvent();
  }

  get cameraAnimation() {
    return this._cameraAnimation
  }

  set cameraAnimation(value) {
    this._cameraAnimation = value;
    this.notifierChangeEvent();
  }

  get antialiasing() {
    return this._antialiasing
  }

  set antialiasing(value) {
    this._antialiasing = value;
    this.notifierChangeEvent();
  }

  get groundShadow() {
    return this._groundShadow
  }

  set groundShadow(value) {
    this._groundShadow = value;
    this.notifierChangeEvent();
  }

  get shadows() {
    return this._shadows
  }

  set shadows(value) {
    this._shadows = value;
    this.notifierChangeEvent();
  }
  
  set cameraAxisXSpeed(value) {
    this._cameraAxisXSpeed = value;
    this.notifierChangeEvent();
  }

  get cameraAxisXSpeed() {
    return this._cameraAxisXSpeed
  }

  set cameraAxisYSpeed(value) {
    this._cameraAxisYSpeed = value;
    this.notifierChangeEvent();
  }

  get cameraAxisYSpeed() {
    return this._cameraAxisYSpeed 
  }

  get ambientOcclusion() {
    return this._ambientOcclusion
  }

  set ambientOcclusion(value) {
    this._ambientOcclusion = value;
    this.notifierChangeEvent();
  }
}///////////////////////////////////////////////////////////////////////////////

/**
 * Common api
 * @class
 */
class Client {
  constructor(options) {
    this._url = options.serverUrl;
    this.user = null;
    this.eventEmitter = new EventEmitter();
    this.jobUpdater = null;
    this._options = new Options(this.eventEmitter);
  }

  /**
   * Url api
   * @type {string}
   */
  get url() { return this._url }

  /**
   * Options
   * @type {Options}
   */
  get options() { return this._options }

  /**
   * Create Viewer options
   * @typedef {Object} ViewerOptions
   * @property {HTMLCanvasElement} target
   * @property {String} [visualizeJsUrl]
   * @property {VisualizeJSProgressCallback} [onprogress = null]
   */

  /**
   * Create instance of Viewer
   * @param {ViewerOptions} options 
   * @returns {Viewer}
   */
  createViewer(options) {
    const viewer = new Viewer(this);
    if(options.visualizeJsUrl) {
      viewer.configure({ visualizeJsUrl: options.visualizeJsUrl });
    }
    return viewer.initializeAsync(
      options.target,
      options.onprogress
    )
  }

  /**
   * Api Options
   * @typedef {Object} ClientOptions
   * @property {string} url - url to Open Cloud
   */

  /**
   * Configure Client
   * @param {ClientOptions}
   * @returns {Api}
   */
  configure(options) {
    this._url = options.url;
    return this
  }


  /**
   * Client initialize Callback
   *
   * @callback InitializeCallback
   * @param {ClientEvent} event - Api event
   */

  /**
   * Subscribe Client Events
   * @param {string} name 
   * @param {InitializeCallback} callback 
   */
  on(name, callback) {
    this.eventEmitter.on(name, callback);
  }

  /**
   * Unsubscribe Client Events
   * @param {string} name 
   * @param {InitializeCallback} callback 
   */
  removeEventListener(name, callback) {
    this.eventEmitter.remove(name, callback);
  }

  /**
   * Remove all api events
   */
  removeAllListeners() {
    this.eventEmitter.clear();
  }

  /**
   * Client Options
   * @typedef {Object} ClientEvent
   * @property {string} type - url to visualizeJS
   * @property {*} data - data event
   */

  emit(event) {
    this.eventEmitter.emit(event);
  }

  /**
   * @typedef FileListResult
   * @type {object}
   * @property {number} allSize
   * @property {number} limit
   * @property {File[]} list
   * @property {number} size
   * @property {number} start
   */

  /**
   * Get file list
   * @async
   * @param {number} start 
   * @param {number} count 
   * @param {string} name 
   * @param {string} ext 
   * @param {Array<string>} ids
   * @param {string} sortByDesc
   * @returns {FileListResult}
   */
  async getFileList(start, count, name, ext, ids, sortByDesc) {
    const { allSize, limit, result, size } = await this.user.getFiles(start, count, name, ext, ids, sortByDesc);
    return {
      allSize,
      limit,
      list: result.map(fileImpl => new File(fileImpl, this)),
      size,
      start
    };
  }


  /**
   * Get file by Id
   * @async
   * @param {string} fileId 
   * @returns {File}
   */
  async getFile(fileId) {
    return new File(await this.user.getFile(fileId), this)
  }

  /**
   * @typedef Version
   * @type {object}
   * @property {string} version
   * @property {string} hash
   */

  /**
   * Get version
   * @async
   * @returns {Version}
   */
  version() {
    return json($get(`${this._url}/version`, { 'Access-Control-Allow-Origin': '*' }))
  }


  /**
   * Login
   * @async
   * @param {string} email 
   * @param {string} password 
   * @returns {User}
   */
  async signInWithEmail(email, password) {
    const token = email + ':' + password;
    const hash = btoa(token);

    const userData = await json($get(`${this._url}/token`, {
      'Authorization': 'Basic ' + hash,
      'Access-Control-Allow-Origin': '*'
    }));

    this.user = new UserImpl(userData, this._url, this._options);
    //this.setActiveJobUpdater(true)

    return new User(this.user, this)
  }


  /**
   * Setting to enable | disable job updater
   * It recursively updates jobs periodically
   * @param {boolean} enable
   */
  setActiveJobUpdater(enable) {
    this.jobUpdater && this.jobUpdater.stop();
    this.jobUpdater = new JobUpdater(this.user, this);
    enable && this.jobUpdater.start();
  }


  /**
   * Get current user
   * @returns {User}
   */
  getCurrentUser() {
    return new User(this.user, this)
  }

  async loginWithToken(token) {
    return new UserImpl({
      tokenInfo: {
        token: token
      }
    }, this._url, this._options)
      .getUserInfo()
      .then(userData => new UserImpl(userData, this._url, this._options))
      .then(user => this.user = user)
      .then(() => this)
  }
  // /**
  //  * Login with raw user data
  //  * @async
  //  * @param {Object} userData 
  //  * @returns {User}
  //  */  
  // async loginFromUserData(userData) {
  //   //this.setActiveJobUpdater(true)
  //   this.user = new UserImpl(userData, this._url)
  //   return new User(this.user, this)
  // }

  /**
   * @typedef UploadFileOptions
   * @type {object}
   * @property {boolean} geometry - create job to generate geometry, default = true
   * @property {boolean} properties - create job to generate properties, default = true
   * @property {boolean} waitForDone - wait for complete geometry | properties jobs, default = false
   */

  /**
   * Upload file
   * @async
   * @param {global.File} file 
   * @param {UploadFileOptions} options
   * @returns {File}
   */
  async uploadFile(file, options = { geometry: true, properties: false, waitForDone: false }) {

    const fileImpl = await this.user.postFile(file, progress => this.emit({ type: "upload-progress", data: progress }));
    const awaiters = [];

    options.geometry && awaiters.push(fileImpl.createJob("geometry"));
    options.properties && awaiters.push(fileImpl.createJob("properties"));

    const jobs = await Promise.all(awaiters);
    if (options.waitForDone) {
      await Promise.all(jobs.map(job => job.waitForDone()));
    }
    return new File(fileImpl, this);
  }

  /**
   * Delete file
   * @async
   * @param {string} fileId - file Id
   * @returns {Object} - result
   */
  deleteFile(fileId) {
    return this.user.deleteFile(fileId)
  }

  /**
   * Download file reference
   * @async
   * @param {string} fileId - file Id
   * @param {string} onProgress - onprogress callback
   * @param {AbortSignal} signal - signal for cancellation
   * @returns {ArrayBuffer} - binary data
   */
  downloadReferenceFile(fileId, onProgress, signal) {
    return this.user.downloadReferenceFile(fileId, onProgress, signal)
  }


  /**
   * @typedef JobsResult
   * @type {object}
   * @property {Job[]} result - Array of jobs
   * @property {Number} start - create job to generate geometry, default = true
   * @property {Number} limit - create job to generate properties, default = true
   * @property {Number} allSize - wait for complete geometry | properties jobs, default = false
   * @property {Number} size - wait for complete geometry | properties jobs, default = false
   */

  /**
   * Get lob list with specified filter
   * @async
   * @param {string} state - filter, default = null
   * @param {Number} limit - limit for response, default = null
   * @param {Number} start - offset of response, default = null
   * @param {Number} sortByDesc - sort by desc createdAt, default = null
   * @returns {JobsResult} - JobsResult
   */
  getJobs(state = null, limit = null, start = null, sortByDesc = null) {
    return this.user.getJobs(state, limit, start, sortByDesc)
      .then(data => ({ ...data, result: data.result.map(job => new Job(job, this)) }))
  }

  /**
   * Get job by id
   * @async
   * @param {string} jobId - jobId
   * @returns {Job} - Job
   */
  getJob(jobId) {
    return this.user.getJob(jobId).then(job => new Job(job, this))
  }

  /**
   * Create Job for file
   * @async
   * @param {string} fileId - File id
   * @param {string} outputFormat - Output format
   * @returns {Job} - Job
   */
  createJob(fileId, outputFormat) {
    return this.user.postJob(fileId, outputFormat).then(job => new Job(job, this))
  }


  /**
   * Delete job
   * @async
   * @param {string} jobId - Job Id
   * @returns {Object} - Result
   */
  deleteJob(jobId) {
    return this.user.deleteJob(jobId)
  }

  /**
   * Get projects 
   * @async
   * @returns {Array<Project>}
   */
  getProjects() {
    return this.user.getProjects().then(projectsImpl => projectsImpl.map(impl => new Project(impl, this)))
  }

  /**
   * Create new projects
   * @async
   * @param {string} name - project name
   * @param {string} description - project description
   * @param {Date} startDate - start project date
   * @param {Date} endDate - end project date
   * @param {string} avatarUrl - base64 image project preview
   * @returns {Project}
   */
  createProject(name, description, startDate, endDate, avatarUrl) {
    return this.user.createProject(name, description, startDate, endDate, avatarUrl).then(impl => new Project(impl, this))
  }

  /**
   * Get project by id 
   * @async
   * @param {string} id - project id
   * @returns {Project}
   */
  getProjectById(id) {
    return this.user.getProjectById(id).then(impl => new Project(impl, this))
  }

  /**
   * Create new assembly
   * @async
   * @param {Array<string>} files - list file ids
   * @param {string} name - assembly name
   * @returns {Assembly}
   */
  createAssembly(files, name) {
    return this.user.createAssembly(files, name).then(impl => new Assembly(impl))
  }

  /**
   * Get assembly by id
   * @async
   * @param {string} id - assembly id
   * @returns {Assembly}
   */
  getAssemblyById(id) {
    return this.user.getAssemblyById(id).then(impl => new Assembly(impl))
  }

  /**
   * @typedef AssemblyListResult
   * @type {object}
   * @property {number} allSize
   * @property {number} limit
   * @property {Assembly[]} result
   * @property {number} size
   * @property {number} start
   */

  /**
   * Get file list
   * @async
   * @param {number} start 
   * @param {number} count 
   * @param {string} name 
   * @param {Array<string>} ids
   * @param {string} sortByDesc 
   * @returns {AssemblyListResult}
   */
  async getAssemblies(start, count, name, ids, sortByDesc) {
    const { allSize, limit, result, size } = await this.user.getAssemblies(start, count, name, ids, sortByDesc);
    return {
      allSize,
      limit,
      list: result.map(impl => new Assembly(impl, this)),
      size,
      start
    };
  }

  /**
   * Delete job
   * @async
   * @param {string} id - assembly Id
   * @returns {Object} - Result
   */
  deleteAssembly(id) {
    return this.user.deleteAssembly(id)
  }
}

class EventEmitter {
  constructor() {
    this.subscribers = {};
  }


  clear() { this.subscribers = {}; }

  emit(event) {
    if (this.subscribers[event.type]) {
      const invoke = [...this.subscribers[event.type]];
      this.subscribers[event.type] = this.subscribers[event.type].filter(subscriber => !subscriber.once);
      invoke.forEach(subscriber => subscriber.callback(event));
    }
  }

  on(type, callback) {
    !this.subscribers[type] && (this.subscribers[type] = []);
    this.subscribers[type].push({ type, callback });
  }

  once(type, callback) {
    !this.subscribers[type] && (this.subscribers[type] = []);
    this.onces.push({ type, callback, once: true });
  }

  remove(type, callback) {
    if (this.subscribers[type]) {
      this.subscribers[type] = this.subscribers[type].filter(subscriber => subscriber.type !== type && subscriber.callback !== callback);
    }
  }
}/** 
 * @namespace 
 * @global
 * */
const ODA = {

  /**
   * Create client instance, 
   * @function
   * @async
   * @returns {Client}
   */
  createClient: async (options) => {
    const client = new Client(options);
    if (options.APIToken) {
      await client.loginWithToken(options.APIToken);
    }
    return client
  },
};return ODA;})));//# sourceMappingURL=client.js.map
