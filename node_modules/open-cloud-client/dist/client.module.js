function json(request) {
    return request.then((response => response.json()));
}

function text(request) {
    return request.then((response => response.text()));
}

function arrayBuffer(request) {
    return request.then((response => response.arrayBuffer()));
}

function options(method, headers, body, signal) {
    const opt = {
        method: method,
        headers: headers,
        body: body
    };
    signal && (opt.signal = signal);
    return opt;
}

function catchHttpError(status) {
    return status > 400 ? Promise.reject(status) : Promise.resolve();
}

function catchHttFetchError(request) {
    return request.then((response => catchHttpError(response.status).then((() => request), (() => response.json().then((json => Promise.reject(new Error(json.description))))))));
}

function $get(url, headers, signal) {
    return catchHttFetchError(fetch(url, options("GET", headers, null, signal)));
}

function $put(url, headers, body) {
    if (typeof body === "object") {
        if (body instanceof FormData) ; else if (!(body instanceof ArrayBuffer) && !(body instanceof Blob)) {
            body = JSON.stringify(body);
            headers = {
                ...headers,
                "Content-Type": "application/json"
            };
        }
    } else {
        headers = {
            ...headers,
            "Content-Type": "application/json"
        };
    }
    headers = {
        ...headers,
        "Access-Control-Allow-Origin": "*",
        pragma: "no-cache",
        "cache-control": "no-cache"
    };
    return catchHttFetchError(fetch(url, options("PUT", headers, body)));
}

function $post(url, headers, body) {
    if (typeof body === "object") {
        if (body instanceof FormData) ; else if (!(body instanceof ArrayBuffer) && !(body instanceof Blob)) {
            body = JSON.stringify(body);
            headers = {
                ...headers,
                "Content-Type": "application/json"
            };
        }
    } else {
        headers = {
            ...headers,
            "Content-Type": "application/json"
        };
    }
    headers = {
        ...headers,
        "Access-Control-Allow-Origin": "*",
        pragma: "no-cache",
        "cache-control": "no-cache"
    };
    return catchHttFetchError(fetch(url, options("POST", headers, body)));
}

function $delete(url, headers, body) {
    return catchHttFetchError(fetch(url, options("DELETE", headers, body)));
}

function streamProgress(stream, onprogress) {
    const reader = stream.getReader();
    let current = 0;
    reader.read().then(calc).catch(console.error);
    function calc(ev) {
        if (!ev.done) {
            reader.read().then(calc).catch(console.error);
        }
        ev.value && (current += ev.value.length);
        onprogress(current);
    }
    return stream;
}

function downloadProgress(response, onprogress) {
    const total = response.headers.get("Content-Length");
    const tee = response.body.tee();
    streamProgress(tee[0], (bytesCount => onprogress && onprogress(bytesCount / total)));
    return new Response(tee[1]);
}

function $XMLHttp(url, {headers: headers, method: method, body: body, uploadProgress: uploadProgress, downloadProgress: downloadProgress}) {
    function getDescription(text) {
        try {
            return JSON.parse(text).description;
        } catch {
            return text;
        }
    }
    return new Promise(((resolve, reject) => {
        const req = new XMLHttpRequest;
        req.open(method, url, true);
        for (var key in headers) {
            req.setRequestHeader(key, headers[key]);
        }
        function calcProgress(ev) {
            return ev.lengthComputable ? ev.loaded / ev.total : 1;
        }
        req.upload.onprogress = ev => uploadProgress && uploadProgress(calcProgress(ev));
        req.onprogress = ev => downloadProgress && downloadProgress(calcProgress(ev));
        req.onloadend = ev => catchHttpError(req.status).then((() => resolve(req)), (() => reject(new Error(getDescription(ev.target.responseText)))));
        req.onerror = ev => reject(ev);
        req.send(body);
    }));
}

function waitFor(func, options = {
    timeout: 6e5,
    interval: 3e3
}) {
    return new Promise(((resolve, reject) => {
        let elapsed = 0;
        const id = setInterval((() => {
            if (func()) {
                clearInterval(id);
                resolve();
            }
            elapsed += options.interval;
            if (elapsed >= options.timeout) {
                reject();
                clearInterval(id);
            }
        }), options.interval);
    }));
}

function normalizePath(path) {
    return path.replace(/^\/*/, "/");
}

class MarkupImpl {
    constructor(data, file) {
        this.data = data;
        this.file = file;
    }
    get id() {
        return this.data.id;
    }
    get(relativePath, signal) {
        const path = normalizePath(relativePath);
        return this.file.get(`/markup/${this.id}${path}`, signal);
    }
    post(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.file.post(`/markup/${this.id}${path}`, body);
    }
    put(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.file.put(`/markup/${this.id}${path}`, body);
    }
    delete(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.file.delete(`/markup/${this.id}${path}`, body);
    }
    saveMarkup() {
        return json(this.post(`/`, this.data));
    }
    getMarkup() {
        return json(this.get(`/`));
    }
    deleteMarkup() {
        return json(this.delete(`/`));
    }
}

class ModelImpl {
    constructor(data, file) {
        this.data = data;
        this.file = file;
    }
    get id() {
        return this.data.id;
    }
    get(relativePath, signal) {
        const path = normalizePath(relativePath);
        return this.file.get(`/${path}`, signal);
    }
    post(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.file.post(`/${path}`, body);
    }
    put(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.file.put(`/${path}`, body);
    }
    delete(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.user.delete(`/${path}`, body);
    }
    downloadResource(dataId, onProgress, signal) {
        return this.file.downloadResource(dataId, onProgress, signal);
    }
    partialDownloadResource(dataId, signal, onProgress) {
        return this.file.partialDownloadResource(dataId, signal, onProgress);
    }
    getReferences() {
        return this.file.getReferences();
    }
    getViewPoints() {
        if (!this.file.getViewPoints) {
            throw new Error("Assembly not support viewpoint");
        }
        return this.file.getViewPoints().then((data => data.filter((viewpoint => viewpoint.custom_fields.modelId === this.id))));
    }
    postViewpoint(data) {
        if (!this.file.postViewpoint) {
            throw new Error("Assembly not support viewpoint");
        }
        return this.file.postViewpoint({
            ...data,
            custom_fields: {
                modelId: this.id
            }
        });
    }
    getViewpoint(guid) {
        if (!this.file.getViewpoint) {
            throw new Error("Assembly not support viewpoint");
        }
        return this.file.getViewpoint(guid);
    }
    deleteViewpoint(guid) {
        if (!this.file.deleteViewpoint) {
            throw new Error("Assembly not support viewpoint");
        }
        return this.file.deleteViewpoint(guid);
    }
    getSnapshot(guid) {
        if (!this.file.getSnapshot) {
            throw new Error("Assembly not support viewpoint");
        }
        return this.file.getSnapshot(guid);
    }
    getSnapshotData(guid, bitmapGuid) {
        if (!this.file.getSnapshotData) {
            throw new Error("Assembly not support viewpoint");
        }
        return this.file.getSnapshot(guid, bitmapGuid);
    }
}

class FileImpl {
    constructor(fileInfo, user) {
        this.fileInfo = fileInfo;
        this.user = user;
    }
    get id() {
        return this.fileInfo.id;
    }
    get(relativePath, signal) {
        const path = normalizePath(relativePath);
        return this.user.get(`/files/${this.id}${path}`, signal);
    }
    post(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.user.post(`/files/${this.id}${path}`, body);
    }
    put(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.user.put(`/files/${this.id}${path}`, body);
    }
    delete(relativePath, body) {
        const path = normalizePath(relativePath);
        return this.user.delete(`/files/${this.id}${path}`, body);
    }
    getProperties() {
        return json(this.get(`/properties`));
    }
    getProperty(id) {
        return json(this.get(`/properties?handle=${id}`));
    }
    getModels() {
        return json(this.get(`/geometry`)).then((models => models.map((data => new ModelImpl(data, this)))));
    }
    postMetadata(metadata) {
        return json(this.post(`/geometry`, metadata));
    }
    postFileDownloads(file, onProgress) {
        const data = new FormData;
        data.append("file", file);
        return json(this.post(`/downloads`, data));
    }
    downloadFile() {
        return arrayBuffer(this.get(`/downloads`));
    }
    downloadResource(dataId, onProgress, signal) {
        return this.get(`/downloads/${dataId}`, signal).then((response => downloadProgress(response, onProgress))).then((response => response.arrayBuffer()));
    }
    async partialDownloadResource(dataId, signal, onProgress) {
        const path = normalizePath(`/files/${this.id}/downloads/${dataId}`);
        const response = await fetch(`${this.user.url}${path}`, {
            headers: this.user.headers,
            signal: signal
        });
        const contentLength = response.headers.get("content-length");
        const total = parseInt(contentLength, 10);
        let loaded = 0;
        const reader = response.body.getReader();
        let condition = true;
        while (condition) {
            const {done: done, value: value} = await reader.read();
            if (done) {
                break;
            }
            loaded += value.byteLength;
            onProgress(loaded / total, value);
        }
    }
    getFileInfo() {
        return json(this.get(`/`));
    }
    putFile(fileInfo) {
        return json(this.put(`/`, fileInfo));
    }
    deleteFile() {
        return this.user.deleteFile(this.id);
    }
    getMarkupList() {
        return json(this.get(`/markup`)).then((list => list.result.map((data => new MarkupImpl(data, this)))));
    }
    postMarkup(markup) {
        return json(this.post(`/markup/`, markup));
    }
    deleteMarkup(markupId) {
        return json(this.delete(`/markup/${markupId}`));
    }
    getMarkup(markupId) {
        return json(this.get(`/markup/${markupId}`));
    }
    createJob(outputFormat) {
        return this.user.postJob(this.id, outputFormat);
    }
    getReferences() {
        return json(this.get(`/references`));
    }
    putReferences(object) {
        return json(this.put(`/references`, object));
    }
    downloadReferenceFile(onProgress, signal) {
        return arrayBuffer(this.user.downloadReferenceFile(this.id, onProgress, signal));
    }
    getViewPoints() {
        return json(this.get(`/viewpoints`)).then((list => list.result));
    }
    postViewpoint(data) {
        return json(this.post(`/viewpoints`, data));
    }
    getViewpoint(guid) {
        return json(this.get(`/viewpoints/${guid}`));
    }
    deleteViewpoint(guid) {
        return json(this.delete(`/viewpoints/${guid}`));
    }
    getSnapshot(guid) {
        return text(this.get(`/viewpoints/${guid}/snapshot`));
    }
    getSnapshotData(guid, bitmapGuid) {
        return text(this.get(`/viewpoints/${guid}/bitmaps/${bitmapGuid}`));
    }
}

class JobImpl {
    constructor(data, user) {
        this.data = data;
        this.user = user;
    }
    get id() {
        return this.data.id;
    }
    get done() {
        return this.data.state === "done";
    }
    get state() {
        return this.data.state;
    }
    get fileId() {
        return this.data.fileId;
    }
    get assemblyId() {
        return this.data.assemblyId;
    }
    get createdAt() {
        return this.data.createdAt;
    }
    get startedAt() {
        return this.data.startedAt;
    }
    get lastUpdate() {
        return this.data.lastUpdate;
    }
    get outputFormat() {
        return this.data.outputFormat;
    }
    refresh() {
        return this.user.getJob(this.id).then((data => this.data = data)).then((() => this));
    }
    editJob(data) {
        return this.user.editJob(this.id, data).then((data => this.data = data)).then((() => this));
    }
    delete() {
        return this.user.deleteJob(this.id);
    }
    waitForDone() {
        return waitFor((() => this.refresh() && this.done));
    }
}

class ProjectImpl {
    constructor(data, user) {
        this._data = data;
        this._user = user;
    }
    delete() {
        const {id: id} = this._data;
        return this._user.delete(`/projects/${id}`);
    }
    save() {
        const {id: id} = this._data;
        return json(this._user.put(`/projects/${id}`, this._data));
    }
}

class AssemblyImpl {
    constructor(assemblyData, user) {
        this._data = assemblyData;
        this._user = user;
    }
    _get(relativePath, signal) {
        const path = normalizePath(relativePath || "");
        return this._user.get(`/assemblies/${this._data.id}${path}`, signal);
    }
    _post(relativePath, body) {
        const path = normalizePath(relativePath || "");
        return this._user.post(`/assemblies/${this._data.id}${path}`, body);
    }
    _put(relativePath, body) {
        const path = normalizePath(relativePath || "");
        return this._user.put(`/assemblies/${this._data.id}${path}`, body);
    }
    _delete(relativePath, body) {
        const path = normalizePath(relativePath || "");
        return this._user.delete(`/assemblies/${this._data.id}${path}`, body);
    }
    getProperties() {
        return json(this._get(`/properties`));
    }
    getProperty(id) {
        return json(this._get(`/properties?handle=${id}`));
    }
    getModels() {
        return json(this._get(`/geometry`)).then((models => models.map((data => new ModelImpl(data, this)))));
    }
    downloadResource(dataId, onProgress, signal) {
        return this._get(`/downloads/${dataId}`, signal).then((response => downloadProgress(response, onProgress))).then((response => response.arrayBuffer()));
    }
    async partialDownloadResource(dataId, signal, onProgress) {
        const path = normalizePath(`/assemblies/${this._data.id}/downloads/${dataId}`);
        const response = await fetch(`${this._user.url}${path}`, {
            headers: this._user.headers,
            signal: signal
        });
        const contentLength = response.headers.get("content-length");
        const total = parseInt(contentLength, 10);
        let loaded = 0;
        const reader = response.body.getReader();
        let condition = true;
        while (condition) {
            const {done: done, value: value} = await reader.read();
            if (done) {
                break;
            }
            loaded += value.byteLength;
            onProgress(loaded / total, value);
        }
    }
    delete() {
        return this._delete();
    }
    save() {
        return this._put("", this._data);
    }
}

class UserImpl {
    constructor(data, url, opt) {
        this.data = data;
        this.url = url;
        this.headers = {
            Authorization: data.tokenInfo.token
        };
        this.opt = opt;
        if (!this.opt) {
            throw new Error("opt can not be undefined");
        }
    }
    get(relativePath, signal) {
        const path = normalizePath(relativePath);
        return $get(`${this.url}${path}`, this.headers, signal);
    }
    post(relativePath, body) {
        const path = normalizePath(relativePath);
        return $post(`${this.url}${path}`, this.headers, body);
    }
    put(relativePath, body) {
        const path = normalizePath(relativePath);
        return $put(`${this.url}${path}`, this.headers, body);
    }
    delete(relativePath, body) {
        const path = normalizePath(relativePath);
        return $delete(`${this.url}${path}`, this.headers, body);
    }
    getUsers() {
        return json(this.get(`/users`));
    }
    getUserInfo() {
        return json(this.get(`/user`));
    }
    putUserInfo(userInfo) {
        return json(this.put(`/user`, userInfo));
    }
    save() {
        return this.putUserInfo(this.data);
    }
    getFile(fileId) {
        return json(this.get(`/files/${fileId}`)).then((data => new FileImpl(data, this)));
    }
    getFiles(start, limit, name, ext, ids, sortByDesc) {
        const query = [];
        if (start !== undefined) {
            query.push("start=" + start);
        }
        if (limit !== undefined) {
            query.push("limit=" + limit);
        }
        if (name) {
            query.push("name=" + name);
        }
        if (ext) {
            query.push("ext=" + ext.toLowerCase());
        }
        if (ids) {
            query.push("id=" + ids.join("|"));
        }
        if (sortByDesc) {
            query.push("sortBy=desc");
        }
        const queryStr = query.length !== 0 ? "?" + query.join("&") : "";
        return json(this.get(`/files${queryStr}`)).then((list => ({
            ...list,
            result: list.result.map((fileInfo => new FileImpl(fileInfo, this)))
        })));
    }
    postFile(file, onProgress) {
        const data = new FormData;
        data.append("file", file);
        return $XMLHttp(`${this.url}/files/`, {
            method: "POST",
            headers: this.headers,
            body: data,
            uploadProgress: onProgress
        }).then((request => JSON.parse(request.responseText))).then((data => new FileImpl(data, this)));
    }
    deleteFile(fileId, body) {
        return json(this.delete(`/files/${fileId}`, body));
    }
    getJobs(state = null, limit = null, start = null, sortByDesc = null) {
        const params = [ state ? `${"state"}=${state}` : "", limit ? `${"limit"}=${limit}` : "", start ? `${"start"}=${start}` : "", sortByDesc ? `${"sortBy"}=desc` : "" ].filter((p => p));
        const query = params.length ? `?${params.join("&")}` : "";
        return json(this.get(`/jobs${query}`)).then((list => ({
            ...list,
            result: list.result.map((data => new JobImpl(data, this)))
        })));
    }
    postJob(fileId, outputFormat) {
        const parameters = this.opt.useVSFX ? {
            useVSFX: ""
        } : {};
        return json(this.post(`/jobs`, {
            fileId: fileId,
            outputFormat: outputFormat,
            parameters: parameters
        })).then((data => new JobImpl(data, this)));
    }
    getJob(jobId) {
        return json(this.get(`/jobs/${jobId}`)).then((data => new JobImpl(data, this)));
    }
    deleteJob(jobId) {
        return json(this.delete(`/jobs/${jobId}`));
    }
    editJob(data) {
        return json(this.put(`/jobs/${this.id}`, data)).then((data => new JobImpl(data, this)));
    }
    downloadReferenceFile(fileId, onProgress, signal) {
        return this.get(`/files/${fileId}/downloads`, signal).then((response => downloadProgress(response, onProgress))).then((response => response.arrayBuffer()));
    }
    getProjects() {
        return json(this.get(`/projects`)).then((projectsData => projectsData.map((data => new ProjectImpl(data, this)))));
    }
    createProject(name, description, startDate, endDate, avatarUrl) {
        return json(this.post(`/projects`, {
            name: name,
            description: description,
            startDate: startDate.toISOString(),
            endDate: endDate.toISOString(),
            avatarUrl: avatarUrl
        })).then((data => new ProjectImpl(data, this)));
    }
    getProjectById(id) {
        return json(this.get(`/projects/${id}`)).then((data => new ProjectImpl(data, this)));
    }
    createAssembly(files, name) {
        return json(this.post(`/assemblies`, {
            name: name,
            files: files
        })).then((data => new AssemblyImpl(data, this)));
    }
    getAssemblyById(id) {
        return json(this.get(`/assemblies/${id}`)).then((data => new AssemblyImpl(data, this)));
    }
    getAssemblies(start, limit, name, ids, sortByDesc) {
        const query = [];
        if (start !== undefined) {
            query.push("start=" + start);
        }
        if (limit !== undefined) {
            query.push("limit=" + limit);
        }
        if (name) {
            query.push("name=" + name);
        }
        if (ids) {
            query.push("id=" + ids.join("|"));
        }
        if (sortByDesc) {
            query.push("sortBy=desc");
        }
        const queryStr = query.length !== 0 ? "?" + query.join("&") : "";
        return json(this.get(`/assemblies${queryStr}`)).then((assemblies => ({
            ...assemblies,
            result: assemblies.result.map((data => new AssemblyImpl(data, this)))
        })));
    }
    deleteAssembly(id) {
        return json(this.delete(`/assemblies/${id}`));
    }
}

class Model {
    constructor(impl, file, assembly) {
        this._impl = impl;
        this._file = file;
        this._assembly = assembly;
    }
    get file() {
        return this._file;
    }
    get assembly() {
        return this._assembly;
    }
    get default() {
        return this._impl.data.default;
    }
    get database() {
        return this._impl.data.database;
    }
    get fileId() {
        return this._impl.data.fileId;
    }
    get geometry() {
        return this._impl.data.geometry;
    }
    get id() {
        return this._impl.data.id;
    }
    get name() {
        return this._impl.data.name;
    }
    get version() {
        return this._impl.data.version;
    }
    getViewpoints() {
        return this._impl.getViewPoints();
    }
    saveViewpoint(viewpointData) {
        return this._impl.postViewpoint(viewpointData);
    }
    deleteViewpoint(viewpointId) {
        return this._impl.deleteViewpoint(viewpointId);
    }
    getSnapshot(guid) {
        return this._impl.getSnapshot(guid);
    }
    getSnapshotData(guid, bitmapGuid) {
        return this._impl.getSnapshotData(guid, bitmapGuid);
    }
    downloadResource(dataId, onProgress, signal) {
        return this._impl.downloadResource(dataId, onProgress, signal);
    }
    partialDownloadResource(dataId, signal, onProgress) {
        return this._impl.partialDownloadResource(dataId, signal, onProgress);
    }
    getReferences() {
        return this._impl.getReferences();
    }
}

class Project {
    constructor(impl, app) {
        this._impl = impl;
        this.app = app;
    }
    get id() {
        return this._impl._data.id;
    }
    get name() {
        return this._impl._data.name;
    }
    set name(value) {
        this._impl._data.name = value;
    }
    get authorization() {
        return this._impl._data.authorization;
    }
    get createdAt() {
        return this._impl._data.createdAt;
    }
    get updatedAt() {
        return this._impl._data.updatedAt;
    }
    get startDate() {
        return this._impl._data.startDate;
    }
    set startDate(value) {
        this._impl._data.startDate = value.toISOString();
    }
    get endDate() {
        return this._impl._data.endDate;
    }
    set endDate(value) {
        this._impl._data.endDate = value.toISOString();
    }
    get description() {
        return this._impl._data.description;
    }
    set description(value) {
        this._impl._data.description = value;
    }
    get avatarUrl() {
        return this._impl._data.avatarUrl;
    }
    set avatarUrl(value) {
        this._impl._data.avatarUrl = value;
    }
    get customFields() {
        return this._impl._data.customFields;
    }
    set customFields(value) {
        this._impl._data.customFields = value;
    }
    get public() {
        return this._impl._data.public;
    }
    set public(value) {
        this._impl._data.public = value;
    }
    save() {
        return this._impl.save();
    }
    delete() {
        return this._impl.delete();
    }
}

class User {
    constructor(impl, plugin) {
        this._impl = impl;
        this._plugin = plugin;
    }
    get data() {
        return this._impl.data;
    }
    get avatarImage() {
        return this._impl.data.avatarImage;
    }
    set avatarImage(v) {
        this._impl.data.avatarImage = v;
        this._impl.save();
    }
    get canCreateProject() {
        return this._impl.data.canCreateProject;
    }
    get createAt() {
        return this._impl.data.createAt;
    }
    get customFields() {
        return this._impl.data.customFields;
    }
    get email() {
        return this._impl.data.email;
    }
    get firstName() {
        return this._impl.data.firstName;
    }
    set firstName(v) {
        this._impl.data.firstName = v;
        this._impl.save();
    }
    get lastModified() {
        return this._impl.data.lastModified;
    }
    get lastName() {
        return this._impl.data.lastName;
    }
    set lastName(v) {
        this._impl.data.lastName = v;
        this._impl.save();
    }
    get lastSignIn() {
        return this._impl.data.lastSignIn;
    }
    get projectsLimit() {
        return this._impl.data.projectsLimit;
    }
    get userName() {
        return this._impl.data.userName;
    }
    set userName(v) {
        this._impl.data.userName = v;
        this._impl.save();
    }
    getUsers() {
        return this._impl.getUsers();
    }
}

class Job {
    constructor(impl, app) {
        this._impl = impl;
        this._app = app;
    }
    get user() {
        return new User(this.impl.user, this._app);
    }
    get id() {
        return this._impl.id;
    }
    get done() {
        return this._impl.done;
    }
    get state() {
        return this._impl.state;
    }
    get fileId() {
        return this._impl.fileId;
    }
    get assemblyId() {
        return this._impl.assemblyId;
    }
    get createdAt() {
        return this._impl.createdAt;
    }
    get startedAt() {
        return this._impl.startedAt;
    }
    get lastUpdate() {
        return this._impl.lastUpdate;
    }
    refresh() {
        return this._impl.refresh();
    }
    editJob(data) {
        return this._impl.editJob(data);
    }
    delete() {
        return this._impl.delete();
    }
}

class File {
    constructor(impl, app) {
        this._impl = impl;
        this.app = app;
    }
    get user() {
        return new User(this._impl.user, this.app);
    }
    get created() {
        return this._impl.fileInfo.created;
    }
    get exports() {
        return this._impl.fileInfo.exports;
    }
    get id() {
        return this._impl.fileInfo.id;
    }
    get metadata() {
        return this._impl.fileInfo.metadata;
    }
    get owner() {
        return this._impl.fileInfo.owner;
    }
    get preview() {
        return this._impl.fileInfo.preview;
    }
    set preview(base64) {
        this._impl.fileInfo.preview = base64;
    }
    get properties() {
        return this._impl.fileInfo.properties;
    }
    get size() {
        return this._impl.fileInfo.size;
    }
    get type() {
        return this._impl.fileInfo.type;
    }
    get version() {
        return this._impl.fileInfo.version;
    }
    get name() {
        return this._impl.fileInfo.name;
    }
    set name(newName) {
        this._impl.fileInfo.name = newName;
    }
    get geometryStatus() {
        return this._impl.fileInfo.geometryStatus;
    }
    get propertiesStatus() {
        return this._impl.fileInfo.propertiesStatus;
    }
    getModels() {
        return this._impl.getModels().then((models => models.map((modelImpl => new Model(modelImpl, this)))));
    }
    getProperty(id) {
        return this._impl.getProperty(id);
    }
    getProperties() {
        return this._impl.getProperties();
    }
    getViewPoints() {
        return this._impl.getViewPoints();
    }
    delete() {
        return this._impl.deleteFile();
    }
    downloadResource(dataId, onProgress, signal) {
        return this._impl.downloadResource(dataId, onProgress, signal);
    }
    save() {
        return this._impl.putFile(this._impl.fileInfo);
    }
    checkout() {
        return this._impl.getFileInfo().then((info => this._impl.fileInfo = info)).then((() => this));
    }
    createReferences(object) {
        return this.putReferences(object);
    }
    getReferences() {
        return this._impl.getReferences();
    }
    putReferences(object) {
        return this._impl.putReferences(object);
    }
    extractGeometry() {
        return this._impl.createJob("geometry").then((jobImpl => new Job(jobImpl, this.app)));
    }
    extractProperties() {
        return this._impl.createJob("properties").then((jobImpl => new Job(jobImpl, this.app)));
    }
}

class JobUpdater {
    constructor(userImpl, plugin) {
        this._userImpl = userImpl;
        this._plugin = plugin;
        this._intervalId = 0;
        this.interval = 5e3;
        this.jobs = [];
    }
    start() {
        this._intervalId = setInterval((() => {
            this.update();
        }), this.interval);
    }
    async update() {
        function completed(one, two) {
            return one.filter((job1 => !two.find((job2 => job1.id === job2.id))));
        }
        const jobs = [ ...(await this._userImpl.getJobs("running")).result, ...(await this._userImpl.getJobs("waiting")).result ];
        const completedJobs = completed(this.jobs, jobs);
        this.jobs = jobs;
        const completedFiles = await completedJobs.reduce(((acc, job) => acc.then((arr => this._userImpl.getFile(job.fileId).then((file => arr.push(file) && arr))))), Promise.resolve([]));
        completedFiles.length && this._plugin.emit({
            type: "jobs-complete",
            data: completedFiles.map((fileImpl => new File(fileImpl, this._plugin)))
        });
    }
    stop() {
        clearInterval(this._intervalId);
        this._intervalId = 0;
    }
}

function loadScript(url) {
    return new Promise(((resolve, reject) => {
        const script = document.createElement("script");
        script.src = url;
        script.async = true;
        script.onload = resolve;
        script.onerror = reject;
        document.body.appendChild(script);
    }));
}

class EventEmitter$1 {
    constructor() {
        this.draggers = [];
        this.emitEvent = this.emitEvent.bind(this);
    }
    addDragger(dragger, events) {
        const subscriber = {
            dragger: dragger,
            events: events.map((key => ({
                key: key,
                fn: event => dragger[key] && dragger[key](event)
            })))
        };
        subscriber.events.forEach((ev => this.addEventListener(ev.key, ev.fn)));
        this.draggers.push(subscriber);
    }
    removeDragger(dragger) {
        const draggers = this.draggers.filter((d => d.dragger === dragger));
        draggers.forEach((dragger => {
            dragger.events.forEach((ev => this.removeEventListener(ev.key, ev.fn)));
        }));
        this.draggers = this.draggers.filter((d => d.dragger !== dragger));
    }
    addEventListener(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === undefined) {
            listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
        }
    }
    removeEventListener(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
                listenerArray.splice(index, 1);
            }
        }
    }
    emitEvent(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            if (!event.target) {
                event.target = this;
            }
            const array = listenerArray.slice(0);
            for (let i = 0, l = array.length; i < l; i++) {
                array[i].call(this, event);
            }
            if (event.target === this) {
                event.target = null;
            }
        }
    }
    removeAllListeners() {
        this._listeners = [];
    }
    attach(element, eventType) {
        return element.addEventListener(eventType, this.emitEvent);
    }
    detach(element, eventType) {
        return element.removeEventListener(eventType, this.emitEvent);
    }
}

const memoize = f => {
    const cache = {};
    return (...args) => {
        const argStr = JSON.stringify(args);
        cache[argStr] = cache[argStr] || f(...args);
        return cache[argStr];
    };
};

const loadVisualizeJS = memoize(((url, onprogress) => loadScript(url).then((() => new Promise((resolve => {
    const instance = window["getVisualizeLibInst"]({
        urlMemFile: url + ".wasm",
        TOTAL_MEMORY: 134217728,
        onprogress: onprogress
    });
    instance.postRun.push((() => resolve(instance)));
}))))));

const composingMatrixFromTransform = (translate, rotate, scale, modelCenter, matrix) => {
    const translateMatrix = matrix.setTranslation([ translate.x, translate.y, translate.z ]);
    const rotateMatrix = matrix.setToRotation(rotate.angle, [ rotate.x, rotate.y, rotate.z ], modelCenter);
    const scaleMatrix = matrix.setToScaling(scale, modelCenter);
    return translateMatrix.postMultBy(rotateMatrix).postMultBy(scaleMatrix);
};

class OdaGeAction {
    constructor(module) {
        this.m_module = module;
    }
    getViewer() {
        return this.m_module.getViewer();
    }
    getModel() {
        return this.getViewer().getMarkupModel();
    }
    copyPoint(point) {
        const p = new this.m_module.Point3d;
        p.set(point.x, point.y, point.z);
        return p;
    }
    createVector3d() {
        return new this.m_module.Vector3d;
    }
    createPoint3d() {
        return new this.m_module.Point3d;
    }
    createMatrix3d() {
        return new this.m_module.Matrix3d;
    }
    createPlane() {
        return new this.m_module.OdTvPlane;
    }
    toVector(geVector) {
        return this.m_module.Vector3d.createFromArray(geVector);
    }
    toGeVector(v) {
        return [ v.x, v.y, v.z ];
    }
    toGePoint(point) {
        return [ point.x, point.y, point.z ];
    }
    toPoint(gePoint) {
        return this.m_module.Point3d.createFromArray(gePoint);
    }
    screenToWorld(x, y) {
        return this.toPoint(this.m_module.getViewer().screenToWorld(x, y));
    }
    toDoubleArray(points) {
        const p = [];
        for (let i = 0; i < points.length; i++) {
            p.push(points[i].x);
            p.push(points[i].y);
            p.push(points[i].z);
        }
        return p;
    }
    correctCameraTarget() {
        const params = this.getViewParams();
        let ext = this.m_module.getViewer().getActiveExtents();
        const {min: min, max: max} = ext;
        const target = this.toGePoint(params.target);
        const contains = target.x >= min.x && target.y >= min.y && target.z >= min.z && target.x <= max.x && target.y <= max.y && target.z <= max.z;
        if (!contains) {
            params.target = ext.center();
            this.setViewParams(params);
        }
    }
    setViewParams(params) {
        const extView = this.m_module.getViewer().getActiveTvExtendedView();
        extView.setView(params.position, params.target, params.upVector, params.viewFieldWidth, params.viewFieldHeight, params.perspective);
        extView.delete && extView.delete();
    }
    getViewParams() {
        const view = this.m_module.getViewer().activeView;
        const obj = {
            position: view.viewPosition,
            target: view.viewTarget,
            upVector: view.upVector,
            viewFieldWidth: view.viewFieldWidth,
            viewFieldHeight: view.viewFieldHeight,
            perspective: view.perspective
        };
        view.delete && view.delete();
        return obj;
    }
}

const CLICK_DELTA = 5;

const OVERLAY_VIEW_NAME = "$OVERLAY_VIEW_NAME";

function syncOverlayView(viewer) {
    let overlayView = viewer.getViewByName(OVERLAY_VIEW_NAME);
    const activeView = viewer.activeView;
    if (!overlayView) {
        const overlayModel = viewer.getMarkupModel();
        const pDevice = viewer.getActiveDevice();
        overlayView = pDevice.createView(OVERLAY_VIEW_NAME, false);
        overlayView.addModel(overlayModel);
        activeView.addSibling(overlayView);
        pDevice.addView(overlayView);
    }
    overlayView.viewPosition = activeView.viewPosition;
    overlayView.viewTarget = activeView.viewTarget;
    overlayView.upVector = activeView.upVector;
    overlayView.viewFieldWidth = activeView.viewFieldWidth;
    overlayView.viewFieldHeight = activeView.viewFieldHeight;
    const viewPort = overlayView.getViewport();
    overlayView.setViewport(viewPort.lowerLeft, viewPort.upperRight);
    overlayView.vportRect = activeView.vportRect;
    return overlayView;
}

class OdBaseDragger extends OdaGeAction {
    constructor(subject) {
        super(subject.visualizeJs);
        this.subject = subject;
        this.needInputText = false;
        this.touchStartPoints = {
            x: 0,
            y: 0
        };
        this.touchEndPoints = {
            x: 0,
            y: 0
        };
        this.mouseDownPosition = {
            x: 0,
            y: 0
        };
        this.autoSelect = false;
        this.onmessage = new Function;
        this.onmessage = event => this.subject.emitEvent(event);
        this.subject.eventEmitter.addDragger(this, [ "mousemove", "mouseleave", "mousedown", "mouseup", "mouseleave", "click", "touchstart", "touchend", "touchcancel", "touchmove", "dblclick" ]);
    }
    dispose() {
        this.subject.eventEmitter.removeDragger(this);
    }
    relativeCoords(event) {
        const bounds = event.target.getBoundingClientRect();
        event.touches && event.touches[0] && (event = event.touches[0]);
        const x = event.clientX - bounds.left;
        const y = event.clientY - bounds.top;
        const rect = this.m_module.canvas.getBoundingClientRect();
        const left = rect.left;
        const top = rect.top;
        const right = rect.right;
        const bottom = rect.bottom;
        if (x <= left || x >= right || y <= top || y >= bottom) {
            return {
                x: x * window.devicePixelRatio,
                y: y * window.devicePixelRatio,
                isValid: false
            };
        }
        return {
            x: x * window.devicePixelRatio,
            y: y * window.devicePixelRatio,
            isValid: true
        };
    }
    touchstart(ev) {
        if (ev.touches.length > 1) {
            ev.preventDefault();
        }
        const relCoord = this.relativeCoords(ev);
        this.isDragging = true;
        this.touchStartPoints.x = relCoord.x;
        this.touchStartPoints.y = relCoord.y;
        this.touchEndPoints.x = relCoord.x;
        this.touchEndPoints.y = relCoord.y;
        this.start(relCoord.x, relCoord.y);
        this.onmessage({
            type: "update"
        });
    }
    touchend(ev) {
        this.end(this.touchEndPoints.x, this.touchEndPoints.y);
        this.isDragging = false;
        this.onmessage({
            type: "update"
        });
    }
    touchmove(ev) {
        const relCoord = this.relativeCoords(ev);
        ev.touches[0];
        this.touchEndPoints.x = relCoord.x;
        this.touchEndPoints.y = relCoord.y;
        this.drag(relCoord.x, relCoord.y, this.touchStartPoints.x - relCoord.x, this.touchStartPoints.y - relCoord.y);
        if (this.isDragging) {
            this.onmessage({
                type: "update"
            });
        }
    }
    mousedown(ev) {
        const relCoord = this.relativeCoords(ev);
        this.isDragging = true;
        this.mouseDownPosition = {
            x: relCoord.x,
            y: relCoord.y
        };
        this.start(this.mouseDownPosition.x, this.mouseDownPosition.y, ev.clientX, ev.clientY);
        this.onmessage({
            type: "update"
        });
    }
    mouseup(ev) {
        const relCoord = this.relativeCoords(ev);
        this.end(relCoord.x, relCoord.y);
        this.isDragging = false;
        this.onmessage({
            type: "update"
        });
    }
    mouseleave(ev) {
        this.mouseup(ev);
    }
    mousemove(ev) {
        const relCoord = this.relativeCoords(ev);
        if (!relCoord.isValid) {
            this.mouseup(ev);
            return;
        }
        this.drag(relCoord.x, relCoord.y, ev.movementX, ev.movementY);
        if (this.isDragging) {
            this.onmessage({
                type: "update"
            });
        }
    }
    click(ev) {
        const relCoord = this.relativeCoords(ev);
        const x = relCoord.x;
        const y = relCoord.y;
        const isNotDragging = Math.abs(x - this.mouseDownPosition.x) < CLICK_DELTA && Math.abs(y - this.mouseDownPosition.y) < CLICK_DELTA;
        const viewer = this.getViewer();
        if (viewer && viewer.getEnableAutoSelect() && isNotDragging) {
            viewer.unselect();
            viewer.select(x, y, x, y);
            const pSelected = viewer.getSelected();
            if (!pSelected.isNull() && pSelected.numItems() !== 0) {
                this.onmessage({
                    type: "select",
                    data: pSelected
                });
            }
            this.onmessage({
                type: "update"
            });
        }
    }
    dblclick(ev) {
        const viewer = this.getViewer();
        const relCoord = this.relativeCoords(ev);
        const x = relCoord.x;
        const y = relCoord.y;
        const device = viewer.getActiveDevice();
        const clickView = device.viewAt([ x, y ]);
        if (clickView && !clickView.active) {
            viewer.activeView = clickView;
            clickView.delete();
            this.onmessage({
                type: "update"
            });
        } else {
            if (viewer && viewer.getEnableAutoSelect()) {
                const pSelected = viewer.getSelected();
                if (!pSelected.isNull() && pSelected.numItems() !== 0) {
                    const itr = pSelected.getIterator();
                    const entity = itr.getEntity();
                    viewer.zoomToEntity(entity);
                    this.onmessage({
                        type: "zoomToEntity",
                        data: entity
                    });
                    this.onmessage({
                        type: "update"
                    });
                    this.deleteAll([ itr, entity ]);
                }
                pSelected.delete();
            }
        }
        device.delete();
    }
    start(x, y) {}
    drag(x, y) {}
    end(x, y) {}
    beginInteractivity() {
        const view = this.getViewer().activeView;
        if (view["beginInteractivity"]) {
            view.beginInteractivity(15);
            this.onmessage({
                type: "update"
            });
        }
        view.delete();
    }
    endInteractivity() {
        const view = this.getViewer().activeView;
        if (view["endInteractivity"]) {
            view.endInteractivity();
            const device = this.getViewer().getActiveDevice();
            const canvas = this.m_module.canvas;
            device.invalidate([ 0, 0, canvas.width, canvas.height ]);
            device.delete();
            this.onmessage({
                type: "update"
            });
        }
        view.delete();
    }
    getActiveMarkupEntity(type) {
        syncOverlayView(this.getViewer());
        const model = this.getViewer().getMarkupModel();
        const entityName = "$MarkupTempEntity_" + type;
        let entityId = model.appendEntity(entityName);
        const entity = entityId.openObject();
        entity.setColor(255, 0, 0);
        entity.setLineWeight(2);
        entity.delete();
        model.delete();
        return entityId;
    }
    deleteAll(objects) {
        for (let obj of objects) {
            obj && obj.delete && obj.delete();
        }
    }
}

class OdPanDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.m_module.getViewer().setEnableAutoSelect(true);
    }
    start(x, y) {
        this.press = true;
        this.m_start = this.screenToWorld(x, y);
        this.beginInteractivity();
    }
    drag(x, y, dltX, dltY) {
        if (this.press) {
            const {Vector3d: Vector3d} = this.m_module;
            const params = this.getViewParams();
            const pt = this.screenToWorld(x, y);
            const ptSub = this.m_start.sub(pt);
            const delta = ptSub.asVector();
            const target = Vector3d.createFromArray(params.target);
            const targetWithDelta = target.add(delta);
            params.target = targetWithDelta.toArray();
            const position = Vector3d.createFromArray(params.position);
            const positionWithDelta = position.add(delta);
            params.position = positionWithDelta.toArray();
            this.setViewParams(params);
            pt.delete();
            ptSub.delete();
            delta.delete();
            target.delete();
            targetWithDelta.delete();
            position.delete();
            positionWithDelta.delete();
        }
    }
    end(x, y) {
        this.press = false;
        this.endInteractivity();
        this.m_start && this.m_start.delete();
        this.m_start = null;
    }
}

class OdOrbitDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.getViewer().setEnableAutoSelect(true);
    }
    start(x, y) {
        this.press = true;
        this.m_viewCenter = this.getCenter();
        this.m_startPoint = {
            x: x,
            y: y
        };
        const view = this.getViewer().activeView;
        this.startCameraParams = {
            position: view.viewPosition,
            target: view.viewTarget,
            upVector: view.upVector,
            viewFieldWidth: view.viewFieldWidth,
            viewFieldHeight: view.viewFieldHeight,
            perspective: view.perspective
        };
        view.delete();
        this.beginInteractivity();
    }
    setDefaultViewParams() {
        const extView = this.getViewer().getActiveTvExtendedView();
        extView.setView(this.startCameraParams.position, this.startCameraParams.target, this.startCameraParams.upVector, this.startCameraParams.viewFieldWidth, this.startCameraParams.viewFieldHeight, this.startCameraParams.perspective);
        extView.delete();
    }
    getSideVector(viewParams) {
        const pUpV = this.toVector(viewParams.upVector);
        const pTarget = this.toPoint(viewParams.target);
        const pPosition = this.toPoint(viewParams.position);
        const direct = pTarget.sub(pPosition);
        const vDirect = direct.asVector();
        const vCross = pUpV.crossProduct(vDirect);
        const sideVector = vCross.normalize();
        this.deleteAll([ direct, pUpV, pTarget, pPosition, vDirect, vCross ]);
        return sideVector;
    }
    calculateXOrbit(viewParams, delta, sideVector) {
        {
            const pPoint = this.toPoint(viewParams.position);
            const pCenter = this.toPoint(this.m_viewCenter);
            const rotatePoint = pPoint.rotateByBasePoint(delta, sideVector, pCenter);
            viewParams.position = rotatePoint.toArray();
            this.deleteAll([ pPoint, pCenter, rotatePoint ]);
        }
        {
            const pTarget = this.toPoint(viewParams.target);
            const pCenter = this.toPoint(this.m_viewCenter);
            const rotatePoint = pTarget.rotateByBasePoint(delta, sideVector, pCenter);
            viewParams.target = rotatePoint.toArray();
            this.deleteAll([ pTarget, pCenter, rotatePoint ]);
        }
        {
            const pPoint = this.toPoint(viewParams.position);
            const pTarget = this.toPoint(viewParams.target);
            const pCenter = this.toPoint(this.m_viewCenter);
            const pUp = pTarget.sub(pPoint);
            const vUp = pUp.asVector();
            const crossProduct = vUp.crossProduct(sideVector);
            const crossProductNormal = crossProduct.normalize();
            viewParams.upVector = crossProductNormal.toArray();
            this.deleteAll([ pPoint, pTarget, pCenter, pUp, vUp, crossProduct, crossProductNormal ]);
        }
    }
    calculateYOrbit(viewParams, delta, sideVector) {
        {
            const pPoint = this.toPoint(viewParams.position);
            const pCenter = this.toPoint(this.m_viewCenter);
            const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);
            const rotatePoint = pPoint.rotateByBasePoint(delta, zAxis, pCenter);
            viewParams.position = rotatePoint.toArray();
            this.deleteAll([ zAxis, pPoint, pCenter, rotatePoint ]);
        }
        {
            const pTarget = this.toPoint(viewParams.target);
            const pCenter = this.toPoint(this.m_viewCenter);
            const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);
            const rotatePoint = pTarget.rotateByBasePoint(delta, zAxis, pCenter);
            viewParams.target = rotatePoint.toArray();
            this.deleteAll([ zAxis, pTarget, pCenter, rotatePoint ]);
        }
        {
            const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);
            const pTarget = this.toPoint(viewParams.target);
            const pPoint = this.toPoint(viewParams.position);
            const side = sideVector.rotateBy(delta, zAxis);
            const pUp = pTarget.sub(pPoint);
            const vUp = pUp.asVector();
            const cross = vUp.crossProduct(side);
            const crossNormal = cross.normalize();
            viewParams.upVector = crossNormal.toArray();
            this.deleteAll([ zAxis, pTarget, pPoint, side, pUp, vUp, cross, crossNormal ]);
        }
    }
    drag(x, y, dltX, dltY) {
        if (this.press) {
            const view = this.getViewer().activeView;
            const corners = view.vportRect;
            const size = Math.max(Math.abs(corners[2] - corners[0]), Math.abs(corners[3] - corners[1]));
            const distX = (this.m_startPoint.x - x) * Math.PI / size;
            const distY = (this.m_startPoint.y - y) * Math.PI / size;
            this.m_startPoint.x = x;
            this.m_startPoint.y = y;
            const xOrbit = distY;
            const yOrbit = distX;
            const viewParams = {
                position: view.viewPosition,
                target: view.viewTarget,
                upVector: view.upVector,
                viewFieldWidth: view.viewFieldWidth,
                viewFieldHeight: view.viewFieldHeight,
                perspective: view.perspective
            };
            view.delete();
            const sideVector = this.getSideVector(viewParams);
            if (xOrbit != 0) {
                this.calculateXOrbit(viewParams, -xOrbit, sideVector);
            }
            if (yOrbit != 0) {
                this.calculateYOrbit(viewParams, yOrbit, sideVector);
            }
            sideVector.delete();
            const extView = this.getViewer().getActiveTvExtendedView();
            extView.setView(viewParams.position, viewParams.target, viewParams.upVector, viewParams.viewFieldWidth, viewParams.viewFieldHeight, viewParams.perspective);
            extView.delete();
        }
    }
    end(x, y) {
        this.press = false;
        this.endInteractivity();
    }
    mouseleave(ev) {
        this.end();
    }
    getCenter() {
        const viewer = this.getViewer();
        let ext = viewer.getActiveExtents();
        const pSet = viewer.getSelected();
        if (!pSet.isNull() && pSet.numItems() !== 0) {
            const itr = pSet.getIterator();
            const entId = itr.getEntity();
            if (entId.getType() === 1) {
                const obj = entId.openObject();
                ext.delete();
                ext = obj.getExtents();
                obj.delete();
            } else if (entId.getType() === 2) {
                const obj = entId.openObjectAsInsert();
                const extTuple = obj.getExtents();
                ext.delete();
                ext = extTuple.ext;
                extTuple.delete();
                obj.delete();
            }
            itr.delete();
        }
        pSet.delete();
        const center = ext.center();
        ext.delete();
        return center;
    }
}

class OdZoomDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.getViewer().setEnableAutoSelect(true);
    }
    start(x, y) {
        this.press = true;
        this.pressX = x;
        this.pressY = y;
    }
    drag(x, y, dltX, dltY) {
        if (this.press) {
            const ZOOM_SPEED = .025;
            const viewer = this.m_module.getViewer();
            viewer.zoomAt(dltY > 0 ? 1 + ZOOM_SPEED : 1 - ZOOM_SPEED, this.pressX, this.pressY);
            if (this.subject.activeDragger() && this.subject.activeDragger().updatePreview) {
                this.subject.activeDragger().updatePreview();
            }
        }
    }
    end(x, y) {
        this.press = false;
    }
    mouseleave(ev) {
        this.end();
    }
}

class OdSelectionFrame {
    constructor() {
        this.m_start = [ 0, 0, 0 ];
        this.m_end = [ 0, 0, 0 ];
        this.m_model = null;
    }
    createPoint3d() {
        return new this.m_module.Point3d;
    }
    init(instance, model) {
        this.m_module = instance;
        this.m_model = model;
    }
    getViewer() {
        return this.m_module.getViewer();
    }
    setValue(value) {
        this.m_end = value;
        this.draw();
    }
    setStartPoint(point) {
        this.m_start = point;
        this.m_end = point;
        this.draw();
    }
    toDoubleArray(points) {
        const p = [];
        for (let i = 0; i < points.length; i++) {
            p.push(points[i].x);
            p.push(points[i].y);
            p.push(points[i].z);
        }
        return p;
    }
    draw() {
        const view = this.getViewer().activeView;
        const viewM = view.viewingMatrix;
        const points = [];
        points.push(this.m_start);
        points.push(this.createPoint3d());
        points.push(this.m_end);
        points.push(this.createPoint3d());
        let p0 = this.createPoint3d();
        p0.set(this.m_start.x, this.m_start.y, this.m_start.z);
        let p2 = this.createPoint3d();
        p2.set(this.m_end.x, this.m_end.y, this.m_end.z);
        p0.transformBy(viewM);
        p2.transformBy(viewM);
        points[1].x = p0.x;
        points[3].x = p2.x;
        points[1].y = p2.y;
        points[3].y = p0.y;
        points[1].z = points[3].z = p2.z;
        const eyeM = view.eyeToWorldMatrix;
        points[1].transformBy(eyeM);
        points[3].transformBy(eyeM);
        if (!this.m_entity) {
            this.m_entity = this.m_model.appendEntity("");
            const entityPtr = this.m_entity.openObject();
            entityPtr.setColor(112, 112, 112);
            entityPtr.setLineWeight(2);
            this.m_frame = entityPtr.appendPolygon(this.toDoubleArray(points));
            entityPtr.delete();
        } else {
            this.m_frame.openAsPolygon().setPoints(this.toDoubleArray(points));
        }
    }
    clear() {
        if (this.m_entity) {
            this.m_model.removeEntity(this.m_entity);
            this.m_entity = null;
        }
    }
}

class OdZoomWindowDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.needInputText = false;
        this.m_frame = new OdSelectionFrame;
        this.getViewer().setEnableAutoSelect(true);
        this.m_frame.init(this.m_module, this.getModel());
    }
    start(x, y) {
        this.press = true;
        this.m_minX = x;
        this.m_minY = y;
        const startPoint = this.screenToWorld(x, y);
        this.m_frame.setStartPoint(startPoint);
    }
    drag(x, y, dltX, dltY) {
        if (this.press) {
            this.m_maxX = x;
            this.m_maxY = y;
            const point = this.screenToWorld(x, y);
            this.m_frame.setValue(point);
        }
    }
    end(x, y) {
        this.press = false;
        this.m_maxX = x;
        this.m_maxY = y;
        if (this.m_minX !== this.m_maxX && this.m_minY !== this.m_maxY) {
            this.m_frame.clear();
            this.getViewer().zoomWindow(this.m_minX, this.m_minY, this.m_maxX, this.m_maxY);
        }
    }
}

class OrbitAroundBuildingDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.maxPolarAngle = Math.PI / 2;
        this.minPolarAngle = 0;
        this.getViewer().setEnableAutoSelect(true);
    }
    start(x, y) {
        this.press = true;
        this.m_viewCenter = this.getCenter();
        this.m_startPoint = {
            x: x,
            y: y
        };
        const view = this.getViewer().activeView;
        this.startCameraParams = this.getViewParams();
        const corners = view.vportRect;
        this.m_delta = Math.max(corners[1] - corners[0], corners[2] - corners[3]);
        this.beginInteractivity();
    }
    setDefaultViewParams() {
        this.setViewParams(this.startCameraParams);
    }
    drag(x, y, dltX, dltY) {
        if (this.press) {
            let dX = x - this.m_startPoint.x;
            let dY = y - this.m_startPoint.y;
            dX *= Math.PI / this.m_delta;
            dY *= Math.PI / this.m_delta;
            this.setDefaultViewParams();
            const {Vector3d: Vector3d, Matrix3d: Matrix3d} = this.m_module;
            const target = Vector3d.createFromArray(this.startCameraParams.target);
            const offset = Vector3d.createFromArray(this.startCameraParams.position).sub(target);
            const dir = offset.normalize();
            const zMatrix = new Matrix3d;
            zMatrix.setToIdentity();
            const xMatrix = new Matrix3d;
            xMatrix.setToIdentity();
            const yAxis = Vector3d.createFromArray([ dir.x, dir.y, dir.z ]);
            const zAxis = Vector3d.createFromArray(this.startCameraParams.upVector);
            const xAxis = yAxis.crossProduct(zAxis);
            let xyDir = Vector3d.createFromArray([ yAxis.x, yAxis.y, 0 ]);
            if (xyDir.length() <= 1e-5) {
                xyDir.set(-xAxis.y, xAxis.x, 0);
            } else {
                xyDir = xyDir.normalize();
            }
            const xyAngle = Math.sign(xyDir.dotProduct(Vector3d.createFromArray([ -1, 0, 0 ]))) * xyDir.angleTo(Vector3d.createFromArray([ 0, 1, 0 ]));
            dX -= xyAngle;
            let yzDir = Vector3d.createFromArray([ dir.x, dir.y, 0 ]);
            let yzAngle = 0;
            if (yzDir.length() <= 1e-5) {
                yzAngle = -dir.z * Math.PI / 2;
            } else {
                yzDir = yzDir.normalize();
                yzAngle = -yzDir.angleTo(dir);
            }
            dY -= yzAngle;
            zMatrix.setToRotation(-dX, [ 0, 0, 1 ], [ 0, 0, 0 ]);
            const xAngle = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, dY));
            xMatrix.setToRotation(xAngle, [ 1, 0, 0 ], [ 0, 0, 0 ]);
            const endMatrix = zMatrix.postMultBy(xMatrix);
            let pos = Vector3d.createFromArray([ 0, 1, 0 ]).transformBy(endMatrix);
            const up = Vector3d.createFromArray([ 0, 0, 1 ]).transformBy(endMatrix);
            pos.setLength(offset.length());
            pos = target.add(pos);
            const current = this.getViewParams();
            current.position = pos.toArray();
            current.upVector = up.toArray();
            this.setViewParams(current);
        }
    }
    end(x, y) {
        this.press = false;
        this.endInteractivity();
    }
    mouseleave(ev) {
        this.end();
    }
    getCenter() {
        const viewer = this.getViewer();
        let ext = viewer.getActiveExtents();
        const pSet = viewer.getSelected();
        if (!pSet.isNull() && pSet.numItems() !== 0) {
            const itr = pSet.getIterator();
            const entId = itr.getEntity();
            if (entId.getType() === 1) {
                const obj = entId.openObject();
                ext.delete();
                ext = obj.getExtents();
                obj.delete();
            } else if (entId.getType() === 2) {
                const obj = entId.openObjectAsInsert();
                const extTuple = obj.getExtents();
                ext.delete();
                ext = extTuple.ext;
                extTuple.delete();
                obj.delete();
            }
            itr.delete();
        }
        pSet.delete();
        const center = ext.center();
        ext.delete();
        return center;
    }
}

class OdZoomWheelDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.subject.eventEmitter.removeDragger(this);
        this.subject.eventEmitter.addDragger(this, [ "wheel" ]);
    }
    wheel(event) {
        event = event || window.event;
        const ZOOM_SPEED = .075;
        const sign = Math.sign(event.deltaY);
        const viewer = this.m_module.getViewer();
        if (viewer) {
            const k = ZOOM_SPEED * sign;
            const {Vector3d: Vector3d} = this.m_module;
            const params = this.getViewParams();
            const center = Vector3d.createFromArray([ this.m_module.canvas.clientWidth * .5, this.m_module.canvas.clientHeight * .5, 0 ]);
            const mousePos = Vector3d.createFromArray([ event.offsetX, event.offsetY, 0 ]);
            const mouseDelta = mousePos.sub(center);
            params.viewFieldWidth = params.viewFieldWidth * (1 + k);
            params.viewFieldHeight = params.viewFieldHeight * (1 + k);
            this.setViewParams(params);
            k < 0 && viewer.pan(mouseDelta.x * k, mouseDelta.y * k);
            if (this.subject.activeDragger() && this.subject.activeDragger().updatePreview) {
                this.subject.activeDragger().updatePreview();
            }
            center.delete();
            mousePos.delete();
            mouseDelta.delete();
        }
    }
}

function createHtmlElementIfNeed(element, targetElement) {
    if (!element) {
        element = document.createElement("div");
        targetElement.appendChild(element);
    }
    return element;
}

function destroyHtmlElement(element, targetElement) {
    if (element) {
        targetElement.removeChild(element);
    }
    return null;
}

function worldToScreen(gePoint, moduleInstance, viewer) {
    const worldPoint = moduleInstance.Point3d.createFromArray(gePoint);
    const avp = viewer.activeView;
    const mtx = avp.worldToDeviceMatrix;
    const devicePoint = worldPoint.transformBy(mtx);
    const res = {
        x: devicePoint.x / window.devicePixelRatio,
        y: devicePoint.y / window.devicePixelRatio
    };
    mtx.delete();
    worldPoint.delete();
    devicePoint.delete();
    avp.delete();
    return res;
}

function getDistance(gePoint1, gePoint2, moduleInstance) {
    const tvPoint1 = moduleInstance.Point3d.createFromArray(gePoint1);
    const tvPoint2 = moduleInstance.Point3d.createFromArray(gePoint2);
    const distance = tvPoint1.distanceTo(tvPoint2).toFixed(2);
    tvPoint1.delete();
    tvPoint2.delete();
    return distance;
}

function normalizeFloat(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
}

const lineSegmentsIntersect = (p1, p2, p3, p4) => {
    const a_dx = p2.x - p1.x;
    const a_dy = p2.y - p1.y;
    const b_dx = p4.x - p3.x;
    const b_dy = p4.y - p3.y;
    const s = (-a_dy * (p1.x - p3.x) + a_dx * (p1.y - p3.y)) / (-b_dx * a_dy + a_dx * b_dy);
    const t = (+b_dx * (p1.y - p3.y) - b_dy * (p1.x - p3.x)) / (-b_dx * a_dy + a_dx * b_dy);
    return s >= 0 && s <= 1 && t >= 0 && t <= 1 ? {
        x: normalizeFloat(p1.x + t * a_dx),
        y: normalizeFloat(p1.y + t * a_dy)
    } : false;
};

function checkSegmentsIntersect(p1, p2, p3, p4, res) {
    const r = lineSegmentsIntersect(p1, p2, p3, p4);
    if (r) {
        res.push(r);
    }
}

function isInsideRect(p, width, height) {
    return p.x <= width && p.x >= 0 && p.y <= height && p.y >= 0;
}

function getDataForDrawLineWithFixed(p1, p2, width, height) {
    const pLU = {
        x: 0,
        y: 0
    };
    const pRU = {
        x: width,
        y: 0
    };
    const pLB = {
        x: 0,
        y: height
    };
    const pRB = {
        x: width,
        y: height
    };
    const intersects = [];
    checkSegmentsIntersect(p1, p2, pLU, pRU, intersects);
    checkSegmentsIntersect(p1, p2, pLU, pLB, intersects);
    checkSegmentsIntersect(p1, p2, pLB, pRB, intersects);
    checkSegmentsIntersect(p1, p2, pRB, pRU, intersects);
    let fixedP1 = null;
    let fixedP2 = null;
    if (intersects.length === 0) {
        fixedP1 = p1;
        fixedP2 = p2;
    } else if (intersects.length === 1) {
        if (isInsideRect(p1, width, height)) {
            fixedP1 = p1;
            fixedP2 = intersects[0];
        } else {
            fixedP1 = intersects[0];
            fixedP2 = p2;
        }
    } else {
        fixedP1 = intersects[0];
        fixedP2 = intersects[1];
    }
    const dx = fixedP2.x - fixedP1.x;
    const dy = fixedP2.y - fixedP1.y;
    let angle = 180 * Math.atan(dy / dx) / Math.PI;
    if (dx < 0) {
        angle -= 180;
    }
    const size = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    return {
        angle: angle,
        width: size,
        p1: fixedP1,
        p2: fixedP2
    };
}

function onSetCallback(element, cb) {
    if (element) {
        element.onclick = cb ? () => cb(this) : () => {};
    }
}

function onSetSelectivity(element, enable) {
    element.style.pointerEvents = enable ? "auto" : "none";
}

class MeasureLineItem {
    constructor(targetElement, viewer, moduleInstance) {
        this.htmlElemStartPoint = null;
        this.htmlElemEndPoint = null;
        this.htmlElemLine = null;
        this.htmlElemTitle = null;
        this.startPoint = null;
        this.endPoint = null;
        this.unit = "";
        this.scale = 1;
        this.size = 10;
        this.lineThickness = 2;
        this.style = {
            border: "2px solid #FFFFFF",
            background: "#009bff",
            color: "white",
            boxShadow: "0 0 10px rgba(0,0,0,0.5)"
        };
        this.htmlElemStartPoint = createHtmlElementIfNeed(this.htmlElemStartPoint, targetElement);
        this.htmlElemEndPoint = createHtmlElementIfNeed(this.htmlElemEndPoint, targetElement);
        this.htmlElemLine = createHtmlElementIfNeed(this.htmlElemLine, targetElement);
        this.htmlElemTitle = createHtmlElementIfNeed(this.htmlElemTitle, targetElement);
        this.viewer = viewer;
        this.moduleInstance = moduleInstance;
        this.targetElement = targetElement;
        this.isFinishDraw = false;
    }
    drawMeasureLine() {
        const pointSize = this.size;
        const rect = this.moduleInstance.canvas.getBoundingClientRect();
        if (this.startPoint) {
            this.htmlElemStartPoint = createHtmlElementIfNeed(this.htmlElemStartPoint, this.targetElement);
            const pScreenStart = worldToScreen(this.startPoint, this.moduleInstance, this.viewer);
            if (isInsideRect(pScreenStart, rect.width, rect.height)) {
                this.htmlElemStartPoint.style.display = "block";
                this.htmlElemStartPoint.style.cursor = "pointer";
                this.htmlElemStartPoint.style.position = "absolute";
                this.htmlElemStartPoint.style.top = `${pScreenStart.y - pointSize / 2}px`;
                this.htmlElemStartPoint.style.left = `${pScreenStart.x - pointSize / 2}px`;
                this.htmlElemStartPoint.style.borderRadius = `${pointSize}px`;
                this.htmlElemStartPoint.style.border = this.style.border;
                this.htmlElemStartPoint.style.background = this.style.background;
                this.htmlElemStartPoint.style.zIndex = 2;
                this.htmlElemStartPoint.style.width = `${pointSize}px`;
                this.htmlElemStartPoint.style.height = `${pointSize}px`;
                this.htmlElemStartPoint.style.boxShadow = this.style.boxShadow;
            } else {
                this.htmlElemStartPoint.style.display = "none";
            }
        }
        if (this.endPoint && this.isFinishDraw) {
            this.htmlElemEndPoint = createHtmlElementIfNeed(this.htmlElemEndPoint, this.targetElement);
            const pScreenEnd = worldToScreen(this.endPoint, this.moduleInstance, this.viewer);
            if (isInsideRect(pScreenEnd, rect.width, rect.height)) {
                this.htmlElemEndPoint.style.display = "block";
                this.htmlElemEndPoint.style.cursor = "pointer";
                this.htmlElemEndPoint.style.position = "absolute";
                this.htmlElemEndPoint.style.top = `${pScreenEnd.y - pointSize / 2}px`;
                this.htmlElemEndPoint.style.left = `${pScreenEnd.x - pointSize / 2}px`;
                this.htmlElemEndPoint.style.borderRadius = `${pointSize}px`;
                this.htmlElemEndPoint.style.border = this.style.border;
                this.htmlElemEndPoint.style.background = this.style.background;
                this.htmlElemEndPoint.style.zIndex = 2;
                this.htmlElemEndPoint.style.width = `${pointSize}px`;
                this.htmlElemEndPoint.style.height = `${pointSize}px`;
                this.htmlElemEndPoint.style.boxShadow = this.style.boxShadow;
            } else {
                this.htmlElemEndPoint.style.display = "none";
            }
        }
        if (this.endPoint && this.startPoint) {
            const point1 = worldToScreen(this.startPoint, this.moduleInstance, this.viewer);
            const point2 = worldToScreen(this.endPoint, this.moduleInstance, this.viewer);
            const {p1: p1, p2: p2, angle: angle, width: width} = getDataForDrawLineWithFixed(point1, point2, rect.width, rect.height);
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const height = this.lineThickness;
            if (isInsideRect(p1, rect.width, rect.height) && isInsideRect(p2, rect.width, rect.height)) {
                this.htmlElemLine = createHtmlElementIfNeed(this.htmlElemLine, this.targetElement);
                this.htmlElemLine.style.display = "block";
                this.htmlElemLine.style.cursor = "pointer";
                this.htmlElemLine.style.position = "absolute";
                this.htmlElemLine.style.top = `${p1.y}px`;
                this.htmlElemLine.style.left = `${p1.x}px`;
                this.htmlElemLine.style.width = `${width}px`;
                this.htmlElemLine.style.transform = `rotate(${angle}deg)`;
                this.htmlElemLine.style.transformOrigin = `0px ${height / 2}px`;
                this.htmlElemLine.style.boxShadow = this.style.boxShadow;
                this.htmlElemLine.style.border = "none";
                this.htmlElemLine.style.background = this.style.background;
                this.htmlElemLine.style.zIndex = 1;
                this.htmlElemLine.style.height = `${height}px`;
                const distance = `${this.getDistance()} ${this.unit}`;
                const pX = p1.x + dx / 2;
                const pY = p1.y + dy / 2;
                const widthTitle = distance.length * 10;
                this.htmlElemTitle = createHtmlElementIfNeed(this.htmlElemTitle, this.targetElement);
                this.htmlElemTitle.style.display = "block";
                this.htmlElemTitle.style.cursor = "pointer";
                this.htmlElemTitle.style.font = "10px";
                this.htmlElemTitle.style.color = "white";
                this.htmlElemTitle.style.position = "Absolute";
                this.htmlElemTitle.style.top = `${pY}px`;
                this.htmlElemTitle.style.left = `${pX - widthTitle / 2}px`;
                this.htmlElemTitle.style.width = `${widthTitle}px`;
                this.htmlElemTitle.style.transformOrigin = "0px 0px";
                this.htmlElemTitle.style.borderRadius = "5px";
                this.htmlElemTitle.style.boxShadow = this.style.boxShadow;
                this.htmlElemTitle.style.border = "none";
                this.htmlElemTitle.style.background = this.style.background;
                this.htmlElemTitle.style.zIndex = 3;
                this.htmlElemTitle.style.padding = "2px";
                this.htmlElemTitle.style.textAlign = "center";
                this.htmlElemTitle.innerHTML = `${distance}`;
            } else {
                this.htmlElemLine.style.display = "none";
                this.htmlElemTitle.style.display = "none";
            }
        }
    }
    getDistance() {
        return getDistance(this.startPoint, this.endPoint, this.moduleInstance) / this.scale;
    }
    setStartPoint(gePoint) {
        this.startPoint = gePoint;
        this.drawMeasureLine();
    }
    setEndPoint(gePoint, isFinish) {
        this.isFinishDraw = isFinish === undefined ? true : isFinish;
        this.endPoint = gePoint;
        this.drawMeasureLine();
    }
    update() {
        this.drawMeasureLine();
    }
    setSize(size) {
        this.size = size;
        this.drawMeasureLine();
    }
    clear() {
        this.endPoint = null;
        this.startPoint = null;
        this.htmlElemStartPoint = destroyHtmlElement(this.htmlElemStartPoint, this.targetElement);
        this.htmlElemEndPoint = destroyHtmlElement(this.htmlElemEndPoint, this.targetElement);
        this.htmlElemLine = destroyHtmlElement(this.htmlElemLine, this.targetElement);
        this.htmlElemTitle = destroyHtmlElement(this.htmlElemTitle, this.targetElement);
    }
    setUnit(unit) {
        this.unit = unit;
        this.drawMeasureLine();
    }
    setConversionFactor(scale) {
        this.scale = scale;
        this.drawMeasureLine();
    }
    setStyle(style) {
        this.style = style;
        this.drawMeasureLine();
    }
    setSelectionReactor(reactor) {
        onSetCallback(this.htmlElemStartPoint, reactor ? reactor.onStartPoint : null);
        onSetCallback(this.htmlElemEndPoint, reactor ? reactor.onEndPoint : null);
        onSetCallback(this.htmlElemTitle, reactor ? reactor.onTitle : null);
    }
    setSelectability(enable) {
        onSetSelectivity(this.htmlElemStartPoint, enable);
        onSetSelectivity(this.htmlElemEndPoint, enable);
        onSetSelectivity(this.htmlElemLine, enable);
        onSetSelectivity(this.htmlElemTitle, enable);
    }
}

function renameUnit(table, unit) {
    return table[unit] || unit;
}

class MeasureLineDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.lineThickness = 2;
        this.press = false;
        this.autoSelect = false;
        this.gripingRadius = 5;
        this.firstPoint = null;
        this.secondPoint = null;
        this.m_overlayElement = document.createElement("div");
        this.m_overlayElement.style.background = "rgba(0,0,0,0)";
        this.m_overlayElement.style.position = "fixed";
        this.m_overlayElement.style.zIndex = "1";
        this.m_overlayElement.style.pointerEvents = "none";
        document.body.appendChild(this.m_overlayElement);
        this.renameUnitTable = {
            Millimeters: "mm",
            Centimeters: "cm",
            Meters: "m",
            Undefined: " "
        };
        this.items = [];
        this.resize();
        this._resize = () => this.resize();
        window.addEventListener("resize", this._resize);
    }
    dispose() {
        window.removeEventListener("resize", this._resize);
        super.dispose();
        this.m_overlayElement.remove();
    }
    updatePreview() {
        for (let item of this.items) {
            item.update();
        }
    }
    resize(ev) {
        const rect = this.m_module.canvas.getBoundingClientRect();
        this.m_overlayElement.style.top = `${rect.top}px`;
        this.m_overlayElement.style.left = `${rect.left}px`;
        this.m_overlayElement.style.width = `${rect.width}px`;
        this.m_overlayElement.style.height = `${rect.height}px`;
    }
    getSnapPointRadius() {
        const view = this.getViewer().activeView;
        const corners = view.viewDcCorners();
        const pt1 = corners.lowerLeft;
        const pt2 = corners.upperRight;
        pt2[0] -= pt1[0];
        pt2[1] -= pt1[1];
        return Math.min(pt2[0], pt2[1]) / 120;
    }
    drag(x, y) {
        this.createNewMeasureIfNeed();
        const point = this.getViewer().getSnapPoint(x, y, this.gripingRadius);
        if (this.isDragging) {
            if (point) {
                if (this.firstPoint) {
                    this.secondPoint = point;
                    this.previewMeasureLine.setStartPoint(this.firstPoint);
                    this.previewMeasureLine.setEndPoint(this.secondPoint);
                } else {
                    this.firstPoint = point;
                    this.previewMeasureLine.setStartPoint(this.firstPoint);
                }
            } else {
                this.secondPoint = null;
                this.previewMeasureLine.clear();
                this.previewMeasureLine.setStartPoint(this.firstPoint);
                this.previewMeasureLine.setEndPoint(this.getViewer().screenToWorld(x, y), false);
            }
        } else {
            if (point) {
                this.previewMeasureLine.setStartPoint(point);
            } else {
                this.previewMeasureLine.clear();
            }
        }
    }
    end() {
        if (this.firstPoint && this.secondPoint) {
            const newLineMeasure = this.createMeasureLine();
            newLineMeasure.setStartPoint(this.firstPoint);
            newLineMeasure.setEndPoint(this.secondPoint);
        }
        this.firstPoint = this.secondPoint = null;
        this.previewMeasureLine.clear();
    }
    createNewMeasureIfNeed() {
        if (!this.previewMeasureLine) {
            this.previewMeasureLine = this.createMeasureLine();
        }
    }
    createMeasureLine() {
        const viewer = this.m_module.getViewer();
        var item = new MeasureLineItem(this.m_overlayElement, viewer, this.m_module);
        item.lineThickness = this.lineThickness || item.lineThickness;
        item.setUnit(renameUnit(this.renameUnitTable, viewer.getUnit()));
        this.items.push(item);
        return item;
    }
}

class OdBaseCuttingPlaneDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.getViewer().setEnableAutoSelect(false);
        const ext = this.getViewer().getActiveExtents();
        const min = ext.min();
        const max = ext.max();
        this.m_size_x = Math.abs(max[0] - min[0]) / 2;
        this.m_size_y = Math.abs(max[1] - min[1]) / 2;
        this.m_size_z = Math.abs(max[2] - min[2]) / 2;
        this.m_center = this.toPoint(ext.center());
        this.m_normal = this.createNormal();
        const avp = this.getViewer().activeView;
        const plane = this.createPlane();
        plane.set(this.toGePoint(this.m_center), this.m_normal);
        avp.addCuttingPlane(plane);
        this.index = avp.numCuttingPlanes() - 1;
        avp.setEnableCuttingPlaneFill(true, 102, 102, 102);
        this.m_model = this.getModel();
        this.createPreview();
        this.deleteAll([ ext, avp, plane ]);
    }
    dispose() {
        super.dispose();
        if (this.m_entity) {
            this.m_model.removeEntity(this.m_entity);
            this.deleteAll([ this.m_model, this.m_entity, this.planePreview ]);
            this.m_entity = null;
            this.planePreview = null;
        }
    }
    createNormal() {
        return [ 0, 0, 0 ];
    }
    handleDelta(delta) {
        return delta;
    }
    getPlanePreviewCoordinate() {
        return [];
    }
    start(x, y) {
        this.press = true;
        this.m_last = this.screenToWorld(x, y);
        this.m_click = {
            x: x,
            y: y
        };
    }
    drag(x, y) {
        if (this.press) {
            const point = this.screenToWorld(x, y);
            const delta = this.handleDelta(point.sub(this.m_last));
            const oldCenter = this.m_center;
            this.m_center = oldCenter.add(delta);
            const oldLast = this.m_last;
            this.m_last = point;
            const avp = this.getViewer().activeView;
            const plane = this.createPlane();
            const newPlane = plane.set(this.toGePoint(this.m_center), this.m_normal);
            const newCutting = avp.updateCuttingPlane(this.index, plane);
            this.drawPreview();
            this.deleteAll([ avp, plane, oldCenter, delta, oldLast, newPlane, newCutting ]);
        }
    }
    end(x, y) {
        this.press = false;
        if (x === this.m_click.x && y === this.m_click.y) {
            this.m_normal = [ this.m_normal[0] * -1, this.m_normal[1] * -1, this.m_normal[2] * -1 ];
            const avp = this.getViewer().activeView;
            const plane = this.createPlane();
            plane.set(this.toGePoint(this.m_center), this.m_normal);
            avp.updateCuttingPlane(this.index, plane);
            this.deleteAll([ avp, plane, this.m_center, this.m_last ]);
        }
    }
    createPreview() {
        this.m_entity = this.m_model.appendEntity("&CuttingPlanePreview");
        const GeometryTypes = this.m_module.GeometryTypes;
        const transparencyDef = new this.m_module.OdTvTransparencyDef;
        const colorDef = new this.m_module.OdTvColorDef(112, 112, 112);
        transparencyDef.setValue(.9);
        const entityPtr = this.m_entity.openObject();
        entityPtr.setColor(colorDef, GeometryTypes.kFaces.value);
        colorDef.setColor(112, 112, 112);
        entityPtr.setColor(colorDef, GeometryTypes.kEdges.value);
        entityPtr.setLineWeight(5);
        entityPtr.setTransparency(transparencyDef, GeometryTypes.kFaces);
        transparencyDef.setValue(1);
        entityPtr.setTransparency(transparencyDef, GeometryTypes.kEdges);
        this.planePreview = entityPtr.appendPolygon(this.getPlanePreviewCoordinate());
        const polygonPtr = this.planePreview.openAsPolygon();
        polygonPtr.setFilled(true);
        this.deleteAll([ transparencyDef, colorDef, entityPtr, polygonPtr, GeometryTypes ]);
    }
    drawPreview() {
        const polygonPtr = this.planePreview.openAsPolygon();
        polygonPtr.setPoints(this.getPlanePreviewCoordinate());
        this.deleteAll([ polygonPtr ]);
    }
}

class OdCuttingPlaneXAxisDragger extends OdBaseCuttingPlaneDragger {
    createNormal() {
        return [ 1, 0, 0 ];
    }
    handleDelta(delta) {
        delta.y = 0;
        delta.z = 0;
        return delta;
    }
    getPlanePreviewCoordinate() {
        return [ this.m_center.x, this.m_center.y - this.m_size_y, this.m_center.z - this.m_size_z, this.m_center.x, this.m_center.y + this.m_size_y, this.m_center.z - this.m_size_z, this.m_center.x, this.m_center.y + this.m_size_y, this.m_center.z + this.m_size_z, this.m_center.x, this.m_center.y - this.m_size_y, this.m_center.z + this.m_size_z ];
    }
}

class OdCuttingPlaneYAxisDragger extends OdBaseCuttingPlaneDragger {
    createNormal() {
        return [ 0, 1, 0 ];
    }
    handleDelta(delta) {
        delta.x = 0;
        delta.z = 0;
        return delta;
    }
    getPlanePreviewCoordinate() {
        return [ this.m_center.x - this.m_size_x, this.m_center.y, this.m_center.z - this.m_size_z, this.m_center.x + this.m_size_x, this.m_center.y, this.m_center.z - this.m_size_z, this.m_center.x + this.m_size_x, this.m_center.y, this.m_center.z + this.m_size_z, this.m_center.x - this.m_size_x, this.m_center.y, this.m_center.z + this.m_size_z ];
    }
}

class OdCuttingPlaneZAxisDragger extends OdBaseCuttingPlaneDragger {
    createNormal() {
        return [ 0, 0, 1 ];
    }
    handleDelta(delta) {
        delta.x = 0;
        delta.y = 0;
        return delta;
    }
    getPlanePreviewCoordinate() {
        return [ this.m_center.x - this.m_size_x, this.m_center.y - this.m_size_y, this.m_center.z, this.m_center.x + this.m_size_x, this.m_center.y - this.m_size_y, this.m_center.z, this.m_center.x + this.m_size_x, this.m_center.y + this.m_size_y, this.m_center.z, this.m_center.x - this.m_size_x, this.m_center.y + this.m_size_y, this.m_center.z ];
    }
}

class OdaLineDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.getViewer().setEnableAutoSelect(false);
    }
    dispose() {
        super.dispose();
        this.end();
        this.points = null;
        this.drawPoints = null;
    }
    start(x, y) {
        const point = this.getViewer().screenToWorld(x, y);
        this.drawPoints = [ point[0], point[1], point[2] ];
    }
    drag(x, y) {
        if (this.isDragging) {
            const point = this.getViewer().screenToWorld(x, y);
            this.drawPoints.push(point[0], point[1], point[2]);
            this._updateFrame();
        }
    }
    end() {
        if (this.entity) {
            this.entity.delete();
            this.drawPoints = null;
            this.entity = null;
        }
    }
    _updateFrame() {
        if (this.entity) {
            const model = this.getViewer().getMarkupModel();
            model.removeEntity(this.entity);
            model.delete();
            this.entity.delete();
        }
        this.entity = this.getActiveMarkupEntity("Line");
        const entityPtr = this.entity.openObject();
        entityPtr.appendPolyline(this.drawPoints).delete();
        entityPtr.delete();
    }
}

class OdaTextDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.getViewer().setEnableAutoSelect(false);
    }
    dispose() {
        super.dispose();
        this.textRef && this.textRef.remove();
        this.textRef = null;
    }
    _finishInput() {
        this._updateFrame();
        this.textRef && this.textRef.remove();
        this.textRef = null;
    }
    start(x, y, absoluteX, absoluteY) {
        if (!this.textRef) {
            this.textRef = document.createElement("textarea");
            this.textRef.style.zIndex = 9999;
            this.textRef.style.position = "absolute";
            this.textRef.style.display = "block";
            this.textRef.style.top = absoluteY + "px";
            this.textRef.style.left = absoluteX + "px";
            this.textRef.onkeypress = event => {
                if (event.key === "Enter") {
                    event.preventDefault();
                    this._finishInput();
                }
            };
            document.body.appendChild(this.textRef);
            this.press = true;
            this.m_data = null;
            this.m_center = this.screenToWorld(x, y + 24);
            this.needInputText = true;
        } else {
            this._finishInput();
        }
    }
    _updateFrame() {
        this.entity = this.getActiveMarkupEntity("Text");
        const entityPtr = this.entity.openObject();
        const view = this.getViewer().activeView;
        const pos = this.toPoint(view.viewPosition);
        const target = this.toPoint(view.viewTarget);
        const eyeToWorld = view.eyeToWorldMatrix;
        const eyeDir = pos.sub(target).asVector();
        const xDir = this.toVector([ 1, 0, 0 ]);
        const direction = xDir.transformBy(eyeToWorld);
        const mtrx = this.createMatrix3d();
        mtrx.setToWorldToPlane(this.toGeVector(eyeDir));
        direction.transformBy(mtrx);
        let angel = -Math.atan2(-direction.y, direction.x);
        let textSize = .02;
        let textScale = 1;
        const projMtrx = view.projectionMatrix;
        const mtrxNumber = projMtrx.get(1, 1);
        const tol = 1e-6;
        if (!(mtrxNumber < tol && mtrxNumber > -tol)) {
            textScale = 1 / mtrxNumber;
        }
        const geomData = entityPtr.appendText(this.toGePoint(this.m_center), this.textRef.value.trimLeft());
        const textPtr = geomData.openAsText();
        textPtr.setNormal(this.toGeVector(eyeDir));
        textPtr.setRotation(angel);
        textPtr.setTextSize(textSize * textScale);
        textPtr.delete();
        geomData.delete();
        entityPtr.delete();
    }
}

const FocalLengthConst = 42;

const calcFocalLength = (lensLength, fieldWidth, fieldHeight) => lensLength / FocalLengthConst * Math.sqrt(fieldWidth * fieldWidth + fieldHeight * fieldHeight);

class OdaWalkDragger extends OdBaseDragger {
    constructor(...args) {
        super(...args);
        this.press = false;
        this.getViewer().setEnableAutoSelect(false);
        this.lastCoord = {
            x: 0,
            y: 0
        };
        this.speed = 1;
        this.delta = this.getViewer().activeView.viewFieldWidth / 1e3;
        this.keyPressMap = new Set;
        this.onKeyDown = ev => {
            const currentDelta = this.speed * this.delta;
            this.keyPressMap.add(ev.code);
            for (let keyCode of this.keyPressMap) {
                if (keyCode === "KeyW") {
                    this.cameraWalker.moveForward(currentDelta);
                } else if (keyCode === "KeyS") {
                    this.cameraWalker.moveBackward(currentDelta);
                } else if (keyCode === "KeyA") {
                    this.cameraWalker.moveLeft(currentDelta);
                } else if (keyCode === "KeyD") {
                    this.cameraWalker.moveRight(currentDelta);
                } else if (keyCode === "KeyQ") {
                    this.cameraWalker.moveUp(currentDelta);
                } else if (keyCode === "KeyE") {
                    this.cameraWalker.moveDown(currentDelta);
                } else if (keyCode === "NumpadSubtract" || keyCode === "Minus") {
                    this.speed = this.speed !== 1 ? this.speed - 1 : 1;
                    this.subject.emitEvent({
                        type: "ChangeWalkDraggerSpeed",
                        data: this.speed
                    });
                } else if (keyCode === "NumpadAdd" || keyCode === "Equal") {
                    this.speed = this.speed !== 10 ? this.speed + 1 : 10;
                    this.subject.emitEvent({
                        type: "ChangeWalkDraggerSpeed",
                        data: this.speed
                    });
                }
            }
        };
        this.onKeyRelease = ev => {
            this.keyPressMap.delete(ev.code);
        };
        window.addEventListener("keydown", this.onKeyDown, false);
        window.addEventListener("keyup", this.onKeyRelease, false);
        if (!this.cameraId) {
            this.initialize();
        }
        this.subject._setEnableForZoomWheelDragger(false);
    }
    initialize() {
        const view = this.getViewer().activeView;
        this.subject.emitEvent({
            type: "StartWalkerDragger",
            data: null
        });
        this.viewParams = {
            position: view.viewPosition,
            target: view.viewTarget,
            upVector: view.upVector,
            viewFieldWidth: view.viewFieldWidth,
            viewFieldHeight: view.viewFieldHeight,
            perspective: view.perspective,
            lensLength: view.lensLength
        };
        const extView = this.getViewer().getActiveTvExtendedView();
        extView.setView(this.viewParams.position, this.viewParams.target, this.viewParams.upVector, this.viewParams.viewFieldWidth, this.viewParams.viewFieldHeight, true);
        extView.delete();
        view.lensLength = view.lensLength * 42 / 120;
        const model = this.getViewer().getActiveModel();
        this.cameraId = model.appendCamera("Camera0");
        const pCamera = this.cameraId.openObjectAsCamera();
        var target = view.viewTarget;
        pCamera.setDisplayGlyph(false);
        pCamera.setDisplayTarget(false);
        pCamera.setAutoAdjust(true);
        pCamera.setupCamera(view.viewPosition, target, view.upVector);
        pCamera.setNearClip(false, 1);
        pCamera.setFarClip(false, 0);
        pCamera.setViewParameters(view.viewFieldWidth, view.viewFieldHeight, true);
        const focalL = calcFocalLength(view.lensLength, view.viewFieldWidth, view.viewFieldHeight);
        {
            const pTarget = this.toPoint(view.viewTarget);
            const viewDir = this.toPoint(view.viewPosition);
            const viewDirSub = viewDir.sub(pTarget);
            const viewDirVec = viewDirSub.asVector();
            const viewDirVecNormal = viewDirVec.normalize();
            const geViewDir = this.toGeVector(viewDirVecNormal);
            const newGeViewDir = [ geViewDir[0] * focalL, geViewDir[1] * focalL, geViewDir[2] * focalL ];
            const pTarget2 = this.toPoint(view.viewTarget);
            const newGeViewDirPt = this.toPoint(newGeViewDir);
            const newPos = pTarget2.add(newGeViewDirPt);
            pCamera.setupCamera(this.toGePoint(newPos), view.viewTarget, view.upVector);
            this.deleteAll([ pTarget, viewDir, viewDirSub, viewDirVec, viewDirVecNormal, pTarget2, newGeViewDirPt, newPos ]);
        }
        pCamera.assignView(view);
        pCamera.delete();
        model.delete();
        this.cameraWalker = new this.m_module.OdTvCameraWalker;
        this.cameraWalker.setCamera(this.cameraId);
    }
    dispose() {
        super.dispose();
        this.keyPressMap.clear();
        window.removeEventListener("keydown", this.onKeyDown);
        window.removeEventListener("keyup", this.onKeyRelease);
        if (this.cameraId) {
            const model = this.getViewer().getActiveModel();
            model.removeEntity(this.cameraId);
            model.delete();
            this.cameraWalker && this.cameraWalker.delete();
        }
        if (this.viewParams) {
            const extView = this.getViewer().getActiveTvExtendedView();
            extView.setView(this.viewParams.position, this.viewParams.target, this.viewParams.upVector, this.viewParams.viewFieldWidth, this.viewParams.viewFieldHeight, this.viewParams.perspective);
            extView.delete();
            const avp = this.getViewer().activeView;
            avp.lensLength = this.viewParams.lensLength;
            avp.delete();
        }
        this.subject._setEnableForZoomWheelDragger(true);
    }
    drag(x, y, dltX, dltY) {
        const view = this.getViewer().activeView;
        const focalL = calcFocalLength(view.lensLength, view.viewFieldWidth, view.viewFieldHeight);
        const hAngle = Math.atan(view.viewFieldHeight / (2 * focalL)) * 2;
        const wAngle = Math.atan(view.viewFieldWidth / (2 * focalL)) * 2;
        const dltAngleY = Math.abs(dltY) * hAngle / this.m_module.canvas.height * this.subject.api.options.cameraAxisYSpeed;
        const dltAngleX = Math.abs(dltX) * wAngle / this.m_module.canvas.width * this.subject.api.options.cameraAxisXSpeed;
        if (this.cameraId && this.isDragging) {
            if (dltX !== 0) {
                if (dltX > 0) {
                    this.cameraWalker.turn(this.viewParams.upVector, -dltAngleX);
                } else if (dltX < 0) {
                    this.cameraWalker.turn(this.viewParams.upVector, dltAngleX);
                }
            }
            if (dltY !== 0) {
                if (dltY < 0) {
                    this.cameraWalker.turnUp(dltAngleY);
                } else if (dltY > 0) {
                    this.cameraWalker.turnDown(dltAngleY);
                }
            }
        }
    }
}

function setupViewerSettings(lib) {
    const viewer = lib.getViewer();
    const device = viewer.getActiveDevice();
    const view = device.getActiveView();
    {
        view.enableDefaultLighting(true, lib.DefaultLightingType.kTwoLights);
        view.setDefaultLightingIntensity(1.25);
    }
    const visualStyleId = viewer.createVisualStyle("OpenCloud");
    {
        const visualStylePtr = visualStyleId.openObject();
        const colorDef = new lib.OdTvColorDef(66, 66, 66);
        const shadedVsId = viewer.findVisualStyle("Realistic");
        visualStylePtr.copyFrom(shadedVsId);
        visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kFaceModifiers, 0, lib.VisualStyleOperations.kSet);
        visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeModel, 2, lib.VisualStyleOperations.kSet);
        visualStylePtr.setOptionDouble(lib.VisualStyleOptions.kEdgeCreaseAngle, 60, lib.VisualStyleOperations.kSet);
        visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeStyles, 0, lib.VisualStyleOperations.kSet);
        visualStylePtr.setOptionInt32(lib.VisualStyleOptions.kEdgeModifiers, 8, lib.VisualStyleOperations.kSet);
        visualStylePtr.setOptionColor(lib.VisualStyleOptions.kEdgeColorValue, colorDef, lib.VisualStyleOperations.kSet);
        visualStylePtr.delete();
    }
    view.visualStyle = visualStyleId;
    view.delete();
    device.delete();
}

class Viewer {
    constructor(api) {
        this.api = api;
        this._changeClientOptionCb = event => {
            const opt = event.data;
            this.syncOptions(opt);
        };
        this.api.eventEmitter.on("changeClientOption", this._changeClientOptionCb);
        this.opt = {
            visualizeJsUrl: "https://opencloud.azureedge.net/libs/visualizejs/23.1/Visualize.js"
        };
        this._activeDragger = null;
        this.visualizeJs = null;
        this.eventEmitter = new EventEmitter$1;
        this.draggerFactory = new Map;
        this.draggerFactory.set("Line", OdaLineDragger);
        this.draggerFactory.set("Text", OdaTextDragger);
        this.draggerFactory.set("Pan", OdPanDragger);
        this.draggerFactory.set("Orbit", OdOrbitDragger);
        this.draggerFactory.set("Zoom", OdZoomDragger);
        this.draggerFactory.set("ZoomWindow", OdZoomWindowDragger);
        this.draggerFactory.set("OrbitAroundBuilding", OrbitAroundBuildingDragger);
        this.draggerFactory.set("MeasureLine", MeasureLineDragger);
        this.draggerFactory.set("CuttingPlaneXAxis", OdCuttingPlaneXAxisDragger);
        this.draggerFactory.set("CuttingPlaneYAxis", OdCuttingPlaneYAxisDragger);
        this.draggerFactory.set("CuttingPlaneZAxis", OdCuttingPlaneZAxisDragger);
        this.draggerFactory.set("Walk", OdaWalkDragger);
        this.render = () => {
            this.frameId = requestAnimationFrame(this.render);
            this.visViewer().update();
        };
    }
    syncOptions(opt) {
        const viewer = this.visViewer();
        if (viewer) {
            if (opt.showFPS !== viewer.getEnableFPS()) {
                viewer.setEnableFPS(opt.showFPS);
            }
            if (opt.showWCS !== viewer.getEnableWCS()) {
                viewer.setEnableWCS(opt.showWCS);
            }
            if (opt.cameraAnimation !== viewer.getEnableAnimation()) {
                viewer.setEnableAnimation(opt.cameraAnimation);
            }
            if (opt.antialiasing !== viewer.fxaaAntiAliasing3d) {
                viewer.fxaaAntiAliasing3d = opt.antialiasing;
                viewer.fxaaQuality = 5;
            }
            if (opt.groundShadow !== viewer.groundShadow) {
                viewer.groundShadow = opt.groundShadow;
            }
            if (opt.shadows !== viewer.shadows) {
                viewer.shadows = opt.shadows;
                const canvas = this.visLib().canvas;
                const device = viewer.getActiveDevice();
                device.invalidate([ 0, canvas.clientWidth, canvas.clientHeight, 0 ]);
                device.delete();
            }
            const lib = this.visLib();
            const device = viewer.getActiveDevice();
            if (opt.ambientOcclusion !== device.getOptionBool(lib.DeviceOptions.kSSAOEnable)) {
                device.setOptionBool(lib.DeviceOptions.kSSAOEnable, opt.ambientOcclusion);
                device.setOptionBool(lib.DeviceOptions.kSSAODynamicRadius, true);
                device.setOptionDouble(lib.DeviceOptions.kSSAORadius, 1);
                device.setOptionInt32(lib.DeviceOptions.kSSAOLoops, 32);
                device.setOptionDouble(lib.DeviceOptions.kSSAOPower, 2);
                device.setOptionInt32(lib.DeviceOptions.kSSAOBlurRadius, 2);
                const avp = viewer.activeView;
                avp.setSSAOEnabled(opt.ambientOcclusion);
                avp.delete();
            }
            device.delete();
        }
    }
    _setEnableForZoomWheelDragger(enable) {
        if (enable && !this.wheelZoomDragger) {
            this.wheelZoomDragger = new OdZoomWheelDragger(this);
        } else {
            this.wheelZoomDragger && this.wheelZoomDragger.dispose();
            this.wheelZoomDragger = null;
        }
    }
    configure(opt) {
        this.opt = opt;
        return this;
    }
    initializeAsync(canvas, onprogress = null) {
        if (canvas.style.width === "" && canvas.style.height === "") {
            canvas.style.width = "100%";
            canvas.style.height = "100%";
        }
        return loadVisualizeJS(this.opt.visualizeJsUrl, (ev => {
            const {loaded: loaded, timeStamp: timeStamp, total: total, lengthComputable: lengthComputable} = ev;
            const event = {
                loaded: loaded,
                timeStamp: timeStamp,
                total: total,
                lengthComputable: lengthComputable,
                type: "visualize-progress"
            };
            onprogress && onprogress(event);
        })).then((visualizeJs => this.visualizeJs = visualizeJs)).then((() => {
            canvas.width = canvas.clientWidth * window.devicePixelRatio;
            canvas.height = canvas.clientHeight * window.devicePixelRatio;
            this.visualizeJs.canvas = canvas;
            this.visualizeJs.Viewer.create();
        })).then((() => {
            this.syncOptions(this.api.options);
            this.eventEmitter.attach(this.visualizeJs.canvas, "mousemove");
            this.eventEmitter.attach(this.visualizeJs.canvas, "mousedown");
            this.eventEmitter.attach(this.visualizeJs.canvas, "mouseup");
            this.eventEmitter.attach(this.visualizeJs.canvas, "mouseleave");
            this.eventEmitter.attach(this.visualizeJs.canvas, "click");
            this.eventEmitter.attach(this.visualizeJs.canvas, "touchstart");
            this.eventEmitter.attach(this.visualizeJs.canvas, "touchend");
            this.eventEmitter.attach(this.visualizeJs.canvas, "touchcancel");
            this.eventEmitter.attach(this.visualizeJs.canvas, "touchmove");
            this.eventEmitter.attach(this.visualizeJs.canvas, "dblclick");
            this.eventEmitter.attach(this.visualizeJs.canvas, "wheel");
            this.eventEmitter.attach(window, "resize");
            this.wheelZoomDragger = new OdZoomWheelDragger(this);
            this.eventEmitter.addEventListener("resize", (ev => {
                const {clientWidth: clientWidth, clientHeight: clientHeight} = canvas;
                canvas.height = clientHeight * window.devicePixelRatio;
                canvas.width = clientWidth * window.devicePixelRatio;
                this.visViewer().resize(0, canvas.width, canvas.height, 0);
                if (this.activeDragger() && this.activeDragger().updatePreview) {
                    this.activeDragger().updatePreview();
                }
            }));
        })).then((() => this.render())).then((() => Promise.resolve(this)));
    }
    get draggers() {
        return [ ...this.draggerFactory.keys() ];
    }
    activeDragger() {
        return this._activeDragger;
    }
    setActiveDragger(name) {
        const Constructor = this.draggerFactory.get(name);
        if (!(this._activeDragger instanceof Constructor)) {
            this._activeDragger && this._activeDragger.dispose();
            this._activeDragger = null;
            this._activeDragger = new Constructor(this);
        }
    }
    visLib() {
        return this.visualizeJs;
    }
    visViewer() {
        return this.visualizeJs.getViewer();
    }
    clearSlices() {
        const avp = this.visViewer().activeView;
        avp.removeCuttingPlanes();
        avp.delete();
    }
    clearOverlay() {
        const markupCtrl = this.visViewer().getMarkupController();
        markupCtrl.clear();
        markupCtrl.delete();
    }
    is3D() {
        const ext = this.visViewer().getActiveExtents();
        const min = ext.min();
        const max = ext.max();
        const extHeight = max[2] - min[2];
        const is3D = extHeight !== 0;
        return is3D;
    }
    dispose() {
        if (this.visLib()) {
            if (this.activeDragger()) {
                this.activeDragger().dispose();
            }
            this.visViewer().clear();
        }
        cancelAnimationFrame(this.frameId);
        this.eventEmitter.detach(this.visualizeJs.canvas, "mousemove");
        this.eventEmitter.detach(this.visualizeJs.canvas, "mousedown");
        this.eventEmitter.detach(this.visualizeJs.canvas, "mouseup");
        this.eventEmitter.detach(this.visualizeJs.canvas, "mouseleave");
        this.eventEmitter.detach(this.visualizeJs.canvas, "click");
        this.eventEmitter.detach(this.visualizeJs.canvas, "touchstart");
        this.eventEmitter.detach(this.visualizeJs.canvas, "touchend");
        this.eventEmitter.detach(this.visualizeJs.canvas, "touchcancel");
        this.eventEmitter.detach(this.visualizeJs.canvas, "touchmove");
        this.eventEmitter.detach(this.visualizeJs.canvas, "dblclick");
        this.eventEmitter.detach(this.visualizeJs.canvas, "wheel");
        this.eventEmitter.detach(window, "resize");
        this.eventEmitter.removeEventListener();
        this.wheelZoomDragger.dispose();
        this._abortController && this._abortController.abort();
        this.api.eventEmitter.remove("changeClientOption", this._changeClientOptionCb);
    }
    addEventListener(name, cb) {
        this.eventEmitter.addEventListener(name, cb);
    }
    removeEventListener(name, cb) {
        this.eventEmitter.removeEventListener(name, cb);
    }
    emitEvent(event) {
        this.eventEmitter.emitEvent(event);
    }
    getSelected() {
        const result = [];
        const selectionSet = this.visViewer().getSelected();
        if (!selectionSet.isNull()) {
            const itr = selectionSet.getIterator();
            while (!itr.done()) {
                const entityId = itr.getEntity();
                const entityPtr = entityId.openObject();
                const nativeHandle = entityPtr.getNativeDatabaseHandle();
                result.push(nativeHandle);
                entityPtr.delete();
                entityId.delete();
                itr.step();
            }
            itr.delete();
        }
        selectionSet.delete();
        return result;
    }
    async loadReferences(model) {
        let refs = [];
        try {
            const refsData = await model.getReferences();
            refs = refsData.references;
        } catch {}
        if (!this.visLib()) {
            throw new Error("VisualizeJS module is null when try load references");
        }
        if (!this.visViewer()) {
            throw new Error("VisualizeJS module getViewer return null, pls create viewer before load reference");
        }
        for (let refItem of refs) {
            const buffer = await this.api.downloadReferenceFile(refItem.id);
            this.visViewer().addEmbeddedFile(refItem.name, new Uint8Array(buffer));
        }
    }
    async _openTcsStream(model) {
        const abortController = new AbortController;
        this._abortController = abortController;
        const listFileForDownload = [ model.database, ...model.geometry ];
        const chunksProgress = listFileForDownload.map((() => 0));
        const calcProgress = (index, progress) => {
            chunksProgress[index] = progress;
            const fileProgress = chunksProgress.reduce(((acc, progress) => acc += progress)) / (chunksProgress.length || 1);
            this.emitEvent({
                type: "geometry-progress",
                data: fileProgress
            });
        };
        this.emitEvent({
            type: "geometry-start",
            data: model
        });
        this.visViewer().clear();
        this.visViewer().update();
        try {
            for (let i = 0; i < listFileForDownload.length; i++) {
                const chunk = listFileForDownload[i];
                const arrayBuffer = await model.downloadResource(chunk, (progress => calcProgress(i, progress)), abortController.signal);
                if (abortController.signal.aborted) {
                    await Promise.reject(new Error(`Open model aborted  ${model.name}`));
                }
                this.visViewer().parseStream(new Uint8Array(arrayBuffer));
                if (i == 0) {
                    this.syncOptions(this.api.options);
                    setupViewerSettings(this.visLib());
                }
                this.emitEvent({
                    type: i == 0 ? "database-chunk" : "geometry-chunk",
                    data: new Uint8Array(arrayBuffer)
                });
                this.visViewer().update();
            }
            this.emitEvent({
                type: "geometry-end",
                data: model
            });
        } catch (error) {
            this.emitEvent({
                type: "error",
                data: error.message || error
            });
            throw error;
        }
        return this;
    }
    async openVsfxStream(model) {
        const abortController = new AbortController;
        this._abortController = abortController;
        this.emitEvent({
            type: "geometry-start",
            data: model
        });
        this.visViewer().clear();
        this.visViewer().update();
        let isFireDatabaseChunk = false;
        try {
            await model.partialDownloadResource(model.database, abortController.signal, ((progress, value) => {
                const state = this.visViewer().parseVsfx(value);
                if (state === this.visLib().DatabaseStreamStatus.ReadyServiceData || state === this.visLib().DatabaseStreamStatus.Complete && !isFireDatabaseChunk) {
                    isFireDatabaseChunk = true;
                    this.syncOptions(this.api.options);
                    setupViewerSettings(this.visLib());
                    this.emitEvent({
                        type: "database-chunk",
                        data: value
                    });
                } else if (state === this.visLib().DatabaseStreamStatus.AwaitingObjectsData) {
                    this.emitEvent({
                        type: "geometry-chunk",
                        data: value
                    });
                }
                this.emitEvent({
                    type: "geometry-progress",
                    data: progress
                });
            }));
            this.emitEvent({
                type: "geometry-end",
                data: model
            });
        } catch (error) {
            this.emitEvent({
                type: "error",
                data: error.message || error
            });
            throw error;
        }
        return this;
    }
    async open(object) {
        this.cancel();
        let model = object;
        if (object.getModels) {
            const models = await object.getModels();
            model = models.find((model => model.default));
        }
        if (model.geometry.length === 0 && model.database.substr(-5) === ".vsfx") {
            await this.openVsfxStream(model);
        } else {
            await this._openTcsStream(model);
        }
        {
            const assembly = model.assembly;
            const lib = this.visLib();
            if (assembly) {
                const modelItr = this.visViewer().getModelIterator();
                for (;!modelItr.done(); modelItr.step()) {
                    const model = modelItr.getModel();
                    const transform = assembly.getModelTransformMatrix(model.getDatabaseHandle());
                    if (transform) {
                        const extents = model.getExtents();
                        const matrix = composingMatrixFromTransform(transform.translate, transform.rotation, transform.scale, extents.center(), new lib.Matrix3d);
                        model.setModelingMatrix(matrix, true);
                    }
                }
            }
        }
    }
    openVsfFile(binary) {
        if (!binary instanceof Uint8Array) {
            binary = new Uint8Array(binary);
        }
        this.visViewer().parseFile(binary);
        this.syncOptions(this.api.options);
        setupViewerSettings(this.visLib());
        return this;
    }
    cancel() {
        this._abortController && this._abortController.abort();
        return this;
    }
}

class Assembly {
    constructor(impl) {
        this._impl = impl;
    }
    get id() {
        return this._impl._data.id;
    }
    get name() {
        return this._impl._data.name;
    }
    set name(value) {
        this._impl._data.name = value;
    }
    get files() {
        return this._impl._data.files;
    }
    get owner() {
        return this._impl._data.owner;
    }
    get created() {
        return this._impl._data.created;
    }
    get status() {
        return this._impl._data.status;
    }
    get relatedJobs() {
        return this._impl._data.relatedJobs;
    }
    getModelTransformMatrix(handle) {
        return this._impl._data.transform[handle];
    }
    setModelTransformMatrix(handle, transform) {
        this._impl._data.transform[handle] = transform;
        return this._impl._put("", {
            transform: this._impl._data.transform
        });
    }
    getModels() {
        return this._impl.getModels().then((models => models.map((modelImpl => new Model(modelImpl, null, this)))));
    }
    getProperty(id) {
        return this._impl.getProperty(id);
    }
    getProperties() {
        return this._impl.getProperties();
    }
    delete() {
        return this._impl.delete();
    }
    downloadResource(dataId, onProgress, signal) {
        return this._impl.downloadResource(dataId, onProgress, signal);
    }
    save() {
        return this._impl.save();
    }
    getReferences() {
        return {
            fileId: "",
            references: []
        };
    }
}

class Options {
    constructor(emitter) {
        this._showFPS = false;
        this._showWCS = true;
        this._cameraAnimation = true;
        this._antialiasing = true;
        this._groundShadow = false;
        this._shadows = false;
        this._cameraAxisXSpeed = 4;
        this._cameraAxisYSpeed = 1;
        this._ambientOcclusion = false;
        this.loadFromStorage();
        this._emitter = emitter;
    }
    notifierChangeEvent() {
        if (this._emitter) {
            this.saveToStorage();
            this._emitter.emit({
                type: "changeClientOption",
                data: this
            });
        }
    }
    saveToStorage() {
        const opt = {
            showFPS: this._showFPS,
            showWCS: this._showWCS,
            cameraAnimation: this._cameraAnimation,
            antialiasing: this._antialiasing,
            groundShadow: this._groundShadow,
            shadows: this._shadows,
            cameraAxisXSpeed: this._cameraAxisXSpeed,
            cameraAxisYSpeed: this._cameraAxisYSpeed,
            ambientOcclusion: this._ambientOcclusion
        };
        localStorage.setItem("od-client-settings", JSON.stringify(opt));
    }
    loadFromStorage() {
        const jsonOpt = localStorage.getItem("od-client-settings");
        if (jsonOpt) {
            const opt = JSON.parse(jsonOpt);
            this._showFPS = opt.showFPS;
            this._showWCS = opt.showWCS;
            this._cameraAnimation = opt.cameraAnimation;
            this._antialiasing = opt.antialiasing;
            this._groundShadow = opt.groundShadow;
            this._shadows = opt.shadows;
            this._cameraAxisXSpeed = opt.cameraAxisXSpeed || 4;
            this._cameraAxisYSpeed = opt.cameraAxisYSpeed || 1;
            this._ambientOcclusion = opt.ambientOcclusion || false;
        }
    }
    get showFPS() {
        return this._showFPS;
    }
    set showFPS(value) {
        this._showFPS = value;
        this.notifierChangeEvent();
    }
    get showWCS() {
        return this._showWCS;
    }
    set showWCS(value) {
        this._showWCS = value;
        this.notifierChangeEvent();
    }
    get cameraAnimation() {
        return this._cameraAnimation;
    }
    set cameraAnimation(value) {
        this._cameraAnimation = value;
        this.notifierChangeEvent();
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(value) {
        this._antialiasing = value;
        this.notifierChangeEvent();
    }
    get groundShadow() {
        return this._groundShadow;
    }
    set groundShadow(value) {
        this._groundShadow = value;
        this.notifierChangeEvent();
    }
    get shadows() {
        return this._shadows;
    }
    set shadows(value) {
        this._shadows = value;
        this.notifierChangeEvent();
    }
    set cameraAxisXSpeed(value) {
        this._cameraAxisXSpeed = value;
        this.notifierChangeEvent();
    }
    get cameraAxisXSpeed() {
        return this._cameraAxisXSpeed;
    }
    set cameraAxisYSpeed(value) {
        this._cameraAxisYSpeed = value;
        this.notifierChangeEvent();
    }
    get cameraAxisYSpeed() {
        return this._cameraAxisYSpeed;
    }
    get ambientOcclusion() {
        return this._ambientOcclusion;
    }
    set ambientOcclusion(value) {
        this._ambientOcclusion = value;
        this.notifierChangeEvent();
    }
}

class Client {
    constructor(options) {
        this._url = options.serverUrl;
        this.user = null;
        this.eventEmitter = new EventEmitter;
        this.jobUpdater = null;
        this._options = new Options(this.eventEmitter);
    }
    get url() {
        return this._url;
    }
    get options() {
        return this._options;
    }
    createViewer(options) {
        const viewer = new Viewer(this);
        if (options.visualizeJsUrl) {
            viewer.configure({
                visualizeJsUrl: options.visualizeJsUrl
            });
        }
        return viewer.initializeAsync(options.target, options.onprogress);
    }
    configure(options) {
        this._url = options.url;
        return this;
    }
    on(name, callback) {
        this.eventEmitter.on(name, callback);
    }
    removeEventListener(name, callback) {
        this.eventEmitter.remove(name, callback);
    }
    removeAllListeners() {
        this.eventEmitter.clear();
    }
    emit(event) {
        this.eventEmitter.emit(event);
    }
    async getFileList(start, count, name, ext, ids, sortByDesc) {
        const {allSize: allSize, limit: limit, result: result, size: size} = await this.user.getFiles(start, count, name, ext, ids, sortByDesc);
        return {
            allSize: allSize,
            limit: limit,
            list: result.map((fileImpl => new File(fileImpl, this))),
            size: size,
            start: start
        };
    }
    async getFile(fileId) {
        return new File(await this.user.getFile(fileId), this);
    }
    version() {
        return json($get(`${this._url}/version`, {
            "Access-Control-Allow-Origin": "*"
        }));
    }
    async signInWithEmail(email, password) {
        const token = email + ":" + password;
        const hash = btoa(token);
        const userData = await json($get(`${this._url}/token`, {
            Authorization: "Basic " + hash,
            "Access-Control-Allow-Origin": "*"
        }));
        this.user = new UserImpl(userData, this._url, this._options);
        return new User(this.user, this);
    }
    setActiveJobUpdater(enable) {
        this.jobUpdater && this.jobUpdater.stop();
        this.jobUpdater = new JobUpdater(this.user, this);
        enable && this.jobUpdater.start();
    }
    getCurrentUser() {
        return new User(this.user, this);
    }
    async loginWithToken(token) {
        return new UserImpl({
            tokenInfo: {
                token: token
            }
        }, this._url, this._options).getUserInfo().then((userData => new UserImpl(userData, this._url, this._options))).then((user => this.user = user)).then((() => this));
    }
    async uploadFile(file, options = {
        geometry: true,
        properties: false,
        waitForDone: false
    }) {
        const fileImpl = await this.user.postFile(file, (progress => this.emit({
            type: "upload-progress",
            data: progress
        })));
        const awaiters = [];
        options.geometry && awaiters.push(fileImpl.createJob("geometry"));
        options.properties && awaiters.push(fileImpl.createJob("properties"));
        const jobs = await Promise.all(awaiters);
        if (options.waitForDone) {
            await Promise.all(jobs.map((job => job.waitForDone())));
        }
        return new File(fileImpl, this);
    }
    deleteFile(fileId) {
        return this.user.deleteFile(fileId);
    }
    downloadReferenceFile(fileId, onProgress, signal) {
        return this.user.downloadReferenceFile(fileId, onProgress, signal);
    }
    getJobs(state = null, limit = null, start = null, sortByDesc = null) {
        return this.user.getJobs(state, limit, start, sortByDesc).then((data => ({
            ...data,
            result: data.result.map((job => new Job(job, this)))
        })));
    }
    getJob(jobId) {
        return this.user.getJob(jobId).then((job => new Job(job, this)));
    }
    createJob(fileId, outputFormat) {
        return this.user.postJob(fileId, outputFormat).then((job => new Job(job, this)));
    }
    deleteJob(jobId) {
        return this.user.deleteJob(jobId);
    }
    getProjects() {
        return this.user.getProjects().then((projectsImpl => projectsImpl.map((impl => new Project(impl, this)))));
    }
    createProject(name, description, startDate, endDate, avatarUrl) {
        return this.user.createProject(name, description, startDate, endDate, avatarUrl).then((impl => new Project(impl, this)));
    }
    getProjectById(id) {
        return this.user.getProjectById(id).then((impl => new Project(impl, this)));
    }
    createAssembly(files, name) {
        return this.user.createAssembly(files, name).then((impl => new Assembly(impl)));
    }
    getAssemblyById(id) {
        return this.user.getAssemblyById(id).then((impl => new Assembly(impl)));
    }
    async getAssemblies(start, count, name, ids, sortByDesc) {
        const {allSize: allSize, limit: limit, result: result, size: size} = await this.user.getAssemblies(start, count, name, ids, sortByDesc);
        return {
            allSize: allSize,
            limit: limit,
            list: result.map((impl => new Assembly(impl, this))),
            size: size,
            start: start
        };
    }
    deleteAssembly(id) {
        return this.user.deleteAssembly(id);
    }
}

class EventEmitter {
    constructor() {
        this.subscribers = {};
    }
    clear() {
        this.subscribers = {};
    }
    emit(event) {
        if (this.subscribers[event.type]) {
            const invoke = [ ...this.subscribers[event.type] ];
            this.subscribers[event.type] = this.subscribers[event.type].filter((subscriber => !subscriber.once));
            invoke.forEach((subscriber => subscriber.callback(event)));
        }
    }
    on(type, callback) {
        !this.subscribers[type] && (this.subscribers[type] = []);
        this.subscribers[type].push({
            type: type,
            callback: callback
        });
    }
    once(type, callback) {
        !this.subscribers[type] && (this.subscribers[type] = []);
        this.onces.push({
            type: type,
            callback: callback,
            once: true
        });
    }
    remove(type, callback) {
        if (this.subscribers[type]) {
            this.subscribers[type] = this.subscribers[type].filter((subscriber => subscriber.type !== type && subscriber.callback !== callback));
        }
    }
}

const ODA = {
    createClient: async options => {
        const client = new Client(options);
        if (options.APIToken) {
            await client.loginWithToken(options.APIToken);
        }
        return client;
    }
};

export default ODA;