///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
import { json, $get } from './impl/Utils'
import { UserImpl as UserImpl } from './impl/UserImpl'
import { File } from './File'
import { User } from './User';
import { JobUpdater } from './JobUpdater'
import { Job } from './Job'

import { Viewer } from '../Viewer/Viewer'
import { Project } from './Project';
import { Assembly } from './Assembly';
import { Options } from './Options';

/**
 * Common api
 * @class
 */
export class Client {
  constructor(options) {
    this._url = options.serverUrl;
    this.user = null;
    this.eventEmitter = new EventEmitter();
    this.jobUpdater = null;
    this._options = new Options(this.eventEmitter);
  }

  /**
   * Url api
   * @type {string}
   */
  get url() { return this._url }

  /**
   * Options
   * @type {Options}
   */
  get options() { return this._options }

  /**
   * Create Viewer options
   * @typedef {Object} ViewerOptions
   * @property {HTMLCanvasElement} target
   * @property {String} [visualizeJsUrl]
   * @property {VisualizeJSProgressCallback} [onprogress = null]
   */

  /**
   * Create instance of Viewer
   * @param {ViewerOptions} options 
   * @returns {Viewer}
   */
  createViewer(options) {
    const viewer = new Viewer(this);
    if(options.visualizeJsUrl) {
      viewer.configure({ visualizeJsUrl: options.visualizeJsUrl })
    }
    return viewer.initializeAsync(
      options.target,
      options.onprogress
    )
  }

  /**
   * Api Options
   * @typedef {Object} ClientOptions
   * @property {string} url - url to Open Cloud
   */

  /**
   * Configure Client
   * @param {ClientOptions}
   * @returns {Api}
   */
  configure(options) {
    this._url = options.url
    return this
  }


  /**
   * Client initialize Callback
   *
   * @callback InitializeCallback
   * @param {ClientEvent} event - Api event
   */

  /**
   * Subscribe Client Events
   * @param {string} name 
   * @param {InitializeCallback} callback 
   */
  on(name, callback) {
    this.eventEmitter.on(name, callback)
  }

  /**
   * Unsubscribe Client Events
   * @param {string} name 
   * @param {InitializeCallback} callback 
   */
  removeEventListener(name, callback) {
    this.eventEmitter.remove(name, callback)
  }

  /**
   * Remove all api events
   */
  removeAllListeners() {
    this.eventEmitter.clear()
  }

  /**
   * Client Options
   * @typedef {Object} ClientEvent
   * @property {string} type - url to visualizeJS
   * @property {*} data - data event
   */

  emit(event) {
    this.eventEmitter.emit(event)
  }

  /**
   * @typedef FileListResult
   * @type {object}
   * @property {number} allSize
   * @property {number} limit
   * @property {File[]} list
   * @property {number} size
   * @property {number} start
   */

  /**
   * Get file list
   * @async
   * @param {number} start 
   * @param {number} count 
   * @param {string} name 
   * @param {string} ext 
   * @param {Array<string>} ids
   * @param {string} sortByDesc
   * @returns {FileListResult}
   */
  async getFileList(start, count, name, ext, ids, sortByDesc) {
    const { allSize, limit, result, size } = await this.user.getFiles(start, count, name, ext, ids, sortByDesc)
    return {
      allSize,
      limit,
      list: result.map(fileImpl => new File(fileImpl, this)),
      size,
      start
    };
  }


  /**
   * Get file by Id
   * @async
   * @param {string} fileId 
   * @returns {File}
   */
  async getFile(fileId) {
    return new File(await this.user.getFile(fileId), this)
  }

  /**
   * @typedef Version
   * @type {object}
   * @property {string} version
   * @property {string} hash
   */

  /**
   * Get version
   * @async
   * @returns {Version}
   */
  version() {
    return json($get(`${this._url}/version`, { 'Access-Control-Allow-Origin': '*' }))
  }


  /**
   * Login
   * @async
   * @param {string} email 
   * @param {string} password 
   * @returns {User}
   */
  async signInWithEmail(email, password) {
    const token = email + ':' + password;
    const hash = btoa(token);

    const userData = await json($get(`${this._url}/token`, {
      'Authorization': 'Basic ' + hash,
      'Access-Control-Allow-Origin': '*'
    }))

    this.user = new UserImpl(userData, this._url, this._options)
    //this.setActiveJobUpdater(true)

    return new User(this.user, this)
  }


  /**
   * Setting to enable | disable job updater
   * It recursively updates jobs periodically
   * @param {boolean} enable
   */
  setActiveJobUpdater(enable) {
    this.jobUpdater && this.jobUpdater.stop()
    this.jobUpdater = new JobUpdater(this.user, this);
    enable && this.jobUpdater.start()
  }


  /**
   * Get current user
   * @returns {User}
   */
  getCurrentUser() {
    return new User(this.user, this)
  }

  async loginWithToken(token) {
    return new UserImpl({
      tokenInfo: {
        token: token
      }
    }, this._url, this._options)
      .getUserInfo()
      .then(userData => new UserImpl(userData, this._url, this._options))
      .then(user => this.user = user)
      .then(() => this)
  }
  // /**
  //  * Login with raw user data
  //  * @async
  //  * @param {Object} userData 
  //  * @returns {User}
  //  */  
  // async loginFromUserData(userData) {
  //   //this.setActiveJobUpdater(true)
  //   this.user = new UserImpl(userData, this._url)
  //   return new User(this.user, this)
  // }

  /**
   * @typedef UploadFileOptions
   * @type {object}
   * @property {boolean} geometry - create job to generate geometry, default = true
   * @property {boolean} properties - create job to generate properties, default = true
   * @property {boolean} waitForDone - wait for complete geometry | properties jobs, default = false
   */

  /**
   * Upload file
   * @async
   * @param {global.File} file 
   * @param {UploadFileOptions} options
   * @returns {File}
   */
  async uploadFile(file, options = { geometry: true, properties: false, waitForDone: false }) {

    const fileImpl = await this.user.postFile(file, progress => this.emit({ type: "upload-progress", data: progress }));
    const awaiters = []

    options.geometry && awaiters.push(fileImpl.createJob("geometry"))
    options.properties && awaiters.push(fileImpl.createJob("properties"))

    const jobs = await Promise.all(awaiters)
    if (options.waitForDone) {
      await Promise.all(jobs.map(job => job.waitForDone()))
    }
    return new File(fileImpl, this);
  }

  /**
   * Delete file
   * @async
   * @param {string} fileId - file Id
   * @returns {Object} - result
   */
  deleteFile(fileId) {
    return this.user.deleteFile(fileId)
  }

  /**
   * Download file reference
   * @async
   * @param {string} fileId - file Id
   * @param {string} onProgress - onprogress callback
   * @param {AbortSignal} signal - signal for cancellation
   * @returns {ArrayBuffer} - binary data
   */
  downloadReferenceFile(fileId, onProgress, signal) {
    return this.user.downloadReferenceFile(fileId, onProgress, signal)
  }


  /**
   * @typedef JobsResult
   * @type {object}
   * @property {Job[]} result - Array of jobs
   * @property {Number} start - create job to generate geometry, default = true
   * @property {Number} limit - create job to generate properties, default = true
   * @property {Number} allSize - wait for complete geometry | properties jobs, default = false
   * @property {Number} size - wait for complete geometry | properties jobs, default = false
   */

  /**
   * Get lob list with specified filter
   * @async
   * @param {string} state - filter, default = null
   * @param {Number} limit - limit for response, default = null
   * @param {Number} start - offset of response, default = null
   * @param {Number} sortByDesc - sort by desc createdAt, default = null
   * @returns {JobsResult} - JobsResult
   */
  getJobs(state = null, limit = null, start = null, sortByDesc = null) {
    return this.user.getJobs(state, limit, start, sortByDesc)
      .then(data => ({ ...data, result: data.result.map(job => new Job(job, this)) }))
  }

  /**
   * Get job by id
   * @async
   * @param {string} jobId - jobId
   * @returns {Job} - Job
   */
  getJob(jobId) {
    return this.user.getJob(jobId).then(job => new Job(job, this))
  }

  /**
   * Create Job for file
   * @async
   * @param {string} fileId - File id
   * @param {string} outputFormat - Output format
   * @returns {Job} - Job
   */
  createJob(fileId, outputFormat) {
    return this.user.postJob(fileId, outputFormat).then(job => new Job(job, this))
  }


  /**
   * Delete job
   * @async
   * @param {string} jobId - Job Id
   * @returns {Object} - Result
   */
  deleteJob(jobId) {
    return this.user.deleteJob(jobId)
  }

  /**
   * Get projects 
   * @async
   * @returns {Array<Project>}
   */
  getProjects() {
    return this.user.getProjects().then(projectsImpl => projectsImpl.map(impl => new Project(impl, this)))
  }

  /**
   * Create new projects
   * @async
   * @param {string} name - project name
   * @param {string} description - project description
   * @param {Date} startDate - start project date
   * @param {Date} endDate - end project date
   * @param {string} avatarUrl - base64 image project preview
   * @returns {Project}
   */
  createProject(name, description, startDate, endDate, avatarUrl) {
    return this.user.createProject(name, description, startDate, endDate, avatarUrl).then(impl => new Project(impl, this))
  }

  /**
   * Get project by id 
   * @async
   * @param {string} id - project id
   * @returns {Project}
   */
  getProjectById(id) {
    return this.user.getProjectById(id).then(impl => new Project(impl, this))
  }

  /**
   * Create new assembly
   * @async
   * @param {Array<string>} files - list file ids
   * @param {string} name - assembly name
   * @returns {Assembly}
   */
  createAssembly(files, name) {
    return this.user.createAssembly(files, name).then(impl => new Assembly(impl))
  }

  /**
   * Get assembly by id
   * @async
   * @param {string} id - assembly id
   * @returns {Assembly}
   */
  getAssemblyById(id) {
    return this.user.getAssemblyById(id).then(impl => new Assembly(impl))
  }

  /**
   * @typedef AssemblyListResult
   * @type {object}
   * @property {number} allSize
   * @property {number} limit
   * @property {Assembly[]} result
   * @property {number} size
   * @property {number} start
   */

  /**
   * Get file list
   * @async
   * @param {number} start 
   * @param {number} count 
   * @param {string} name 
   * @param {Array<string>} ids
   * @param {string} sortByDesc 
   * @returns {AssemblyListResult}
   */
  async getAssemblies(start, count, name, ids, sortByDesc) {
    const { allSize, limit, result, size } = await this.user.getAssemblies(start, count, name, ids, sortByDesc)
    return {
      allSize,
      limit,
      list: result.map(impl => new Assembly(impl, this)),
      size,
      start
    };
  }

  /**
   * Delete job
   * @async
   * @param {string} id - assembly Id
   * @returns {Object} - Result
   */
  deleteAssembly(id) {
    return this.user.deleteAssembly(id)
  }
}

class EventEmitter {
  constructor() {
    this.subscribers = {}
  }


  clear() { this.subscribers = {} }

  emit(event) {
    if (this.subscribers[event.type]) {
      const invoke = [...this.subscribers[event.type]]
      this.subscribers[event.type] = this.subscribers[event.type].filter(subscriber => !subscriber.once)
      invoke.forEach(subscriber => subscriber.callback(event))
    }
  }

  on(type, callback) {
    !this.subscribers[type] && (this.subscribers[type] = [])
    this.subscribers[type].push({ type, callback })
  }

  once(type, callback) {
    !this.subscribers[type] && (this.subscribers[type] = [])
    this.onces.push({ type, callback, once: true })
  }

  remove(type, callback) {
    if (this.subscribers[type]) {
      this.subscribers[type] = this.subscribers[type].filter(subscriber => subscriber.type !== type && subscriber.callback !== callback)
    }
  }
}
