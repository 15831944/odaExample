///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
import { json, normalizePath, arrayBuffer, downloadProgress, text } from './Utils'
import { MarkupImpl } from './MarkupImpl';
import { ModelImpl } from './ModelImpl';
/* eslint no-unused-vars: off */
export class FileImpl {

  constructor(fileInfo, user) {
    this.fileInfo = fileInfo;
    this.user = user
  }
  get id() { return this.fileInfo.id }
  /**
  * File operation api
  * */

  get(relativePath, signal) {
    const path = normalizePath(relativePath)
    return this.user.get(`/files/${this.id}${path}`, signal)
  }

  post(relativePath, body) {
    const path = normalizePath(relativePath)
    return this.user.post(`/files/${this.id}${path}`, body)
  }

  put(relativePath, body) {
    const path = normalizePath(relativePath)
    return this.user.put(`/files/${this.id}${path}`, body)
  }

  delete(relativePath, body) {
    const path = normalizePath(relativePath)
    return this.user.delete(`/files/${this.id}${path}`, body)
  }

  //Get object properties for specific file
  getProperties() {
    return json(this.get(`/properties`))
  }

  //Get object properties for specific file
  getProperty(id) {
    return json(this.get(`/properties?handle=${id}`))
  }


  //Get geometry metadata for specific file
  getModels() {
    return json(this.get(`/geometry`))
      .then(models => models.map(data => new ModelImpl(data, this)))

  }

  //Add geometry metadata for specific file
  postMetadata(metadata) {
    return json(this.post(`/geometry`, metadata))
  }

  //Upload file for downloads
  postFileDownloads(file, onProgress) {
    //todo: Check description
    const data = new FormData();
    data.append('file', file);
    return json(this.post(`/downloads`, data))
  }

  //Download file
  downloadFile() {
    return arrayBuffer(this.get(`/downloads`))
  }

  //Download file resource
  downloadResource(dataId, onProgress, signal) {
    return this.get(`/downloads/${dataId}`, signal)
      .then(response => downloadProgress(response, onProgress))
      .then(response => response.arrayBuffer())
  }

  async partialDownloadResource(dataId, signal, onProgress)
  {
    const path = normalizePath(`/files/${this.id}/downloads/${dataId}`)
    
    const response = await fetch(`${this.user.url}${path}`, {
      headers: this.user.headers, signal: signal
    })
    const contentLength = response.headers.get('content-length')
    const total = parseInt(contentLength, 10)

    let loaded = 0;

    const reader = response.body.getReader()
    let condition = true
    while (condition) 
    {
      const {done, value} = await reader.read()
      
      if (done) {
        break
      }

      loaded += value.byteLength

      onProgress(loaded/total, value)
    }
  }

  //Show file info
  getFileInfo() {
    return json(this.get(`/`))
  }

  //Update file(name and preview)
  putFile(fileInfo) {
    return json(this.put(`/`, fileInfo))
  }

  //Remove file
  deleteFile() {
    return this.user.deleteFile(this.id)
  }

  //Get all markups for file
  getMarkupList() {
    return json(this.get(`/markup`))
      .then(list => list.result.map(data => new MarkupImpl(data, this)))
  }

  // Add markup to file
  postMarkup(markup) {
    return json(this.post(`/markup/`, markup))
  }

  // Delete markup by id
  deleteMarkup(markupId) {
    return json(this.delete(`/markup/${markupId}`))
  }

  // Get markup by id
  getMarkup(markupId) {
    return json(this.get(`/markup/${markupId}`))
  }

  // Create new Job
  createJob(outputFormat) {
    return this.user.postJob(this.id, outputFormat)
  }

  getReferences() {
    return json(this.get(`/references`))
  }

  putReferences(object) {
    return json(this.put(`/references`, object))
  }

  downloadReferenceFile(onProgress, signal)  {
    return arrayBuffer(this.user.downloadReferenceFile(this.id, onProgress, signal))
  }


  // Get all viewpoint for file
  getViewPoints() {
    return json(this.get(`/viewpoints`))
      .then(list => list.result)
  }

  // Add viewpoint for file
  postViewpoint(data) {
    return json(this.post(`/viewpoints`, data))
  }

  // Get viewpoint by guid
  getViewpoint(guid) {
    return json(this.get(`/viewpoints/${guid}`))
  }

  // Delete viewpoint by guid
  deleteViewpoint(guid) {
    return json(this.delete(`/viewpoints/${guid}`))
  }

  // Get snapshot data for view point by guid
  getSnapshot(guid) {
    return text(this.get(`/viewpoints/${guid}/snapshot`))
  }

  // Get snapshot data for view point by guid
  getSnapshotData(guid, bitmapGuid) {
    return text(this.get(`/viewpoints/${guid}/bitmaps/${bitmapGuid}`))
  }

}