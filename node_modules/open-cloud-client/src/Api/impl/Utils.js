///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
export function json(request) {
  return request.then(response => response.json())
}

export function text(request) {
  return request.then(response => response.text())
}

export function arrayBuffer(request) {
  return request.then(response => response.arrayBuffer())
}

export function options(method, headers, body, signal) {
  const opt =  {
    method,
    headers,
    body
  }
  signal && (opt.signal = signal)
  return opt
}

function catchHttpError(status) {
  return status > 400 ? Promise.reject(status): Promise.resolve()
  
}
function catchHttFetchError(request) {
  return request
  .then(response => {
    return catchHttpError(response.status)
     .then(() => request, () => response.json().then(json => Promise.reject(new Error(json.description))))
  })
}

export function $get(url, headers, signal) {
  return catchHttFetchError(fetch(url, options("GET", headers, null, signal)))
}
export function $put(url, headers, body) {
  if (typeof (body) === 'object') {
    if (body instanceof FormData) {
      //headers = { ...headers, 'Content-Type': 'multipart/form-data' }
    } else if (!(body instanceof ArrayBuffer) && !(body instanceof Blob)) {
      body = JSON.stringify(body)
      headers = { ...headers, 'Content-Type': 'application/json' }
    }
  } else {
    headers = { ...headers, 'Content-Type': 'application/json' }
  }
  headers = { ...headers, 'Access-Control-Allow-Origin': '*', 'pragma': 'no-cache', 'cache-control': 'no-cache' }

  return catchHttFetchError(fetch(url, options("PUT", headers, body)))
}

// json || object 'content-type': 'application/json'
// FormData 'Content-Type': 'multipart/form-data'
export function $post(url, headers, body) {
  if (typeof (body) === 'object') {
    if (body instanceof FormData) {
      //headers = { ...headers, 'Content-Type': 'multipart/form-data' }
    } else if (!(body instanceof ArrayBuffer) && !(body instanceof Blob)) {
      body = JSON.stringify(body)
      headers = { ...headers, 'Content-Type': 'application/json' }
    }
  } else {
    headers = { ...headers, 'Content-Type': 'application/json' }
  }
  headers = { ...headers, 'Access-Control-Allow-Origin': '*', 'pragma': 'no-cache', 'cache-control': 'no-cache' }
  return catchHttFetchError(fetch(url, options("POST", headers, body)))
}

export function $delete(url, headers, body) {
  return catchHttFetchError(fetch(url, options("DELETE", headers, body)))
}

export function streamProgress(stream, onprogress) {
  const reader = stream.getReader();
  let current = 0;

  reader.read().then(calc).catch(console.error)

  function calc(ev) {
    if (!ev.done) {
      reader.read().then(calc).catch(console.error)
    }
    ev.value && (current += ev.value.length)
    onprogress(current)
  }
  return stream
}

export function downloadProgress(response, onprogress) {
  const total = response.headers.get("Content-Length")
  const tee = response.body.tee()
  streamProgress(tee[0], bytesCount => onprogress && onprogress(bytesCount / total))
  return new Response(tee[1])
}

/* eslint no-unused-vars: off */
export function $XMLHttp(url, {
  headers,
  method,
  body,
  uploadProgress,
  downloadProgress
}) {

      /* eslint no-unused-vars: off */
  function getDescription(text) {
    try{
      return JSON.parse(text).description
    }
    catch {
      return text
    }
  }

  return new Promise((resolve, reject) => {
    const req = new XMLHttpRequest();
    req.open(method, url, true);
    for (var key in headers) {
      req.setRequestHeader(key, headers[key]);
    }
    function calcProgress(ev) {
      return ev.lengthComputable ? ev.loaded / ev.total : 1
    }
    req.upload.onprogress = ev => uploadProgress && uploadProgress(calcProgress(ev))
    req.onprogress = ev => downloadProgress && downloadProgress(calcProgress(ev))

    req.onloadend = ev => catchHttpError(req.status).then(() => resolve(req), ()=> reject(new Error(getDescription(ev.target.responseText))))
    req.onerror = ev => reject(ev)
    req.send(body);
  });
}

export function waitFor(func, options = { timeout: 600000, interval: 3000 }) {
  return new Promise((resolve, reject) => {
    let elapsed = 0
    const id = setInterval(() => {
      if(func()){
        clearInterval(id);
        resolve();
      }
      elapsed += options.interval
      if(elapsed >= options.timeout) {
        reject();
        clearInterval(id);
      }
    }, options.interval)
  })
}

export function normalizePath(path) {
  return path.replace(/^\/*/,"/")
}
