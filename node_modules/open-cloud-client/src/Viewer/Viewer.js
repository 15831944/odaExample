import { EventEmitter, loadVisualizeJS, composingMatrixFromTransform } from './utils'

import { OdPanDragger } from './Draggers/OdPanDragger'
import { OdOrbitDragger } from './Draggers/OdOrbitDragger'
import { OdZoomDragger } from './Draggers/OdZoomDragger'
import { OdZoomWindowDragger } from './Draggers/OdZoomWindowDragger'
import { OrbitAroundBuildingDragger } from './Draggers/OrbitAroundBuildingDragger'
import { OdZoomWheelDragger } from './Draggers/OdZoomWheelDragger'
import { MeasureLineDragger } from './Draggers/MeasureLineDragger'
import { OdCuttingPlaneXAxisDragger } from './Draggers/OdCuttingPlaneXAxisDragger'
import { OdCuttingPlaneYAxisDragger } from './Draggers/OdCuttingPlaneYAxisDragger'
import { OdCuttingPlaneZAxisDragger } from './Draggers/OdCuttingPlaneZAxisDragger'
import { OdaLineDragger } from './Draggers/OdaLineDragger'
import { OdaTextDragger } from './Draggers/OdaTextDragger'
import { OdaWalkDragger } from './Draggers/OdaWalkDragger'


import { setupViewerSettings } from './defaultSettings'

/**
 * Client viewer class
 * There are many instances may be in project
 * @class
 */
export class Viewer {

  /**
 * Viewer Options
 * @typedef {Object} ViewerOptions
 * @property {string} visualizeJsUrl - url to visualizeJS
 */

  /**
   * @constructor
   * @param {Viewer} api 
   */
  constructor(api) {
    this.api = api

    this._changeClientOptionCb = (event) => {
      const opt = event.data;
      this.syncOptions(opt)
    }

    this.api.eventEmitter.on('changeClientOption', this._changeClientOptionCb)

    /**
     * @type {ViewerOptions}
     */
    this.opt = { visualizeJsUrl: "VISUALIZE_JS_URL" }
    this._activeDragger = null
    this.visualizeJs = null;

    /**
     * @type {EventEmitter}
     */
    this.eventEmitter = new EventEmitter()

    /**
     * Dragger factory
     * @type {Map}
     * @example draggerFactory.set("Line", OdaLineDragger);
     */
    this.draggerFactory = new Map();
    this.draggerFactory.set("Line", OdaLineDragger);
    this.draggerFactory.set("Text", OdaTextDragger);
    this.draggerFactory.set("Pan", OdPanDragger);
    this.draggerFactory.set("Orbit", OdOrbitDragger);
    this.draggerFactory.set("Zoom", OdZoomDragger);
    this.draggerFactory.set("ZoomWindow", OdZoomWindowDragger);
    this.draggerFactory.set("OrbitAroundBuilding", OrbitAroundBuildingDragger);
    this.draggerFactory.set("MeasureLine", MeasureLineDragger);
    this.draggerFactory.set("CuttingPlaneXAxis", OdCuttingPlaneXAxisDragger);
    this.draggerFactory.set("CuttingPlaneYAxis", OdCuttingPlaneYAxisDragger);
    this.draggerFactory.set("CuttingPlaneZAxis", OdCuttingPlaneZAxisDragger);
    this.draggerFactory.set("Walk", OdaWalkDragger);

    this.render = () => {
      this.frameId = requestAnimationFrame(this.render)
      this.visViewer().update()
    }
  }

  syncOptions(opt)
  {
    const viewer = this.visViewer()
    if (viewer)
    {
      if (opt.showFPS !== viewer.getEnableFPS())
      {
        viewer.setEnableFPS(opt.showFPS);
      }

      if (opt.showWCS !== viewer.getEnableWCS())
      {
        viewer.setEnableWCS(opt.showWCS);
      }

      if (opt.cameraAnimation !== viewer.getEnableAnimation())
      {
        viewer.setEnableAnimation(opt.cameraAnimation);
      }

      if (opt.antialiasing !== viewer.fxaaAntiAliasing3d)
      {
        viewer.fxaaAntiAliasing3d = opt.antialiasing;
        viewer.fxaaQuality = 5;
      }

      if (opt.groundShadow !== viewer.groundShadow)
      {
        viewer.groundShadow = opt.groundShadow;
      }

      if (opt.shadows !== viewer.shadows)
      {
        viewer.shadows = opt.shadows;
        const canvas = this.visLib().canvas;
        const device = viewer.getActiveDevice();
        device.invalidate([0, canvas.clientWidth, canvas.clientHeight, 0]);
        device.delete();
      }

      const lib = this.visLib()
      const device = viewer.getActiveDevice();
      if (opt.ambientOcclusion !== device.getOptionBool(lib.DeviceOptions.kSSAOEnable))
      {
      

        device.setOptionBool(lib.DeviceOptions.kSSAOEnable, opt.ambientOcclusion);
        device.setOptionBool(lib.DeviceOptions.kSSAODynamicRadius, true);
        device.setOptionDouble(lib.DeviceOptions.kSSAORadius, 1.);
        device.setOptionInt32(lib.DeviceOptions.kSSAOLoops, 32);
        device.setOptionDouble(lib.DeviceOptions.kSSAOPower, 2.);
        device.setOptionInt32(lib.DeviceOptions.kSSAOBlurRadius, 2);

        const avp = viewer.activeView;
        avp.setSSAOEnabled(opt.ambientOcclusion);
        avp.delete();
      }
      device.delete();
    }
  }

  _setEnableForZoomWheelDragger(enable) {
    if (enable && !this.wheelZoomDragger) {
      this.wheelZoomDragger = new OdZoomWheelDragger(this)
    } else {
      this.wheelZoomDragger && this.wheelZoomDragger.dispose()
      this.wheelZoomDragger = null;
    }
  }

  /**
   * Configure Viewer
   * @param {ViewerOptions}
   * @returns {Viewer}
   */
  configure(opt) {
    this.opt = opt
    return this
  }

  /**
   * Viewer initialize Callback
   *
   * @callback VisualizeJSProgressCallback
   * @param {Viewer} 
   */

  /**
   * Intialize VisualizeJS with particular canvas
   * @param {HTMLCanvasElement}
   * @param {VisualizeJSProgressCallback} [onprogress = null] - The callback that handles the response.
   * @async
   */
  initializeAsync(canvas, onprogress = null) {
    if (canvas.style.width === '' && canvas.style.height === '') 
    {
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    }

    return loadVisualizeJS(this.opt.visualizeJsUrl,
      ev => {
        const { loaded, timeStamp, total, lengthComputable } = ev
        const event = { loaded, timeStamp, total, lengthComputable, type: "visualize-progress" }
        onprogress && onprogress(event)
      }
    )
      .then(visualizeJs => this.visualizeJs = visualizeJs)
      .then(() => {
        canvas.width = canvas.clientWidth * window.devicePixelRatio;
        canvas.height = canvas.clientHeight * window.devicePixelRatio;
        this.visualizeJs.canvas = canvas
        this.visualizeJs.Viewer.create()

      })
      .then(() => {
        this.syncOptions(this.api.options)

        this.eventEmitter.attach(this.visualizeJs.canvas, "mousemove")
        this.eventEmitter.attach(this.visualizeJs.canvas, "mousedown")
        this.eventEmitter.attach(this.visualizeJs.canvas, "mouseup")
        this.eventEmitter.attach(this.visualizeJs.canvas, "mouseleave")
        this.eventEmitter.attach(this.visualizeJs.canvas, "click")
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchstart")
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchend")
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchcancel")
        this.eventEmitter.attach(this.visualizeJs.canvas, "touchmove")
        this.eventEmitter.attach(this.visualizeJs.canvas, "dblclick")
        this.eventEmitter.attach(this.visualizeJs.canvas, "wheel")

        this.eventEmitter.attach(window, "resize")

        this.wheelZoomDragger = new OdZoomWheelDragger(this)

        this.eventEmitter.addEventListener("resize", ev => {
          const { clientWidth, clientHeight } = canvas
          canvas.height = clientHeight * window.devicePixelRatio
          canvas.width = clientWidth * window.devicePixelRatio

          this.visViewer().resize(0, canvas.width, canvas.height, 0)
          if (this.activeDragger() && this.activeDragger().updatePreview)
          {
            this.activeDragger().updatePreview()
          }
        })
      })
      .then(() => this.render())
      .then(() => Promise.resolve(this))
  }

  /**
   * Keys for available draggers in dragger factory
   * @property {string[]}
   */
  get draggers() {
    return [...this.draggerFactory.keys()]
  }

  /**
   * @function
   * @returns {(string | null)} - Current active dragger name
   */
  activeDragger() {
    return this._activeDragger
  }

  /**
  * Set active dragger
  * @function
  * @param {string}
  */
  setActiveDragger(name) {
    const Constructor = this.draggerFactory.get(name)
    if (!(this._activeDragger instanceof Constructor)) {
      this._activeDragger && this._activeDragger.dispose()
      this._activeDragger = null
      this._activeDragger = new Constructor(this)
    }
  }

  /**
  * Get visualizeJS lib
  * @function
  * @returns {Object}
  */
  visLib() {
    return this.visualizeJs
  }

  /**
 * Get visualizeJS viewer instance
 * @function
 * @returns {Object}
 */
  visViewer() {
    return this.visualizeJs.getViewer()
  }

  /**
  * Clear slices | cutting planes
  * @function
  */
  clearSlices() {
    const avp = this.visViewer().activeView
    avp.removeCuttingPlanes();
    avp.delete();
  }

  /**
   * Clear markup
   * @function
   */
  clearOverlay() {
    const markupCtrl = this.visViewer().getMarkupController();
    markupCtrl.clear();
    markupCtrl.delete();
  }

  /**
   * Is current drawing 3d 
   * @function
   * @returns {boolean}
   */
  is3D() {
    const ext = this.visViewer().getActiveExtents()
    const min = ext.min()
    const max = ext.max()
    const extHeight = max[2] - min[2]
    const is3D = extHeight !== 0
    return is3D
    //return this.visViewer().activeView.upVector[1] >= 0.95;
  }

  /**
   * Destructor for this Viewer, releases all resources and unsubscribe all events
   * @function
   * @returns {boolean}
   */
  dispose() {
    if (this.visLib()) {
      if (this.activeDragger()) {
        this.activeDragger().dispose()
      }
      this.visViewer().clear()
    }

    cancelAnimationFrame(this.frameId)
    this.eventEmitter.detach(this.visualizeJs.canvas, "mousemove")
    this.eventEmitter.detach(this.visualizeJs.canvas, "mousedown")
    this.eventEmitter.detach(this.visualizeJs.canvas, "mouseup")
    this.eventEmitter.detach(this.visualizeJs.canvas, "mouseleave")
    this.eventEmitter.detach(this.visualizeJs.canvas, "click")
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchstart")
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchend")
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchcancel")
    this.eventEmitter.detach(this.visualizeJs.canvas, "touchmove")
    this.eventEmitter.detach(this.visualizeJs.canvas, "dblclick")
    this.eventEmitter.detach(this.visualizeJs.canvas, "wheel")
    this.eventEmitter.detach(window, "resize")

    this.eventEmitter.removeEventListener()
    this.wheelZoomDragger.dispose()

    this._abortController && this._abortController.abort()
    this.api.eventEmitter.remove('changeClientOption', this._changeClientOptionCb)
  }

  /**
   * Provide subscribe to event emitter
   * @function
   * @param {string} name - Event type
   * @param {function} - Callback for event
   */
  addEventListener(name, cb) {
    this.eventEmitter.addEventListener(name, cb)
  }

  /**
   * Provide unsubscribe from event emitter
   * @function
   * @param {string} name - Event type
   * @param {function} - Callback for event
   */
  removeEventListener(name, cb) {
    this.eventEmitter.removeEventListener(name, cb)

  }

  /**
 * Provide emit event to event emitter
 * @function
 * @param {EventObject} event - Event object
 */
  emitEvent(event) {
    this.eventEmitter.emitEvent(event)
  }

  /**
   * Returns array of currently selected objects
   * @function
   * @returns {Object[]}
   */
  getSelected() {
    const result = []
    const selectionSet = this.visViewer().getSelected()
    if (!selectionSet.isNull()) {

      const itr = selectionSet.getIterator()
      while (!itr.done()) {
        const entityId = itr.getEntity()
        const entityPtr = entityId.openObject()
        const nativeHandle = entityPtr.getNativeDatabaseHandle()
        result.push(nativeHandle)
        entityPtr.delete()
        entityId.delete()
        itr.step()
      }
      itr.delete()
    }
    selectionSet.delete()
    return result
  }

  /**
   * Load references like images, fonts, other files to view model correctly
   * @function
   * @async
   * @param {Model} model - model 
   * @returns {Promise}
   */
  async loadReferences(model) {
    let refs = [];
    try {
      const refsData = await model.getReferences();
      refs = refsData.references;
    } catch {
      //ignore
    }

    if (!this.visLib()) {
      throw new Error("VisualizeJS module is null when try load references");
    }

    if (!this.visViewer()) {
      throw new Error("VisualizeJS module getViewer return null, pls create viewer before load reference");
    }


    for (let refItem of refs) {
      const buffer = await this.api.downloadReferenceFile(refItem.id);
      this.visViewer().addEmbeddedFile(refItem.name, new Uint8Array(buffer));
    }
  }

  async _openTcsStream(model) 
  {
    const abortController = new AbortController();
    this._abortController = abortController;

    const listFileForDownload = [model.database, ...model.geometry];
    const chunksProgress = listFileForDownload.map(() => 0)

    const calcProgress = (index, progress) => {
      chunksProgress[index] = progress
      const fileProgress = chunksProgress.reduce((acc, progress) => acc += progress) / (chunksProgress.length || 1)
      this.emitEvent({ type: 'geometry-progress', data: fileProgress })
    }

    this.emitEvent({ type: "geometry-start", data: model })

    this.visViewer().clear()
    this.visViewer().update()

    try {

      for (let i = 0; i < listFileForDownload.length; i++) {

        const chunk = listFileForDownload[i]
        const arrayBuffer = await model.downloadResource(chunk, progress => calcProgress(i, progress), abortController.signal)

        if (abortController.signal.aborted) {
          await Promise.reject(new Error(`Open model aborted  ${model.name}`))
        }

        this.visViewer().parseStream(new Uint8Array(arrayBuffer))
        if (i == 0) {
          this.syncOptions(this.api.options)
          setupViewerSettings(this.visLib())
        }
        
        this.emitEvent({
          type: i == 0 ? 'database-chunk' : 'geometry-chunk',
          data: new Uint8Array(arrayBuffer)
        })

        this.visViewer().update()
      }
      this.emitEvent({ type: "geometry-end", data: model })

    } catch (error) {
      this.emitEvent({ type: "error", data: error.message || error })
      throw error
    }
    return this
  }

  async openVsfxStream(model)
  {
    const abortController = new AbortController();
    this._abortController = abortController;

    this.emitEvent({ type: "geometry-start", data: model })
    this.visViewer().clear()
    this.visViewer().update()
    let isFireDatabaseChunk = false;
    try 
    {
      await model.partialDownloadResource(model.database,
        abortController.signal,
        (progress, value) => {
          const state = this.visViewer().parseVsfx(value)
          if (state === this.visLib().DatabaseStreamStatus.ReadyServiceData ||
              state === this.visLib().DatabaseStreamStatus.Complete && !isFireDatabaseChunk)
          {
            isFireDatabaseChunk = true;
            this.syncOptions(this.api.options)
            setupViewerSettings(this.visLib())
            this.emitEvent({ type: 'database-chunk', data: value })
          }
          else if (state === this.visLib().DatabaseStreamStatus.AwaitingObjectsData)
          {
            this.emitEvent({ type: 'geometry-chunk', data: value  })
          }
          this.emitEvent({ type: 'geometry-progress', data: progress })

      })
      this.emitEvent({ type: "geometry-end", data: model })
    } 
    catch (error)
    {
      this.emitEvent({ type: "error", data: error.message || error })
      throw error
    }
    return this
  }

  /**
   * Open file or model
   * @function
   * @async
   * @param {(Model|File)} model - model 
   * @returns {Promise}
   */
  async open(object) {
    this.cancel();

    let model = object
    if (object.getModels) {
      const models = await object.getModels()
      model = models.find(model => model.default)
    }

    if (model.geometry.length === 0 && model.database.substr(-5) === '.vsfx')
    {
      await this.openVsfxStream(model)
    }
    else
    {
      await this._openTcsStream(model)
    }

    {
      const assembly = model.assembly;
      const lib = this.visLib();
      if (assembly)
      {
        const modelItr = this.visViewer().getModelIterator();
        for (; !modelItr.done(); modelItr.step())
        {
          const model = modelItr.getModel();
          const transform = assembly.getModelTransformMatrix(model.getDatabaseHandle());
          if (transform)
          {
            const extents = model.getExtents();
            const matrix = composingMatrixFromTransform(
              transform.translate, 
              transform.rotation, 
              transform.scale, 
              extents.center(), 
              new lib.Matrix3d());

            model.setModelingMatrix(matrix, true);
          }
        }
      }
    }
  }

  /**
   * Open file or model
   * @function
   * @param {(Uint8Array|ArrayBuffer)} binary - data of .vsf file
   * @returns {Viewer}
   */
  openVsfFile(binary) {
    if (!binary instanceof Uint8Array) {
      binary = new Uint8Array(binary)
    }
    this.visViewer().parseFile(binary)
    this.syncOptions(this.api.options)
    setupViewerSettings(this.visLib())
    return this
  }

  /**
 * Cancel asynchronous open model | file
 * @function
 * @returns {Viewer}
 */
  cancel() {
    this._abortController && this._abortController.abort()
    return this
  }

}