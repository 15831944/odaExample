///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
/* eslint-disable no-unused-vars */
import { OdBaseDragger } from './Common/OdBaseDragger.js';

export class OdOrbitDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args)
    this.press = false;

    this.getViewer().setEnableAutoSelect(true);
  }

  start(x, y) {
    this.press = true;

    this.m_viewCenter = this.getCenter();
    this.m_startPoint = {x: x, y: y};

    const view = this.getViewer().activeView;

    this.startCameraParams = {
      position        : view.viewPosition,
      target          : view.viewTarget,
      upVector        : view.upVector,
      viewFieldWidth  : view.viewFieldWidth,
      viewFieldHeight : view.viewFieldHeight,
      perspective     : view.perspective
    }

    view.delete();
    this.beginInteractivity();
  }

  setDefaultViewParams() {
    const extView = this.getViewer().getActiveTvExtendedView();
    extView.setView(
      this.startCameraParams.position,
      this.startCameraParams.target,
      this.startCameraParams.upVector,
      this.startCameraParams.viewFieldWidth,
      this.startCameraParams.viewFieldHeight,
      this.startCameraParams.perspective
    );
    extView.delete();
  }

  getSideVector(viewParams) {
    const pUpV = this.toVector(viewParams.upVector);
    const pTarget = this.toPoint(viewParams.target);
    const pPosition = this.toPoint(viewParams.position)

    const direct = pTarget.sub(pPosition);
    const vDirect = direct.asVector();

    const vCross = pUpV.crossProduct(vDirect);
    const sideVector = vCross.normalize();

    this.deleteAll([direct, pUpV, pTarget, pPosition, vDirect, vCross])

    return sideVector;
  }

  calculateXOrbit(viewParams, delta, sideVector) {
    {
      const pPoint = this.toPoint(viewParams.position);
      const pCenter = this.toPoint(this.m_viewCenter);

      const rotatePoint = pPoint.rotateByBasePoint(delta, sideVector, pCenter)
      viewParams.position = rotatePoint.toArray();

      this.deleteAll([pPoint, pCenter, rotatePoint])
    }

    {
      const pTarget = this.toPoint(viewParams.target);
      const pCenter = this.toPoint(this.m_viewCenter);

      const rotatePoint = pTarget.rotateByBasePoint(delta, sideVector, pCenter)
      viewParams.target = rotatePoint.toArray();

      this.deleteAll([pTarget, pCenter, rotatePoint]);
    }

    {
      const pPoint = this.toPoint(viewParams.position);
      const pTarget = this.toPoint(viewParams.target);
      const pCenter = this.toPoint(this.m_viewCenter);

      const pUp = pTarget.sub(pPoint);
      const vUp = pUp.asVector();

      const crossProduct = vUp.crossProduct(sideVector);
      const crossProductNormal = crossProduct.normalize();
      
      viewParams.upVector = crossProductNormal.toArray();

      this.deleteAll([pPoint, pTarget, pCenter, pUp, vUp, crossProduct, crossProductNormal]);
    }
  }

  calculateYOrbit(viewParams, delta, sideVector)
  {
    {
      const pPoint = this.toPoint(viewParams.position);
      const pCenter = this.toPoint(this.m_viewCenter);

      const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);

      const rotatePoint = pPoint.rotateByBasePoint(delta, zAxis, pCenter)
      viewParams.position = rotatePoint.toArray();

      this.deleteAll([zAxis, pPoint, pCenter, rotatePoint]);
    }

    {
      const pTarget = this.toPoint(viewParams.target);
      const pCenter = this.toPoint(this.m_viewCenter);

      const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);

      const rotatePoint = pTarget.rotateByBasePoint(delta, zAxis, pCenter)
      viewParams.target = rotatePoint.toArray();

      this.deleteAll([zAxis, pTarget, pCenter, rotatePoint]);
    }

    {
      const zAxis = this.toVector(this.m_module.Vector3d.kZAxis);
      const pTarget = this.toPoint(viewParams.target);
      const pPoint = this.toPoint(viewParams.position);

      const side = sideVector.rotateBy(delta, zAxis);

      const pUp = pTarget.sub(pPoint);
      const vUp = pUp.asVector();

      const cross = vUp.crossProduct(side);
      const crossNormal = cross.normalize();

      viewParams.upVector = crossNormal.toArray();

      this.deleteAll([zAxis, pTarget, pPoint, side, pUp, vUp, cross, crossNormal]);
    }
    
  }

  drag(x, y, dltX, dltY) {
    if (this.press) {
      const view = this.getViewer().activeView;

      const corners = view.vportRect;

      const size = Math.max(
        Math.abs(corners[2] - corners[0]),
        Math.abs(corners[3] - corners[1]));

      const distX = (this.m_startPoint.x - x) * Math.PI / size;
      const distY = (this.m_startPoint.y - y) * Math.PI / size;

      this.m_startPoint.x = x;
      this.m_startPoint.y = y;

      const xOrbit = distY;
      const yOrbit = distX;

      const viewParams = {
        position: view.viewPosition,
        target: view.viewTarget,
        upVector: view.upVector,
        viewFieldWidth: view.viewFieldWidth,
        viewFieldHeight: view.viewFieldHeight,
        perspective: view.perspective
      }

      view.delete();

      const sideVector = this.getSideVector(viewParams);

      if (xOrbit != 0.0) {
        this.calculateXOrbit(viewParams, -xOrbit, sideVector);
      }

      if (yOrbit != 0.0) {
        this.calculateYOrbit(viewParams, yOrbit, sideVector);
      }

      sideVector.delete();

      const extView = this.getViewer()
        .getActiveTvExtendedView();

      extView.setView(
        viewParams.position,
        viewParams.target,
        viewParams.upVector,
        viewParams.viewFieldWidth,
        viewParams.viewFieldHeight,
        viewParams.perspective
      );
      extView.delete();
    }
  }

  end(x, y) {
    this.press = false;
    this.endInteractivity();
  }
  
  mouseleave(ev) {
    this.end()
  }

  getCenter() {
    const viewer = this.getViewer();

    let ext = viewer.getActiveExtents();

    const pSet = viewer.getSelected();
    if (!pSet.isNull() && pSet.numItems() !== 0) {
      const itr = pSet.getIterator();
      const entId = itr.getEntity();

      if (entId.getType() === 1) {
        const obj = entId.openObject();

        ext.delete();
        ext = obj.getExtents();

        obj.delete();
      } else if (entId.getType() === 2) {
        const obj = entId.openObjectAsInsert();
        const extTuple = obj.getExtents();

        ext.delete();
        ext = extTuple.ext;

        extTuple.delete();
        obj.delete();
      }

      itr.delete();
    }
    pSet.delete();

    const center = ext.center();

    ext.delete();
    return center;
  }
}