///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
/* eslint-disable no-unused-vars */

import { OdaGeAction } from './OdaGeAction';

const CLICK_DELTA = 5;
const OVERLAY_VIEW_NAME = "$OVERLAY_VIEW_NAME";

function syncOverlayView(viewer) {
  let overlayView = viewer.getViewByName(OVERLAY_VIEW_NAME);
  const activeView = viewer.activeView;

  if (!overlayView) {
    const overlayModel = viewer.getMarkupModel();
    const pDevice = viewer.getActiveDevice();

    overlayView = pDevice.createView(OVERLAY_VIEW_NAME, false);

    overlayView.addModel(overlayModel);

    activeView.addSibling(overlayView);
    pDevice.addView(overlayView);
  }

  overlayView.viewPosition = activeView.viewPosition;
  overlayView.viewTarget = activeView.viewTarget;
  overlayView.upVector = activeView.upVector;
  overlayView.viewFieldWidth = activeView.viewFieldWidth;
  overlayView.viewFieldHeight = activeView.viewFieldHeight;

  const viewPort = overlayView.getViewport();
  overlayView.setViewport(viewPort.lowerLeft, viewPort.upperRight);

  overlayView.vportRect = activeView.vportRect;

  return overlayView;
}



export class OdBaseDragger extends OdaGeAction {
  constructor(subject) {
    super(subject.visualizeJs);
    this.subject = subject
    this.needInputText = false;
    this.touchStartPoints = { x: 0, y: 0 };
    this.touchEndPoints = { x: 0, y: 0 };
    this.mouseDownPosition = { x: 0, y: 0 };
    this.autoSelect = false;
    this.onmessage = new Function();

    this.onmessage = event => this.subject.emitEvent(event)

    this.subject.eventEmitter.addDragger(this, [
      "mousemove",
      "mouseleave",
      "mousedown",
      "mouseup",
      "mouseleave",
      "click",
      "touchstart",
      "touchend",
      "touchcancel",
      "touchmove",
      "dblclick",
    ])
  }

  dispose() {
    this.subject.eventEmitter.removeDragger(this)
  }

  relativeCoords(event) {
    const bounds = event.target.getBoundingClientRect();
    event.touches && event.touches[0] && (event = event.touches[0])
    const x = event.clientX - bounds.left;
    const y = event.clientY - bounds.top;
    const rect = this.m_module.canvas.getBoundingClientRect()
    const left = rect.left
    const top = rect.top
    const right = rect.right
    const bottom = rect.bottom
    if (x <= left || x >= right || y <= top || y >= bottom) {
      return { x: x * window.devicePixelRatio, y: y * window.devicePixelRatio, isValid: false };
    }
    return { x: x * window.devicePixelRatio, y: y * window.devicePixelRatio, isValid: true };
  }

  touchstart(ev) {
    if (ev.touches.length > 1) {
      ev.preventDefault()
    }
    const relCoord = this.relativeCoords(ev);
    this.isDragging = true;
    this.touchStartPoints.x = relCoord.x;
    this.touchStartPoints.y = relCoord.y;
    this.touchEndPoints.x = relCoord.x;
    this.touchEndPoints.y = relCoord.y;
    this.start(relCoord.x, relCoord.y);
    this.onmessage({ type: 'update' });
  }

  touchend(ev) {
    this.end(this.touchEndPoints.x, this.touchEndPoints.y);
    this.isDragging = false;
    this.onmessage({ type: 'update' });
  }

  touchmove(ev) {
    const relCoord = this.relativeCoords(ev);
    const touch = ev.touches[0]
    this.touchEndPoints.x = relCoord.x;
    this.touchEndPoints.y = relCoord.y;
    this.drag(
      relCoord.x,
      relCoord.y,
      this.touchStartPoints.x - relCoord.x,
      this.touchStartPoints.y - relCoord.y);
    if (this.isDragging) {
      this.onmessage({ type: 'update' });
    }
  }

  mousedown(ev) {
    const relCoord = this.relativeCoords(ev);
    this.isDragging = true;
    this.mouseDownPosition = { x: relCoord.x, y: relCoord.y };
    this.start(this.mouseDownPosition.x, this.mouseDownPosition.y,
      ev.clientX, ev.clientY);
    this.onmessage({ type: 'update' });
  }

  mouseup(ev) {
    const relCoord = this.relativeCoords(ev);
    this.end(relCoord.x, relCoord.y);
    this.isDragging = false;
    this.onmessage({ type: 'update' });
  }

  mouseleave(ev) {
    this.mouseup(ev)
  }

  mousemove(ev) {
    const relCoord = this.relativeCoords(ev);
    if (!relCoord.isValid) {
      this.mouseup(ev)
      return
    }
    this.drag(relCoord.x, relCoord.y, ev.movementX, ev.movementY);
    if (this.isDragging) {
      this.onmessage({ type: 'update' });
    }
  }

  click(ev) {
    const relCoord = this.relativeCoords(ev);
    const x = relCoord.x;
    const y = relCoord.y;

    const isNotDragging = Math.abs(x - this.mouseDownPosition.x) < CLICK_DELTA &&
      Math.abs(y - this.mouseDownPosition.y) < CLICK_DELTA;

    const viewer = this.getViewer();

    if (viewer && viewer.getEnableAutoSelect() && isNotDragging) {
      viewer.unselect();
      viewer.select(x, y, x, y);
      const pSelected = viewer.getSelected();
      if (!pSelected.isNull() && pSelected.numItems() !== 0) {
        this.onmessage({ type: 'select', data: pSelected })
      }
      this.onmessage({ type: 'update' });
    }
  }

  dblclick(ev) {
    const viewer = this.getViewer()
    const relCoord = this.relativeCoords(ev);
    const x = relCoord.x;
    const y = relCoord.y;

    const device = viewer.getActiveDevice();
    const clickView = device.viewAt([x, y]);
    if (clickView && !clickView.active) {
      viewer.activeView = clickView;
      clickView.delete();
      this.onmessage({ type: 'update' });
    } else {
      if (viewer && viewer.getEnableAutoSelect()) {
        const pSelected = viewer.getSelected();

        if (!pSelected.isNull() && pSelected.numItems() !== 0) {
          const itr = pSelected.getIterator();
          const entity = itr.getEntity();
          viewer.zoomToEntity(entity);

          this.onmessage({ type: 'zoomToEntity', data: entity });
          this.onmessage({ type: 'update' });

          this.deleteAll([itr, entity]);
        }

        pSelected.delete();
      }
    }

    device.delete();
  }

  start(x, y) {

  }

  drag(x, y) {

  }

  end(x, y) {

  }

  beginInteractivity() {
    const view = this.getViewer().activeView;
    if (view['beginInteractivity']) {
      view.beginInteractivity(15);
      this.onmessage({ type: 'update' });
    }
    view.delete();
  }

  endInteractivity() {
    const view = this.getViewer().activeView;
    if (view['endInteractivity']) {
      view.endInteractivity();

      const device = this.getViewer().getActiveDevice();
      const canvas = this.m_module.canvas;
      device.invalidate([0, 0, canvas.width, canvas.height]);
      device.delete();
      this.onmessage({ type: 'update' });
    }
    view.delete();
  }

  getActiveMarkupEntity(type) {
    syncOverlayView(this.getViewer())
    const model = this.getViewer().getMarkupModel();
    const entityName = '$MarkupTempEntity_' + type;

    let entityId = model.appendEntity(entityName);
    
    const entity = entityId.openObject();
    entity.setColor(255, 0, 0);
    entity.setLineWeight(2);

    entity.delete();
    model.delete();

    return entityId;
  }

  deleteAll(objects) {
    for (let obj of objects) {
      obj && obj.delete && obj.delete()
    }
  }
}