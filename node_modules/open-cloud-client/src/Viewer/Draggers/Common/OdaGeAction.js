///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
export class OdaGeAction {
  constructor(module) {
    this.m_module = module;
  }

  getViewer() {
    return this.m_module.getViewer();
  }

  getModel() {
    return this.getViewer().getMarkupModel();
  }
  
  copyPoint(point) {
    const p = new this.m_module.Point3d();
    p.set(point.x, point.y, point.z);
    return p;
  }

  createVector3d() {
    return new this.m_module.Vector3d();
  }

  createPoint3d() {
    return new this.m_module.Point3d();
  }

  createMatrix3d() {
    return new this.m_module.Matrix3d();
  }

  createPlane() {
    return new this.m_module.OdTvPlane();
  }

  toVector(geVector) {
    return this.m_module.Vector3d.createFromArray(geVector);
  }

  toGeVector(v) {
    return [v.x, v.y, v.z];
  }

  toGePoint(point) {
    return [point.x, point.y, point.z];
  }

  toPoint(gePoint) {
    return this.m_module.Point3d.createFromArray(gePoint);
  }

  screenToWorld(x, y) {
    return this.toPoint(this.m_module.getViewer().screenToWorld(x, y));
  }

  toDoubleArray(points) {
    const p = [];
    for (let i = 0; i < points.length; i++) {
      p.push(points[i].x)
      p.push(points[i].y)
      p.push(points[i].z)
    }
    return p;
  }

  correctCameraTarget() {
    const params = this.getViewParams()
    let ext = this.m_module.getViewer().getActiveExtents();
    const { min, max } = ext;
    const target = this.toGePoint(params.target);
    
    const contains = (target.x >= min.x
    && target.y >= min.y
    && target.z >= min.z
    && target.x <= max.x
    && target.y <= max.y
    && target.z <= max.z );
    if(!contains) {
      params.target = ext.center()
      this.setViewParams(params)
    }
  }

  setViewParams(params) {
    const extView = this.m_module.getViewer().getActiveTvExtendedView();
    extView.setView(
      params.position,
      params.target,
      params.upVector,
      params.viewFieldWidth,
      params.viewFieldHeight,
      params.perspective
    );
    extView.delete && extView.delete();
  }

  getViewParams() {
    const view = this.m_module.getViewer().activeView;

    const obj = {
      position: view.viewPosition,
      target: view.viewTarget,
      upVector: view.upVector,
      viewFieldWidth: view.viewFieldWidth,
      viewFieldHeight: view.viewFieldHeight,
      perspective: view.perspective
    };
    view.delete && view.delete();

    return obj;
  }
}