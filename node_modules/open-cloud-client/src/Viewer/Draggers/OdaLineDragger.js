///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
import { OdBaseDragger } from './Common/OdBaseDragger.js';

export class OdaLineDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.getViewer().setEnableAutoSelect(false);
  }

  dispose() {
    super.dispose()
    this.end()
    this.points = null;
    this.drawPoints = null;
  }
  
  start(x, y) {
    const point = this.getViewer().screenToWorld(x, y);
    this.drawPoints = [point[0], point[1], point[2]]
  }

  drag(x, y) {
    if (this.isDragging) {
      const point = this.getViewer().screenToWorld(x, y);
      this.drawPoints.push(point[0], point[1], point[2]);
      this._updateFrame();
    }
  }

  end() {
    if (this.entity) {
      this.entity.delete();
      this.drawPoints = null;
      this.entity = null;
    }
  }

   _updateFrame() {
    if (this.entity) {
      const model = this.getViewer().getMarkupModel()
      model.removeEntity(this.entity);
      model.delete();
      this.entity.delete();
    }

    this.entity = this.getActiveMarkupEntity("Line");

    const entityPtr = this.entity.openObject();
    entityPtr.appendPolyline(this.drawPoints).delete();
    entityPtr.delete();
  }
}