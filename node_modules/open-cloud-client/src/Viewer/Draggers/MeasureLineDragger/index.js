///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
import { OdBaseDragger } from '../Common/OdBaseDragger.js';
import { MeasureLineItem } from './MeasureLineItem'

function renameUnit(table, unit){
  return table[unit] || unit
}

export class MeasureLineDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.lineThickness = 2
    this.press = false;
    this.autoSelect = false;
    this.gripingRadius = 5.0;
    this.firstPoint = null;
    this.secondPoint = null;

    this.m_overlayElement = document.createElement("div");
    this.m_overlayElement.style.background    = "rgba(0,0,0,0)";
    this.m_overlayElement.style.position      = "fixed";
    this.m_overlayElement.style.zIndex        = "1";
    this.m_overlayElement.style.pointerEvents = "none";

    document.body.appendChild(this.m_overlayElement);

    this.renameUnitTable = {
      "Millimeters":"mm",
      "Centimeters":"cm",
      "Meters":"m",
      "Undefined": " "
    }

    this.items = []

    this.resize()
    this._resize = () => this.resize()
    window.addEventListener('resize', this._resize)
  }

  dispose() {
    window.removeEventListener('resize', this._resize)
    super.dispose()
    this.m_overlayElement.remove()
  }

  updatePreview()
  {
    for(let item of this.items)
    {
      item.update()
    }
  }

  resize(ev) {
    const rect = this.m_module.canvas.getBoundingClientRect();

    this.m_overlayElement.style.top    = `${rect.top}px`;
    this.m_overlayElement.style.left   = `${rect.left}px`;
    this.m_overlayElement.style.width  = `${rect.width}px`;
    this.m_overlayElement.style.height = `${rect.height}px`;
  }

  getSnapPointRadius() {
    const view = this.getViewer().activeView;
    const corners = view.viewDcCorners();

    const pt1 = corners.lowerLeft;
    const pt2 = corners.upperRight;

    pt2[0] -= pt1[0];
    pt2[1] -= pt1[1];

    return Math.min(pt2[0], pt2[1]) / 120;
  }

  drag(x, y) {
    this.createNewMeasureIfNeed();
    const point = this.getViewer().getSnapPoint(x, y, this.gripingRadius);

    if (this.isDragging) {
      if (point) {
        if (this.firstPoint) {
          this.secondPoint = point;
          this.previewMeasureLine.setStartPoint(this.firstPoint);
          this.previewMeasureLine.setEndPoint(this.secondPoint);
        } else {
          this.firstPoint = point;
          this.previewMeasureLine.setStartPoint(this.firstPoint);
        }
      } else {
        this.secondPoint = null;
        this.previewMeasureLine.clear();
        this.previewMeasureLine.setStartPoint(this.firstPoint);
        this.previewMeasureLine.setEndPoint(this.getViewer().screenToWorld(x, y), false);
      }
    } else {
      if (point) {
        this.previewMeasureLine.setStartPoint(point);
      } else {
        this.previewMeasureLine.clear();
      }
    }
  }

  end() {
    if (this.firstPoint && this.secondPoint) {
      const newLineMeasure = this.createMeasureLine();
      newLineMeasure.setStartPoint(this.firstPoint);
      newLineMeasure.setEndPoint(this.secondPoint);
    }
    this.firstPoint = this.secondPoint = null;
    this.previewMeasureLine.clear();
  } 

  createNewMeasureIfNeed() {
    if (! this.previewMeasureLine) {
      this.previewMeasureLine = this.createMeasureLine();
    }
  }

  createMeasureLine() {
    const viewer = this.m_module.getViewer()
    var item = new MeasureLineItem(this.m_overlayElement, viewer, this.m_module);
    item.lineThickness = this.lineThickness || item.lineThickness
    item.setUnit(renameUnit(this.renameUnitTable,viewer.getUnit()))
    this.items.push(item);
    return item;
  }

  
}