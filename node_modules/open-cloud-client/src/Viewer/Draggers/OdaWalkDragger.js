///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
import { OdBaseDragger } from './Common/OdBaseDragger.js';


const FocalLengthConst = 42.0;//42.0 

const calcFocalLength = (lensLength, fieldWidth, fieldHeight) => {
  return (lensLength / FocalLengthConst * Math.sqrt(fieldWidth * fieldWidth + fieldHeight * fieldHeight));
}

export class OdaWalkDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;
    this.getViewer().setEnableAutoSelect(false);

    this.lastCoord = { x: 0, y: 0 }

    this.speed = 1
    this.delta = this.getViewer().activeView.viewFieldWidth / 1000

    this.keyPressMap = new Set();

    this.onKeyDown = (ev) => {
      const currentDelta = this.speed * this.delta
      this.keyPressMap.add(ev.code)

      for(let keyCode of this.keyPressMap) {
        if (keyCode === 'KeyW') {
          this.cameraWalker.moveForward(currentDelta)
        } else if (keyCode === 'KeyS') {
          this.cameraWalker.moveBackward(currentDelta)
        } else if (keyCode === 'KeyA') {
          this.cameraWalker.moveLeft(currentDelta)
        } else if (keyCode === 'KeyD') {
          this.cameraWalker.moveRight(currentDelta)
        } else if (keyCode === 'KeyQ') {
          this.cameraWalker.moveUp(currentDelta)
        } else if (keyCode === 'KeyE') {
          this.cameraWalker.moveDown(currentDelta)
        } else if (keyCode === 'NumpadSubtract' || keyCode === 'Minus') {
          this.speed = this.speed !== 1 ? this.speed - 1 : 1;
          this.subject.emitEvent({ type: 'ChangeWalkDraggerSpeed', data: this.speed})
        } else if (keyCode === 'NumpadAdd' || keyCode === 'Equal') {
          this.speed = this.speed !== 10 ? this.speed + 1 : 10;
          this.subject.emitEvent({ type: 'ChangeWalkDraggerSpeed', data: this.speed})
        }
      }
    }

    this.onKeyRelease = (ev) => {
      this.keyPressMap.delete(ev.code)
    }

    window.addEventListener('keydown', this.onKeyDown, false)
    window.addEventListener('keyup', this.onKeyRelease, false)

    if (! this.cameraId) {
      this.initialize();
    }

    this.subject._setEnableForZoomWheelDragger(false);
  }

  initialize() {
    const view = this.getViewer().activeView

    this.subject.emitEvent({type: 'StartWalkerDragger', data: null})

    this.viewParams = {
      position        : view.viewPosition,
      target          : view.viewTarget,
      upVector        : view.upVector,
      viewFieldWidth  : view.viewFieldWidth,
      viewFieldHeight : view.viewFieldHeight,
      perspective     : view.perspective,
      lensLength      : view.lensLength
    }

    const extView = this.getViewer().getActiveTvExtendedView();
    extView.setView(
      this.viewParams.position,
      this.viewParams.target,
      this.viewParams.upVector,
      this.viewParams.viewFieldWidth,
      this.viewParams.viewFieldHeight,
      true
    );
    extView.delete();

    view.lensLength = view.lensLength * 42 / 120
    
    const model = this.getViewer().getActiveModel();
    this.cameraId = model.appendCamera("Camera0")
    const pCamera = this.cameraId.openObjectAsCamera();
    var target = view.viewTarget;

    pCamera.setDisplayGlyph(false);
    pCamera.setDisplayTarget(false);
    pCamera.setAutoAdjust(true);
    pCamera.setupCamera(view.viewPosition, target, view.upVector);
    pCamera.setNearClip(false, 1.0);
    pCamera.setFarClip(false, 0.);
    pCamera.setViewParameters(
      view.viewFieldWidth,
      view.viewFieldHeight,
      true);
 
    const focalL = calcFocalLength(view.lensLength, view.viewFieldWidth, view.viewFieldHeight);
  
    {
      const pTarget = this.toPoint(view.viewTarget);
      const viewDir = this.toPoint(view.viewPosition);
      const viewDirSub = viewDir.sub(pTarget);
      const viewDirVec = viewDirSub.asVector();
      const viewDirVecNormal = viewDirVec.normalize();
  
      const geViewDir = this.toGeVector(viewDirVecNormal)
      const newGeViewDir = [geViewDir[0] * focalL, geViewDir[1] * focalL, geViewDir[2] * focalL]

      const pTarget2 = this.toPoint(view.viewTarget);
      const newGeViewDirPt = this.toPoint(newGeViewDir);

      const newPos = pTarget2.add(newGeViewDirPt);
      pCamera.setupCamera(this.toGePoint(newPos), view.viewTarget, view.upVector);

      this.deleteAll([pTarget, viewDir, viewDirSub, viewDirVec, viewDirVecNormal, pTarget2, newGeViewDirPt, newPos])
    }

    pCamera.assignView(view);
    pCamera.delete();
    model.delete();
    //pCamera.setAdjustLensLength(true);
    this.cameraWalker = new this.m_module.OdTvCameraWalker();
    this.cameraWalker.setCamera(this.cameraId);
  }

  dispose() {
    super.dispose();

    this.keyPressMap.clear();

    window.removeEventListener('keydown', this.onKeyDown)
    window.removeEventListener('keyup', this.onKeyRelease)

    if (this.cameraId)
    {
      const model = this.getViewer().getActiveModel();
      model.removeEntity(this.cameraId)
      model.delete()
      this.cameraWalker && this.cameraWalker.delete()
    }

    if (this.viewParams) {
      const extView = this.getViewer().getActiveTvExtendedView();

      extView.setView(
        this.viewParams.position,
        this.viewParams.target,
        this.viewParams.upVector,
        this.viewParams.viewFieldWidth,
        this.viewParams.viewFieldHeight,
        this.viewParams.perspective
      );
      extView.delete()

      const avp = this.getViewer().activeView

      avp.lensLength = this.viewParams.lensLength;
      avp.delete()
    }

    this.subject._setEnableForZoomWheelDragger(true);
  }

  drag(x, y, dltX, dltY) {
    const view = this.getViewer().activeView

    const focalL = calcFocalLength(view.lensLength, view.viewFieldWidth, view.viewFieldHeight);

    const hAngle = Math.atan(view.viewFieldHeight/(2 * focalL)) * 2
    const wAngle = Math.atan(view.viewFieldWidth/(2 * focalL)) * 2

    const dltAngleY = Math.abs(dltY) * hAngle / this.m_module.canvas.height * this.subject.api.options.cameraAxisYSpeed
    const dltAngleX = Math.abs(dltX) * wAngle / this.m_module.canvas.width * this.subject.api.options.cameraAxisXSpeed

    if (this.cameraId && this.isDragging) {
      if (dltX !== 0.0) {
        if (dltX > 0) {
          this.cameraWalker.turn(this.viewParams.upVector, -dltAngleX)
        } else if (dltX < 0) {
          this.cameraWalker.turn(this.viewParams.upVector, dltAngleX)
        }
      }

      if (dltY !== 0.0) {
        if (dltY < 0) {
          this.cameraWalker.turnUp(dltAngleY)
        } else if (dltY > 0) {
          this.cameraWalker.turnDown(dltAngleY)
        }
      }
    }
  }
}