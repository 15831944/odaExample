///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2002-2021, Open Design Alliance (the "Alliance").
// All rights reserved.
//
// This software and its documentation and related materials are owned by
// the Alliance. The software may only be incorporated into application
// programs owned by members of the Alliance, subject to a signed
// Membership Agreement and Supplemental Software License Agreement with the
// Alliance. The structure and organization of this software are the valuable
// trade secrets of the Alliance and its suppliers. The software is also
// protected by copyright law and international treaty provisions. Application
// programs incorporating this software must include the following statement
// with their copyright notices:
//
//   This application incorporates Open Design Alliance software pursuant to a
//   license agreement with Open Design Alliance.
//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.
//   All rights reserved.
//
// By use of this software, its documentation or related materials, you
// acknowledge and accept the above terms.
///////////////////////////////////////////////////////////////////////////////
import { OdBaseDragger } from './Common/OdBaseDragger.js';

export class OdBaseCuttingPlaneDragger extends OdBaseDragger {
  constructor(...args) {
    super(...args);
    this.press = false;

    this.getViewer().setEnableAutoSelect(false);
    //this.getViewer().getMarkupController().clear();

    const ext = this.getViewer().getActiveExtents();
    const min = ext.min();
    const max = ext.max();

    this.m_size_x = Math.abs(max[0] - min[0]) / 2.;
    this.m_size_y = Math.abs(max[1] - min[1]) / 2.;
    this.m_size_z = Math.abs(max[2] - min[2]) / 2.;

    this.m_center = this.toPoint(ext.center());
    this.m_normal = this.createNormal();

    const avp = this.getViewer().activeView;
    const plane = this.createPlane();
    plane.set(this.toGePoint(this.m_center), this.m_normal);

    avp.addCuttingPlane(plane);
    this.index = avp.numCuttingPlanes() - 1;
    avp.setEnableCuttingPlaneFill(true, 0x66, 0x66, 0x66);

    this.m_model = this.getModel();
    this.createPreview();

    this.deleteAll([ext, avp, plane]);
  }

  dispose() {
    super.dispose()

    if (this.m_entity) {
      this.m_model.removeEntity(this.m_entity);
      this.deleteAll([this.m_model, this.m_entity, this.planePreview]);
      this.m_entity = null;
      this.planePreview = null;
    }
  }


  createNormal() {
    return [0., 0., 0.];
  }

  handleDelta(delta) {
    return delta;
  }

  getPlanePreviewCoordinate() {
    return [];
  }

  start(x, y) {
    this.press = true;
    this.m_last = this.screenToWorld(x, y);
    this.m_click = { x: x, y: y };
  }

  drag(x, y) {
    if (this.press) {
      const point = this.screenToWorld(x, y);
      const delta = this.handleDelta(point.sub(this.m_last));

      const oldCenter = this.m_center;
      this.m_center = oldCenter.add(delta);

      const oldLast = this.m_last;
      this.m_last = point;

      const avp = this.getViewer().activeView;
      const plane = this.createPlane();
      const newPlane = plane.set(this.toGePoint(this.m_center), this.m_normal);
      const newCutting = avp.updateCuttingPlane(this.index, plane);

      this.drawPreview();

      this.deleteAll([avp, plane, oldCenter, delta, oldLast, newPlane, newCutting]);
    }
  }

  end(x, y) {
    this.press = false;
    if (x === this.m_click.x && y === this.m_click.y) {
      this.m_normal = [this.m_normal[0] * -1, this.m_normal[1] * -1, this.m_normal[2] * -1];

      const avp = this.getViewer().activeView;
      const plane = this.createPlane();
      plane.set(this.toGePoint(this.m_center), this.m_normal);
      avp.updateCuttingPlane(this.index, plane);

      this.deleteAll([avp, plane, this.m_center, this.m_last]);
    }
  }

  createPreview() {
    this.m_entity = this.m_model.appendEntity('&CuttingPlanePreview');

    const GeometryTypes = this.m_module.GeometryTypes;

    const transparencyDef = new this.m_module.OdTvTransparencyDef();
    const colorDef = new this.m_module.OdTvColorDef(112, 112, 112); //0x53, 0x72, 0xAE

    transparencyDef.setValue(0.9);

    const entityPtr = this.m_entity.openObject();
    entityPtr.setColor(colorDef, GeometryTypes.kFaces.value);

    colorDef.setColor(112, 112, 112); //0xcd, 0xe2, 0xff
    entityPtr.setColor(colorDef, GeometryTypes.kEdges.value);

    entityPtr.setLineWeight(5);

    entityPtr.setTransparency(transparencyDef, GeometryTypes.kFaces);
    transparencyDef.setValue(1.0);
    entityPtr.setTransparency(transparencyDef, GeometryTypes.kEdges);

    this.planePreview = entityPtr.appendPolygon(this.getPlanePreviewCoordinate());
    const polygonPtr = this.planePreview.openAsPolygon();
    polygonPtr.setFilled(true);

    this.deleteAll([transparencyDef, colorDef, entityPtr, polygonPtr, GeometryTypes]);
  }

  drawPreview() {
    const polygonPtr = this.planePreview.openAsPolygon();
    polygonPtr.setPoints(this.getPlanePreviewCoordinate());
    this.deleteAll([polygonPtr]);
  }


}