export function loadScript(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = url;
    script.async = true;
    script.onload = resolve;
    script.onerror = reject;
    document.body.appendChild(script);
  })
}

/**
 * @class
 */
export class EventEmitter {

  /**
   * @constructor
   */
  constructor() {
    this.draggers = []

    this.emitEvent = this.emitEvent.bind(this)
  }

  /**
   * Add dragger to listen couple of events
   * @function
   * @param {Object}
   * @param {Array<String>}
   */
  addDragger(dragger, events) {
    const subscriber = {
      dragger,
      events: events.map(key => ({
        key,
        fn: event => dragger[key] && dragger[key](event)
      }))
    }
    subscriber.events.forEach(ev => this.addEventListener(ev.key, ev.fn))
    this.draggers.push(subscriber)
  }

    /**
   * Remove dragger, detach to listen events
   * @function
   * @param {Object}
   */
  removeDragger(dragger) {
    const draggers = this.draggers.filter(d => d.dragger === dragger)
    draggers.forEach(dragger => {
      dragger.events.forEach(ev => this.removeEventListener(ev.key, ev.fn))
    })
    this.draggers = this.draggers.filter(d => d.dragger !== dragger)
  }

  /**
   * Subscribe on event
   * @function
   * @param {string} 
   * @param {function} 
   */
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === - 1) {
      listeners[type].push(listener);
    }
  }

  /**
   * Unsubscribe from event
   * @function
   * @param {string} 
   * @param {function} 
   */
  removeEventListener(type, listener) {

    if (this._listeners === undefined) return;

    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {

      const index = listenerArray.indexOf(listener);
      if (index !== - 1) {
        listenerArray.splice(index, 1);
      }
    }
  }

/**
 * The interface of the Event from EventEmitter.
 * @typedef {(Object | Event)} EventObject
 * @property {string} type - type of the event
 * @property {Object} data - data of the event
 */


  /**
   * Emit event
   * @function
   * @param {EventObject} 
   */
  emitEvent(event) {

    if (this._listeners === undefined) return;

    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      if (!event.target) {
        event.target = this;
      }


      // Make a copy, in case listeners are removed while iterating.
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      if (event.target === this) {
        event.target = null;
      }
    }
  }

  removeAllListeners() {
    this._listeners = []
  }

  attach(element, eventType) {
    return element.addEventListener(eventType, this.emitEvent)
  }
  detach(element, eventType) {
    return element.removeEventListener(eventType, this.emitEvent)
  }
}

export const memoize = (f) => {
  const cache = {};
  return (...args) => {
    const argStr = JSON.stringify(args);
    cache[argStr] = cache[argStr] || f(...args);
    return cache[argStr];
  };
};
export const loadVisualizeJS = memoize((url, onprogress) => {
  return loadScript(url)
  .then(() => {
    return new Promise(resolve => {
      const instance = window["getVisualizeLibInst"]({ urlMemFile: url + ".wasm", TOTAL_MEMORY: 134217728, onprogress: onprogress});
      instance.postRun.push(() => resolve(instance))
    })
  })
})

export const composingMatrixFromTransform = (translate, rotate, scale, modelCenter, matrix) => {

  const translateMatrix = matrix.setTranslation(
    [
      translate.x, 
      translate.y, 
      translate.z
    ]
  );

  const rotateMatrix = matrix.setToRotation(
    rotate.angle,
    [
      rotate.x,
      rotate.y, 
      rotate.z
    ],
    modelCenter
  );

  const scaleMatrix = matrix.setToScaling(scale, modelCenter);
  return translateMatrix.postMultBy(rotateMatrix).postMultBy(scaleMatrix);
}