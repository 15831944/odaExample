{"ast":null,"code":"///////////////////////////////////////////////////////////////////////////////\n// Copyright (C) 2002-2021, Open Design Alliance (the \"Alliance\").\n// All rights reserved.\n//\n// This software and its documentation and related materials are owned by\n// the Alliance. The software may only be incorporated into application\n// programs owned by members of the Alliance, subject to a signed\n// Membership Agreement and Supplemental Software License Agreement with the\n// Alliance. The structure and organization of this software are the valuable\n// trade secrets of the Alliance and its suppliers. The software is also\n// protected by copyright law and international treaty provisions. Application\n// programs incorporating this software must include the following statement\n// with their copyright notices:\n//\n//   This application incorporates Open Design Alliance software pursuant to a\n//   license agreement with Open Design Alliance.\n//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.\n//   All rights reserved.\n//\n// By use of this software, its documentation or related materials, you\n// acknowledge and accept the above terms.\n///////////////////////////////////////////////////////////////////////////////\nconst OVERLAY_VIEW_NAME = \"$OVERLAY_VIEW_NAME\";\nconst MARKUP_ENTITY_LINE = \"$MarkupTempEntity_Line\";\nconst MARKUP_ENTITY_TEXT = \"$MarkupTempEntity_Text\";\n\nfunction getActiveMarkupEntity(viewer, type) {\n  const model = viewer.getMarkupModel();\n  const entityName = \"$MarkupTempEntity\" + type;\n  let res = model.appendEntity(entityName);\n  res.openObject().setColor(255, 0, 0);\n  res.openObject().setLineWeight(2);\n  return res;\n}\n\nfunction logicalPoint3dToArrayValue(point) {\n  return [point.x, point.y, point.z];\n}\n\nfunction arrayPointToLogicalPoint3d(array) {\n  return {\n    x: array[0],\n    y: array[1],\n    z: array[2]\n  };\n}\n\nfunction createPreview(canvas, type, quality) {\n  return canvas.toDataURL(type, quality);\n}\n\nfunction clearOldViewPoint(viewer) {\n  const markupCtrl = viewer.getMarkupController();\n  markupCtrl.clear();\n  viewer.activeView.removeCuttingPlanes();\n}\n\nfunction syncOverlayView(viewer) {\n  let overlayView = viewer.getViewByName(OVERLAY_VIEW_NAME);\n  const activeView = viewer.activeView;\n\n  if (!overlayView) {\n    const overlayModel = viewer.getMarkupModel();\n    const pDevice = viewer.getActiveDevice();\n    overlayView = pDevice.createView(OVERLAY_VIEW_NAME, false);\n    overlayView.addModel(overlayModel);\n    activeView.addSibling(overlayView);\n    pDevice.addView(overlayView);\n  }\n\n  overlayView.viewPosition = activeView.viewPosition;\n  overlayView.viewTarget = activeView.viewTarget;\n  overlayView.upVector = activeView.upVector;\n  overlayView.viewFieldWidth = activeView.viewFieldWidth;\n  overlayView.viewFieldHeight = activeView.viewFieldHeight;\n  const viewPort = overlayView.getViewport();\n  overlayView.setViewport(viewPort.lowerLeft, viewPort.upperRight);\n  overlayView.vportRect = activeView.vportRect;\n  return overlayView;\n}\n\nfunction deleteAll(objects) {\n  for (let obj of objects) {\n    obj.delete();\n  }\n}\n\nfunction toPoint(module, gePoint) {\n  return module.Point3d.createFromArray(gePoint);\n}\n\nfunction toGePoint(point) {\n  return [point.x, point.y, point.z];\n}\n\nfunction createPlane(module) {\n  return new module.OdTvPlane();\n}\n\nexport default class ViewPointHelper {\n  constructor(module) {\n    this.m_viewer = module.getViewer();\n    this.m_module = module;\n  }\n\n  drawViewPoint(viewPoint) {\n    const viewer = this.m_viewer;\n    const view = viewer.activeView;\n    clearOldViewPoint(viewer);\n\n    if (viewPoint.orthogonal_camera) {\n      view.setView(logicalPoint3dToArrayValue(viewPoint.orthogonal_camera.view_point), logicalPoint3dToArrayValue(viewPoint.orthogonal_camera.direction), logicalPoint3dToArrayValue(viewPoint.orthogonal_camera.up_vector), viewPoint.orthogonal_camera.field_width, viewPoint.orthogonal_camera.field_height, true);\n    }\n\n    syncOverlayView(viewer);\n\n    if (viewPoint.lines) {\n      for (let line of viewPoint.lines) {\n        const entityData = [];\n\n        for (let point of line.points) {\n          entityData.push(point.x, point.y, point.z);\n        }\n\n        const entity = getActiveMarkupEntity(viewer, \"Line\");\n        const entityPtr = entity.openObject();\n        entityPtr.appendPolyline(entityData);\n        deleteAll([entityPtr, entity]);\n      }\n    }\n\n    const pos = toPoint(this.m_module, view.viewPosition);\n    const target = toPoint(this.m_module, view.viewTarget);\n    const normal = pos.sub(target).asVector();\n\n    if (viewPoint.texts) {\n      for (var text of viewPoint.texts) {\n        const entity = getActiveMarkupEntity(viewer, \"Text\");\n        const entityPtr = entity.openObject();\n        const geomData = entityPtr.appendText(logicalPoint3dToArrayValue(text.position), text.text);\n        const textPtr = geomData.openAsText();\n        textPtr.setNormal(toGePoint(normal));\n        textPtr.setRotation(text.angle);\n        textPtr.setTextSize(text.text_size);\n        deleteAll([textPtr, geomData, entityPtr, entity]);\n      }\n    }\n\n    if (viewPoint.clipping_planes) {\n      for (let clippingPlane of viewPoint.clipping_planes) {\n        const plane = createPlane(this.m_module);\n        plane.set(logicalPoint3dToArrayValue(clippingPlane.location), logicalPoint3dToArrayValue(clippingPlane.direction));\n        view.addCuttingPlane(plane);\n        view.setEnableCuttingPlaneFill(true, 0x66, 0x66, 0x66);\n      }\n    }\n  }\n\n  getViewPoint(canvas, opt) {\n    const viewer = this.m_viewer;\n    const view = viewer.activeView;\n    const viewPointData = {};\n    viewPointData.orthogonal_camera = {\n      view_point: arrayPointToLogicalPoint3d(view.viewPosition),\n      direction: arrayPointToLogicalPoint3d(view.viewTarget),\n      up_vector: arrayPointToLogicalPoint3d(view.upVector),\n      field_width: view.viewFieldWidth,\n      field_height: view.viewFieldHeight\n    };\n    viewPointData.lines = [];\n    viewPointData.texts = [];\n    viewPointData.clipping_planes = [];\n    {\n      const model = viewer.getMarkupModel();\n\n      for (const itr = model.getEntitiesIterator(); !itr.done(); itr.step()) {\n        const entity = itr.getEntity();\n        const entityPtr = entity.openObject();\n        const geomItr = entityPtr.getGeometryDataIterator();\n\n        if (geomItr.done()) {\n          continue;\n        }\n\n        const geometryId = geomItr.getGeometryData();\n\n        if (entityPtr.getName() === MARKUP_ENTITY_LINE) {\n          const polyLinePtr = geometryId.openAsPolyline();\n          const points = polyLinePtr.getPoints();\n          const newLineItem = {\n            points: []\n          };\n\n          for (const point of points) {\n            newLineItem.points.push(arrayPointToLogicalPoint3d(point));\n          }\n\n          viewPointData.lines.push(newLineItem);\n          deleteAll([polyLinePtr]);\n        } else if (entityPtr.getName() === MARKUP_ENTITY_TEXT) {\n          const textPtr = geometryId.openAsText();\n          const position = textPtr.getPosition();\n          const newLineItem = {\n            position: arrayPointToLogicalPoint3d(position),\n            text: textPtr.getString(),\n            angle: textPtr.getRotation(),\n            text_size: textPtr.getTextSize()\n          };\n          viewPointData.texts.push(newLineItem);\n          deleteAll([textPtr]);\n        }\n\n        deleteAll([entityPtr, entity]);\n      }\n    }\n    const cuttingPlaneSize = view.numCuttingPlanes();\n\n    for (let i = 0; i < cuttingPlaneSize; i++) {\n      const cuttingPlane = view.getCuttingPlane(i);\n      viewPointData.clipping_planes.push({\n        location: arrayPointToLogicalPoint3d(cuttingPlane.getOrigin()),\n        direction: arrayPointToLogicalPoint3d(cuttingPlane.normal())\n      });\n    }\n\n    const fixOpt = opt || {\n      type: \"image/jpeg\",\n      quality: 0.25\n    };\n    fixOpt.type = fixOpt.type || \"image/jpeg\";\n    fixOpt.quality = fixOpt.quality || 0.25;\n    viewPointData.snapshot = {\n      data: createPreview(canvas, fixOpt.type, fixOpt.quality)\n    };\n    return viewPointData;\n  }\n\n}","map":{"version":3,"sources":["/Users/yutianjian/test/oda/src/viewer/ViewPointHelper.js"],"names":["OVERLAY_VIEW_NAME","MARKUP_ENTITY_LINE","MARKUP_ENTITY_TEXT","getActiveMarkupEntity","viewer","type","model","getMarkupModel","entityName","res","appendEntity","openObject","setColor","setLineWeight","logicalPoint3dToArrayValue","point","x","y","z","arrayPointToLogicalPoint3d","array","createPreview","canvas","quality","toDataURL","clearOldViewPoint","markupCtrl","getMarkupController","clear","activeView","removeCuttingPlanes","syncOverlayView","overlayView","getViewByName","overlayModel","pDevice","getActiveDevice","createView","addModel","addSibling","addView","viewPosition","viewTarget","upVector","viewFieldWidth","viewFieldHeight","viewPort","getViewport","setViewport","lowerLeft","upperRight","vportRect","deleteAll","objects","obj","delete","toPoint","module","gePoint","Point3d","createFromArray","toGePoint","createPlane","OdTvPlane","ViewPointHelper","constructor","m_viewer","getViewer","m_module","drawViewPoint","viewPoint","view","orthogonal_camera","setView","view_point","direction","up_vector","field_width","field_height","lines","line","entityData","points","push","entity","entityPtr","appendPolyline","pos","target","normal","sub","asVector","texts","text","geomData","appendText","position","textPtr","openAsText","setNormal","setRotation","angle","setTextSize","text_size","clipping_planes","clippingPlane","plane","set","location","addCuttingPlane","setEnableCuttingPlaneFill","getViewPoint","opt","viewPointData","itr","getEntitiesIterator","done","step","getEntity","geomItr","getGeometryDataIterator","geometryId","getGeometryData","getName","polyLinePtr","openAsPolyline","getPoints","newLineItem","getPosition","getString","getRotation","getTextSize","cuttingPlaneSize","numCuttingPlanes","i","cuttingPlane","getCuttingPlane","getOrigin","fixOpt","snapshot","data"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,iBAAiB,GAAG,oBAA1B;AACA,MAAMC,kBAAkB,GAAG,wBAA3B;AACA,MAAMC,kBAAkB,GAAG,wBAA3B;;AAEA,SAASC,qBAAT,CAA+BC,MAA/B,EAAuCC,IAAvC,EAA6C;AAC3C,QAAMC,KAAK,GAAGF,MAAM,CAACG,cAAP,EAAd;AACA,QAAMC,UAAU,GAAG,sBAAsBH,IAAzC;AAEA,MAAII,GAAG,GAAGH,KAAK,CAACI,YAAN,CAAmBF,UAAnB,CAAV;AACAC,EAAAA,GAAG,CAACE,UAAJ,GAAiBC,QAAjB,CAA0B,GAA1B,EAA+B,CAA/B,EAAkC,CAAlC;AACAH,EAAAA,GAAG,CAACE,UAAJ,GAAiBE,aAAjB,CAA+B,CAA/B;AAEA,SAAOJ,GAAP;AACD;;AAED,SAASK,0BAAT,CAAoCC,KAApC,EAA2C;AACzC,SAAO,CAACA,KAAK,CAACC,CAAP,EAAUD,KAAK,CAACE,CAAhB,EAAmBF,KAAK,CAACG,CAAzB,CAAP;AACD;;AAED,SAASC,0BAAT,CAAoCC,KAApC,EAA2C;AACzC,SAAO;AAAEJ,IAAAA,CAAC,EAAEI,KAAK,CAAC,CAAD,CAAV;AAAeH,IAAAA,CAAC,EAAEG,KAAK,CAAC,CAAD,CAAvB;AAA4BF,IAAAA,CAAC,EAAEE,KAAK,CAAC,CAAD;AAApC,GAAP;AACD;;AAED,SAASC,aAAT,CAAuBC,MAAvB,EAA+BjB,IAA/B,EAAqCkB,OAArC,EAA8C;AAC5C,SAAOD,MAAM,CAACE,SAAP,CAAiBnB,IAAjB,EAAuBkB,OAAvB,CAAP;AACD;;AAED,SAASE,iBAAT,CAA2BrB,MAA3B,EAAmC;AACjC,QAAMsB,UAAU,GAAGtB,MAAM,CAACuB,mBAAP,EAAnB;AACAD,EAAAA,UAAU,CAACE,KAAX;AACAxB,EAAAA,MAAM,CAACyB,UAAP,CAAkBC,mBAAlB;AACD;;AAED,SAASC,eAAT,CAAyB3B,MAAzB,EAAiC;AAC/B,MAAI4B,WAAW,GAAG5B,MAAM,CAAC6B,aAAP,CAAqBjC,iBAArB,CAAlB;AACA,QAAM6B,UAAU,GAAGzB,MAAM,CAACyB,UAA1B;;AAEA,MAAI,CAACG,WAAL,EAAkB;AAChB,UAAME,YAAY,GAAG9B,MAAM,CAACG,cAAP,EAArB;AACA,UAAM4B,OAAO,GAAG/B,MAAM,CAACgC,eAAP,EAAhB;AAEAJ,IAAAA,WAAW,GAAGG,OAAO,CAACE,UAAR,CAAmBrC,iBAAnB,EAAsC,KAAtC,CAAd;AAEAgC,IAAAA,WAAW,CAACM,QAAZ,CAAqBJ,YAArB;AAEAL,IAAAA,UAAU,CAACU,UAAX,CAAsBP,WAAtB;AACAG,IAAAA,OAAO,CAACK,OAAR,CAAgBR,WAAhB;AACD;;AAEDA,EAAAA,WAAW,CAACS,YAAZ,GAA2BZ,UAAU,CAACY,YAAtC;AACAT,EAAAA,WAAW,CAACU,UAAZ,GAAyBb,UAAU,CAACa,UAApC;AACAV,EAAAA,WAAW,CAACW,QAAZ,GAAuBd,UAAU,CAACc,QAAlC;AACAX,EAAAA,WAAW,CAACY,cAAZ,GAA6Bf,UAAU,CAACe,cAAxC;AACAZ,EAAAA,WAAW,CAACa,eAAZ,GAA8BhB,UAAU,CAACgB,eAAzC;AAEA,QAAMC,QAAQ,GAAGd,WAAW,CAACe,WAAZ,EAAjB;AACAf,EAAAA,WAAW,CAACgB,WAAZ,CAAwBF,QAAQ,CAACG,SAAjC,EAA4CH,QAAQ,CAACI,UAArD;AAEAlB,EAAAA,WAAW,CAACmB,SAAZ,GAAwBtB,UAAU,CAACsB,SAAnC;AAEA,SAAOnB,WAAP;AACD;;AAED,SAASoB,SAAT,CAAmBC,OAAnB,EAA4B;AAC1B,OAAK,IAAIC,GAAT,IAAgBD,OAAhB,EAAyB;AACvBC,IAAAA,GAAG,CAACC,MAAJ;AACD;AACF;;AAED,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,OAAzB,EAAkC;AAChC,SAAOD,MAAM,CAACE,OAAP,CAAeC,eAAf,CAA+BF,OAA/B,CAAP;AACD;;AAED,SAASG,SAAT,CAAmB9C,KAAnB,EAA0B;AACxB,SAAO,CAACA,KAAK,CAACC,CAAP,EAAUD,KAAK,CAACE,CAAhB,EAAmBF,KAAK,CAACG,CAAzB,CAAP;AACD;;AAED,SAAS4C,WAAT,CAAqBL,MAArB,EAA6B;AAC3B,SAAO,IAAIA,MAAM,CAACM,SAAX,EAAP;AACD;;AAED,eAAe,MAAMC,eAAN,CAAsB;AACnCC,EAAAA,WAAW,CAACR,MAAD,EAAS;AAClB,SAAKS,QAAL,GAAgBT,MAAM,CAACU,SAAP,EAAhB;AACA,SAAKC,QAAL,GAAgBX,MAAhB;AACD;;AAEDY,EAAAA,aAAa,CAACC,SAAD,EAAY;AACvB,UAAMlE,MAAM,GAAG,KAAK8D,QAApB;AACA,UAAMK,IAAI,GAAGnE,MAAM,CAACyB,UAApB;AAEAJ,IAAAA,iBAAiB,CAACrB,MAAD,CAAjB;;AAEA,QAAIkE,SAAS,CAACE,iBAAd,EAAiC;AAC/BD,MAAAA,IAAI,CAACE,OAAL,CACE3D,0BAA0B,CAACwD,SAAS,CAACE,iBAAV,CAA4BE,UAA7B,CAD5B,EAEE5D,0BAA0B,CAACwD,SAAS,CAACE,iBAAV,CAA4BG,SAA7B,CAF5B,EAGE7D,0BAA0B,CAACwD,SAAS,CAACE,iBAAV,CAA4BI,SAA7B,CAH5B,EAIEN,SAAS,CAACE,iBAAV,CAA4BK,WAJ9B,EAKEP,SAAS,CAACE,iBAAV,CAA4BM,YAL9B,EAME,IANF;AAQD;;AAED/C,IAAAA,eAAe,CAAC3B,MAAD,CAAf;;AAEA,QAAIkE,SAAS,CAACS,KAAd,EAAqB;AACnB,WAAK,IAAIC,IAAT,IAAiBV,SAAS,CAACS,KAA3B,EAAkC;AAChC,cAAME,UAAU,GAAG,EAAnB;;AACA,aAAK,IAAIlE,KAAT,IAAkBiE,IAAI,CAACE,MAAvB,EAA+B;AAC7BD,UAAAA,UAAU,CAACE,IAAX,CAAgBpE,KAAK,CAACC,CAAtB,EAAyBD,KAAK,CAACE,CAA/B,EAAkCF,KAAK,CAACG,CAAxC;AACD;;AAED,cAAMkE,MAAM,GAAGjF,qBAAqB,CAACC,MAAD,EAAS,MAAT,CAApC;AACA,cAAMiF,SAAS,GAAGD,MAAM,CAACzE,UAAP,EAAlB;AAEA0E,QAAAA,SAAS,CAACC,cAAV,CAAyBL,UAAzB;AAEA7B,QAAAA,SAAS,CAAC,CAACiC,SAAD,EAAYD,MAAZ,CAAD,CAAT;AACD;AACF;;AAED,UAAMG,GAAG,GAAG/B,OAAO,CAAC,KAAKY,QAAN,EAAgBG,IAAI,CAAC9B,YAArB,CAAnB;AACA,UAAM+C,MAAM,GAAGhC,OAAO,CAAC,KAAKY,QAAN,EAAgBG,IAAI,CAAC7B,UAArB,CAAtB;AACA,UAAM+C,MAAM,GAAGF,GAAG,CAACG,GAAJ,CAAQF,MAAR,EAAgBG,QAAhB,EAAf;;AAEA,QAAIrB,SAAS,CAACsB,KAAd,EAAqB;AACnB,WAAK,IAAIC,IAAT,IAAiBvB,SAAS,CAACsB,KAA3B,EAAkC;AAChC,cAAMR,MAAM,GAAGjF,qBAAqB,CAACC,MAAD,EAAS,MAAT,CAApC;AACA,cAAMiF,SAAS,GAAGD,MAAM,CAACzE,UAAP,EAAlB;AACA,cAAMmF,QAAQ,GAAGT,SAAS,CAACU,UAAV,CAAqBjF,0BAA0B,CAAC+E,IAAI,CAACG,QAAN,CAA/C,EAAgEH,IAAI,CAACA,IAArE,CAAjB;AACA,cAAMI,OAAO,GAAGH,QAAQ,CAACI,UAAT,EAAhB;AAEAD,QAAAA,OAAO,CAACE,SAAR,CAAkBtC,SAAS,CAAC4B,MAAD,CAA3B;AACAQ,QAAAA,OAAO,CAACG,WAAR,CAAoBP,IAAI,CAACQ,KAAzB;AACAJ,QAAAA,OAAO,CAACK,WAAR,CAAoBT,IAAI,CAACU,SAAzB;AAEAnD,QAAAA,SAAS,CAAC,CAAC6C,OAAD,EAAUH,QAAV,EAAoBT,SAApB,EAA+BD,MAA/B,CAAD,CAAT;AACD;AACF;;AAED,QAAId,SAAS,CAACkC,eAAd,EAA+B;AAC7B,WAAK,IAAIC,aAAT,IAA0BnC,SAAS,CAACkC,eAApC,EAAqD;AACnD,cAAME,KAAK,GAAG5C,WAAW,CAAC,KAAKM,QAAN,CAAzB;AACAsC,QAAAA,KAAK,CAACC,GAAN,CACE7F,0BAA0B,CAAC2F,aAAa,CAACG,QAAf,CAD5B,EAEE9F,0BAA0B,CAAC2F,aAAa,CAAC9B,SAAf,CAF5B;AAKAJ,QAAAA,IAAI,CAACsC,eAAL,CAAqBH,KAArB;AACAnC,QAAAA,IAAI,CAACuC,yBAAL,CAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,EAAiD,IAAjD;AACD;AACF;AACF;;AAEDC,EAAAA,YAAY,CAACzF,MAAD,EAAS0F,GAAT,EAAc;AACxB,UAAM5G,MAAM,GAAG,KAAK8D,QAApB;AACA,UAAMK,IAAI,GAAGnE,MAAM,CAACyB,UAApB;AAEA,UAAMoF,aAAa,GAAG,EAAtB;AACAA,IAAAA,aAAa,CAACzC,iBAAd,GAAkC;AAChCE,MAAAA,UAAU,EAAEvD,0BAA0B,CAACoD,IAAI,CAAC9B,YAAN,CADN;AAEhCkC,MAAAA,SAAS,EAAExD,0BAA0B,CAACoD,IAAI,CAAC7B,UAAN,CAFL;AAGhCkC,MAAAA,SAAS,EAAEzD,0BAA0B,CAACoD,IAAI,CAAC5B,QAAN,CAHL;AAIhCkC,MAAAA,WAAW,EAAEN,IAAI,CAAC3B,cAJc;AAKhCkC,MAAAA,YAAY,EAAEP,IAAI,CAAC1B;AALa,KAAlC;AAQAoE,IAAAA,aAAa,CAAClC,KAAd,GAAsB,EAAtB;AACAkC,IAAAA,aAAa,CAACrB,KAAd,GAAsB,EAAtB;AACAqB,IAAAA,aAAa,CAACT,eAAd,GAAgC,EAAhC;AAEA;AACE,YAAMlG,KAAK,GAAGF,MAAM,CAACG,cAAP,EAAd;;AACA,WAAK,MAAM2G,GAAG,GAAG5G,KAAK,CAAC6G,mBAAN,EAAjB,EAA8C,CAACD,GAAG,CAACE,IAAJ,EAA/C,EAA2DF,GAAG,CAACG,IAAJ,EAA3D,EAAuE;AACrE,cAAMjC,MAAM,GAAG8B,GAAG,CAACI,SAAJ,EAAf;AACA,cAAMjC,SAAS,GAAGD,MAAM,CAACzE,UAAP,EAAlB;AAEA,cAAM4G,OAAO,GAAGlC,SAAS,CAACmC,uBAAV,EAAhB;;AAEA,YAAID,OAAO,CAACH,IAAR,EAAJ,EAAoB;AAClB;AACD;;AAED,cAAMK,UAAU,GAAGF,OAAO,CAACG,eAAR,EAAnB;;AAEA,YAAIrC,SAAS,CAACsC,OAAV,OAAwB1H,kBAA5B,EAAgD;AAC9C,gBAAM2H,WAAW,GAAGH,UAAU,CAACI,cAAX,EAApB;AACA,gBAAM3C,MAAM,GAAG0C,WAAW,CAACE,SAAZ,EAAf;AAEA,gBAAMC,WAAW,GAAG;AAClB7C,YAAAA,MAAM,EAAE;AADU,WAApB;;AAIA,eAAK,MAAMnE,KAAX,IAAoBmE,MAApB,EAA4B;AAC1B6C,YAAAA,WAAW,CAAC7C,MAAZ,CAAmBC,IAAnB,CAAwBhE,0BAA0B,CAACJ,KAAD,CAAlD;AACD;;AAEDkG,UAAAA,aAAa,CAAClC,KAAd,CAAoBI,IAApB,CAAyB4C,WAAzB;AACA3E,UAAAA,SAAS,CAAC,CAACwE,WAAD,CAAD,CAAT;AACD,SAdD,MAcO,IAAIvC,SAAS,CAACsC,OAAV,OAAwBzH,kBAA5B,EAAgD;AACrD,gBAAM+F,OAAO,GAAGwB,UAAU,CAACvB,UAAX,EAAhB;AACA,gBAAMF,QAAQ,GAAGC,OAAO,CAAC+B,WAAR,EAAjB;AAEA,gBAAMD,WAAW,GAAG;AAClB/B,YAAAA,QAAQ,EAAE7E,0BAA0B,CAAC6E,QAAD,CADlB;AAElBH,YAAAA,IAAI,EAAEI,OAAO,CAACgC,SAAR,EAFY;AAGlB5B,YAAAA,KAAK,EAAEJ,OAAO,CAACiC,WAAR,EAHW;AAIlB3B,YAAAA,SAAS,EAAEN,OAAO,CAACkC,WAAR;AAJO,WAApB;AAOAlB,UAAAA,aAAa,CAACrB,KAAd,CAAoBT,IAApB,CAAyB4C,WAAzB;AAEA3E,UAAAA,SAAS,CAAC,CAAC6C,OAAD,CAAD,CAAT;AACD;;AAED7C,QAAAA,SAAS,CAAC,CAACiC,SAAD,EAAYD,MAAZ,CAAD,CAAT;AACD;AACF;AAED,UAAMgD,gBAAgB,GAAG7D,IAAI,CAAC8D,gBAAL,EAAzB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,gBAApB,EAAsCE,CAAC,EAAvC,EAA2C;AACzC,YAAMC,YAAY,GAAGhE,IAAI,CAACiE,eAAL,CAAqBF,CAArB,CAArB;AACArB,MAAAA,aAAa,CAACT,eAAd,CAA8BrB,IAA9B,CAAmC;AACjCyB,QAAAA,QAAQ,EAAEzF,0BAA0B,CAACoH,YAAY,CAACE,SAAb,EAAD,CADH;AAEjC9D,QAAAA,SAAS,EAAExD,0BAA0B,CAACoH,YAAY,CAAC9C,MAAb,EAAD;AAFJ,OAAnC;AAID;;AAED,UAAMiD,MAAM,GAAG1B,GAAG,IAAI;AAAE3G,MAAAA,IAAI,EAAE,YAAR;AAAsBkB,MAAAA,OAAO,EAAE;AAA/B,KAAtB;AACAmH,IAAAA,MAAM,CAACrI,IAAP,GAAcqI,MAAM,CAACrI,IAAP,IAAe,YAA7B;AACAqI,IAAAA,MAAM,CAACnH,OAAP,GAAiBmH,MAAM,CAACnH,OAAP,IAAkB,IAAnC;AAEA0F,IAAAA,aAAa,CAAC0B,QAAd,GAAyB;AACvBC,MAAAA,IAAI,EAAEvH,aAAa,CAACC,MAAD,EAASoH,MAAM,CAACrI,IAAhB,EAAsBqI,MAAM,CAACnH,OAA7B;AADI,KAAzB;AAIA,WAAO0F,aAAP;AACD;;AA7JkC","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n// Copyright (C) 2002-2021, Open Design Alliance (the \"Alliance\").\n// All rights reserved.\n//\n// This software and its documentation and related materials are owned by\n// the Alliance. The software may only be incorporated into application\n// programs owned by members of the Alliance, subject to a signed\n// Membership Agreement and Supplemental Software License Agreement with the\n// Alliance. The structure and organization of this software are the valuable\n// trade secrets of the Alliance and its suppliers. The software is also\n// protected by copyright law and international treaty provisions. Application\n// programs incorporating this software must include the following statement\n// with their copyright notices:\n//\n//   This application incorporates Open Design Alliance software pursuant to a\n//   license agreement with Open Design Alliance.\n//   Open Design Alliance Copyright (C) 2002-2021 by Open Design Alliance.\n//   All rights reserved.\n//\n// By use of this software, its documentation or related materials, you\n// acknowledge and accept the above terms.\n///////////////////////////////////////////////////////////////////////////////\n\nconst OVERLAY_VIEW_NAME = \"$OVERLAY_VIEW_NAME\";\nconst MARKUP_ENTITY_LINE = \"$MarkupTempEntity_Line\";\nconst MARKUP_ENTITY_TEXT = \"$MarkupTempEntity_Text\";\n\nfunction getActiveMarkupEntity(viewer, type) {\n  const model = viewer.getMarkupModel();\n  const entityName = \"$MarkupTempEntity\" + type;\n\n  let res = model.appendEntity(entityName);\n  res.openObject().setColor(255, 0, 0);\n  res.openObject().setLineWeight(2);\n\n  return res;\n}\n\nfunction logicalPoint3dToArrayValue(point) {\n  return [point.x, point.y, point.z];\n}\n\nfunction arrayPointToLogicalPoint3d(array) {\n  return { x: array[0], y: array[1], z: array[2] };\n}\n\nfunction createPreview(canvas, type, quality) {\n  return canvas.toDataURL(type, quality);\n}\n\nfunction clearOldViewPoint(viewer) {\n  const markupCtrl = viewer.getMarkupController();\n  markupCtrl.clear();\n  viewer.activeView.removeCuttingPlanes();\n}\n\nfunction syncOverlayView(viewer) {\n  let overlayView = viewer.getViewByName(OVERLAY_VIEW_NAME);\n  const activeView = viewer.activeView;\n\n  if (!overlayView) {\n    const overlayModel = viewer.getMarkupModel();\n    const pDevice = viewer.getActiveDevice();\n\n    overlayView = pDevice.createView(OVERLAY_VIEW_NAME, false);\n\n    overlayView.addModel(overlayModel);\n\n    activeView.addSibling(overlayView);\n    pDevice.addView(overlayView);\n  }\n\n  overlayView.viewPosition = activeView.viewPosition;\n  overlayView.viewTarget = activeView.viewTarget;\n  overlayView.upVector = activeView.upVector;\n  overlayView.viewFieldWidth = activeView.viewFieldWidth;\n  overlayView.viewFieldHeight = activeView.viewFieldHeight;\n\n  const viewPort = overlayView.getViewport();\n  overlayView.setViewport(viewPort.lowerLeft, viewPort.upperRight);\n\n  overlayView.vportRect = activeView.vportRect;\n\n  return overlayView;\n}\n\nfunction deleteAll(objects) {\n  for (let obj of objects) {\n    obj.delete();\n  }\n}\n\nfunction toPoint(module, gePoint) {\n  return module.Point3d.createFromArray(gePoint);\n}\n\nfunction toGePoint(point) {\n  return [point.x, point.y, point.z];\n}\n\nfunction createPlane(module) {\n  return new module.OdTvPlane();\n}\n\nexport default class ViewPointHelper {\n  constructor(module) {\n    this.m_viewer = module.getViewer();\n    this.m_module = module;\n  }\n\n  drawViewPoint(viewPoint) {\n    const viewer = this.m_viewer;\n    const view = viewer.activeView;\n\n    clearOldViewPoint(viewer);\n\n    if (viewPoint.orthogonal_camera) {\n      view.setView(\n        logicalPoint3dToArrayValue(viewPoint.orthogonal_camera.view_point),\n        logicalPoint3dToArrayValue(viewPoint.orthogonal_camera.direction),\n        logicalPoint3dToArrayValue(viewPoint.orthogonal_camera.up_vector),\n        viewPoint.orthogonal_camera.field_width,\n        viewPoint.orthogonal_camera.field_height,\n        true\n      );\n    }\n\n    syncOverlayView(viewer);\n\n    if (viewPoint.lines) {\n      for (let line of viewPoint.lines) {\n        const entityData = [];\n        for (let point of line.points) {\n          entityData.push(point.x, point.y, point.z);\n        }\n\n        const entity = getActiveMarkupEntity(viewer, \"Line\");\n        const entityPtr = entity.openObject();\n\n        entityPtr.appendPolyline(entityData);\n\n        deleteAll([entityPtr, entity]);\n      }\n    }\n\n    const pos = toPoint(this.m_module, view.viewPosition);\n    const target = toPoint(this.m_module, view.viewTarget);\n    const normal = pos.sub(target).asVector();\n\n    if (viewPoint.texts) {\n      for (var text of viewPoint.texts) {\n        const entity = getActiveMarkupEntity(viewer, \"Text\");\n        const entityPtr = entity.openObject();\n        const geomData = entityPtr.appendText(logicalPoint3dToArrayValue(text.position), text.text);\n        const textPtr = geomData.openAsText();\n\n        textPtr.setNormal(toGePoint(normal));\n        textPtr.setRotation(text.angle);\n        textPtr.setTextSize(text.text_size);\n\n        deleteAll([textPtr, geomData, entityPtr, entity]);\n      }\n    }\n\n    if (viewPoint.clipping_planes) {\n      for (let clippingPlane of viewPoint.clipping_planes) {\n        const plane = createPlane(this.m_module);\n        plane.set(\n          logicalPoint3dToArrayValue(clippingPlane.location),\n          logicalPoint3dToArrayValue(clippingPlane.direction)\n        );\n\n        view.addCuttingPlane(plane);\n        view.setEnableCuttingPlaneFill(true, 0x66, 0x66, 0x66);\n      }\n    }\n  }\n\n  getViewPoint(canvas, opt) {\n    const viewer = this.m_viewer;\n    const view = viewer.activeView;\n\n    const viewPointData = {};\n    viewPointData.orthogonal_camera = {\n      view_point: arrayPointToLogicalPoint3d(view.viewPosition),\n      direction: arrayPointToLogicalPoint3d(view.viewTarget),\n      up_vector: arrayPointToLogicalPoint3d(view.upVector),\n      field_width: view.viewFieldWidth,\n      field_height: view.viewFieldHeight,\n    };\n\n    viewPointData.lines = [];\n    viewPointData.texts = [];\n    viewPointData.clipping_planes = [];\n\n    {\n      const model = viewer.getMarkupModel();\n      for (const itr = model.getEntitiesIterator(); !itr.done(); itr.step()) {\n        const entity = itr.getEntity();\n        const entityPtr = entity.openObject();\n\n        const geomItr = entityPtr.getGeometryDataIterator();\n\n        if (geomItr.done()) {\n          continue;\n        }\n\n        const geometryId = geomItr.getGeometryData();\n\n        if (entityPtr.getName() === MARKUP_ENTITY_LINE) {\n          const polyLinePtr = geometryId.openAsPolyline();\n          const points = polyLinePtr.getPoints();\n\n          const newLineItem = {\n            points: [],\n          };\n\n          for (const point of points) {\n            newLineItem.points.push(arrayPointToLogicalPoint3d(point));\n          }\n\n          viewPointData.lines.push(newLineItem);\n          deleteAll([polyLinePtr]);\n        } else if (entityPtr.getName() === MARKUP_ENTITY_TEXT) {\n          const textPtr = geometryId.openAsText();\n          const position = textPtr.getPosition();\n\n          const newLineItem = {\n            position: arrayPointToLogicalPoint3d(position),\n            text: textPtr.getString(),\n            angle: textPtr.getRotation(),\n            text_size: textPtr.getTextSize(),\n          };\n\n          viewPointData.texts.push(newLineItem);\n\n          deleteAll([textPtr]);\n        }\n\n        deleteAll([entityPtr, entity]);\n      }\n    }\n\n    const cuttingPlaneSize = view.numCuttingPlanes();\n    for (let i = 0; i < cuttingPlaneSize; i++) {\n      const cuttingPlane = view.getCuttingPlane(i);\n      viewPointData.clipping_planes.push({\n        location: arrayPointToLogicalPoint3d(cuttingPlane.getOrigin()),\n        direction: arrayPointToLogicalPoint3d(cuttingPlane.normal()),\n      });\n    }\n\n    const fixOpt = opt || { type: \"image/jpeg\", quality: 0.25 };\n    fixOpt.type = fixOpt.type || \"image/jpeg\";\n    fixOpt.quality = fixOpt.quality || 0.25;\n\n    viewPointData.snapshot = {\n      data: createPreview(canvas, fixOpt.type, fixOpt.quality),\n    };\n\n    return viewPointData;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}